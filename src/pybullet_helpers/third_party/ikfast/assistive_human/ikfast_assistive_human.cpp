/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004a generated on 2024-12-13 18:08:06.684099
/// Generated using solver transform6d
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp

#include "Python.h"

#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
// #define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
// IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x1000004a);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan std::isnan
#endif
#ifndef isinf
#define isinf std::isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64,x65,x66,x67,x68,x69,x70;
x0=IKcos(j[1]);
x1=IKcos(j[2]);
x2=IKcos(j[3]);
x3=IKsin(j[1]);
x4=IKsin(j[3]);
x5=IKcos(j[4]);
x6=IKsin(j[2]);
x7=IKsin(j[4]);
x8=IKcos(j[5]);
x9=IKsin(j[5]);
x10=IKsin(j[6]);
x11=IKcos(j[6]);
x12=IKsin(j[0]);
x13=IKcos(j[0]);
x14=((0.27900001)*x6);
x15=((0.4)*x9);
x16=((1.0)*x6);
x17=((1.0)*x4);
x18=((0.4)*x8);
x19=((1.0)*x2);
x20=((1.0)*x3);
x21=((0.4)*x5);
x22=((1.0)*x9);
x23=((1.0)*x8);
x24=((0.27900001)*x4);
x25=(x13*x3);
x26=(x1*x12);
x27=(x12*x6);
x28=(x0*x7);
x29=(x0*x1);
x30=(x1*x13);
x31=(x0*x12);
x32=(x13*x6);
x33=(x0*x13);
x34=(x17*x3);
x35=(x12*x16);
x36=(x2*x31);
x37=(x2*x33);
x38=((((-1.0)*x3*x35))+x30);
x39=(x32+((x26*x3)));
x40=((((-1.0)*x19*x29))+x34);
x41=((((-1.0)*x20*x30))+x35);
x42=(((x19*x3))+((x17*x29)));
x43=((-1.0)*x42);
x44=((((-1.0)*x13*x16))+(((-1.0)*x20*x26)));
x45=(x38*x5);
x46=((((-1.0)*x26))+(((-1.0)*x16*x25)));
x47=(x38*x7);
x48=(x4*x41);
x49=(x46*x7);
x50=(x46*x5);
x51=(x43*x5);
x52=(x4*x44);
x53=(x37+x48);
x54=(((x42*x7))+(((-1.0)*x0*x16*x5)));
x55=((((-1.0)*x16*x28))+x51);
x56=((((-1.0)*x17*x31))+(((-1.0)*x19*x39)));
x57=(x36+x52);
x58=(((x19*(((((-1.0)*x1*x25))+x35))))+(((-1.0)*x17*x33)));
x59=((((-1.0)*x17*x41))+(((-1.0)*x19*x33)));
x60=(x5*x53);
x61=(x54*x8);
x62=(x56*x9);
x63=(x59*x7);
x64=(x47+((x5*x57)));
x65=(((x7*(((((-1.0)*x17*x44))+(((-1.0)*x19*x31))))))+x45);
x66=(x45+((x7*(((((-1.0)*x36))+(((-1.0)*x52)))))));
x67=(x50+x63);
x68=((((-1.0)*x49))+(((-1.0)*x60)));
x69=(x66*x8);
x70=(x67*x8);
eerot[0]=(((x8*(((((-1.0)*x34))+((x2*x29))))))+((x54*x9)));
eerot[1]=(((x10*x55))+((x11*(((((-1.0)*x22*x40))+(((-1.0)*x23*x54)))))));
eerot[2]=(((x10*((x61+((x40*x9))))))+((x11*x55)));
eetrans[0]=(((x5*(((((-1.0)*x24*x29))+(((-0.27900001)*x2*x3))))))+((x11*(((((-0.4)*x28*x6))+((x21*x43))))))+(((-0.17900000508718)*x29))+(((-1.0)*x14*x28))+((x10*((((x18*x54))+((x15*x40)))))));
eerot[3]=(((x8*((((x31*x4))+((x2*x39))))))+((x65*x9)));
eerot[4]=(((x10*x64))+((x11*(((((-1.0)*x69))+(((-1.0)*x62)))))));
eerot[5]=(((x10*((x62+((x65*x8))))))+((x11*x64)));
eetrans[1]=(((x7*(((((0.27900001)*x30))+(((-1.0)*x12*x14*x3))))))+(((-0.17900000508718)*x26*x3))+(((-0.17900000508718)*x32))+((x5*(((((0.27900001)*x36))+((x24*x44))))))+((x11*(((((0.4)*x47))+((x21*x57))))))+((x10*((((x15*x56))+((x18*x66))))))+(((-0.07075)*x12)));
eerot[6]=(((x9*(((((-1.0)*x50))+(((-1.0)*x63))))))+((x58*x8)));
eerot[7]=(((x11*((x70+((x58*x9))))))+((x10*x68)));
eerot[8]=(((x11*x68))+((x10*(((((-1.0)*x23*x67))+(((-1.0)*x22*x58)))))));
eetrans[2]=((0.07075)+((x5*(((((-0.27900001)*x48))+(((-0.27900001)*x37))))))+((x11*(((((-0.4)*x60))+(((-0.4)*x49))))))+(((0.17900000508718)*x1*x25))+(((0.07075)*x13))+(((-0.17900000508718)*x27))+((x10*(((((-1.0)*x18*x67))+(((-1.0)*x15*x58))))))+((x7*((((x14*x25))+(((0.27900001)*x26)))))));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {2}; return freeparams; }
IKFAST_API int GetNumJoints() { return 7; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,j2,cj2,sj2,htj2,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6,_ij2[2], _nj2;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1;  _ij2[0] = -1; _ij2[1] = -1; _nj2 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j2=pfree[0]; cj2=cos(pfree[0]); sj2=sin(pfree[0]), htj2=tan(pfree[0]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((-1.0)*r22);
new_r01=r21;
new_r02=((-1.0)*r20);
new_px=((0.07075)+(((-1.0)*pz))+(((0.4)*r22)));
new_r10=r12;
new_r11=((-1.0)*r11);
new_r12=r10;
new_py=((((-0.4)*r12))+py);
new_r20=r02;
new_r21=((-1.0)*r01);
new_r22=r00;
new_pz=(px+(((-0.4)*r02)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x71=((1.0)*px);
IkReal x72=((1.0)*pz);
IkReal x73=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x73))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x72)));
rxp0_2=((((-1.0)*r10*x71))+((py*r00)));
rxp1_0=((((-1.0)*r21*x73))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x72)));
rxp1_2=(((py*r01))+(((-1.0)*r11*x71)));
rxp2_0=((((-1.0)*r22*x73))+((pz*r12)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x72)));
rxp2_2=(((py*r02))+(((-1.0)*r12*x71)));
IkReal op[8+1], zeror[8];
int numroots;
IkReal x74=((0.17900000508718)*cj2);
IkReal x75=((0.27900001)*r20);
IkReal x76=((1.0)*pz);
IkReal x77=((1.0)*pp);
IkReal x78=((0.55800002)*npx);
IkReal x79=((-0.0407944412587896)+(((-1.0)*x77))+x78);
IkReal x80=((-0.0407944412587896)+(((-1.0)*x77))+(((-1.0)*x78)));
IkReal x81=(x75+x74);
IkReal x82=((((-1.0)*x74))+(((-1.0)*x76))+x75);
IkReal x83=((((-1.0)*x76))+x81);
IkReal x84=((((-1.0)*x75))+(((-1.0)*x76))+x74);
IkReal x85=((((-1.0)*x76))+(((-1.0)*x81)));
IkReal gconst0=x82;
IkReal gconst1=x85;
IkReal gconst2=x79;
IkReal gconst3=x80;
IkReal gconst4=x82;
IkReal gconst5=x85;
IkReal gconst6=x79;
IkReal gconst7=x80;
IkReal gconst8=x83;
IkReal gconst9=x84;
IkReal gconst10=x79;
IkReal gconst11=x80;
IkReal gconst12=x83;
IkReal gconst13=x84;
IkReal gconst14=x79;
IkReal gconst15=x80;
IkReal x86=r21*r21;
IkReal x87=cj2*cj2;
IkReal x88=npy*npy;
IkReal x89=(gconst0*gconst11);
IkReal x90=(gconst5*gconst6);
IkReal x91=((1.0)*gconst12);
IkReal x92=(gconst1*gconst6);
IkReal x93=(gconst10*gconst9);
IkReal x94=(gconst13*gconst14);
IkReal x95=(gconst14*gconst5);
IkReal x96=(npy*r21);
IkReal x97=((0.0630910709077053)*cj2);
IkReal x98=((1.0)*gconst2);
IkReal x99=((0.0157727677269263)*cj2);
IkReal x100=(gconst4*gconst9);
IkReal x101=((0.622728044640001)*gconst11);
IkReal x102=(gconst0*gconst3);
IkReal x103=(gconst1*gconst10);
IkReal x104=(gconst11*gconst8);
IkReal x105=(gconst14*gconst9);
IkReal x106=((0.622728044640001)*gconst6);
IkReal x107=((1.0)*gconst13);
IkReal x108=(gconst1*gconst14);
IkReal x109=((0.050657001439672)*cj2);
IkReal x110=(gconst1*gconst7);
IkReal x111=((1.24545608928)*gconst12);
IkReal x112=(gconst12*gconst8);
IkReal x113=(gconst1*gconst12);
IkReal x114=(gconst13*gconst8);
IkReal x115=(gconst12*gconst7);
IkReal x116=(gconst0*gconst4);
IkReal x117=((1.24545608928)*gconst4);
IkReal x118=(gconst3*gconst8);
IkReal x119=(gconst12*gconst9);
IkReal x120=(gconst15*gconst4);
IkReal x121=(gconst1*gconst2);
IkReal x122=(gconst13*gconst6);
IkReal x123=(gconst6*gconst9);
IkReal x124=((0.0315455354538526)*cj2);
IkReal x125=(gconst4*gconst7);
IkReal x126=(gconst1*gconst4);
IkReal x127=(gconst2*gconst9);
IkReal x128=((0.31136402232)*gconst11);
IkReal x129=(gconst12*gconst15);
IkReal x130=(gconst15*gconst2);
IkReal x131=((0.622728044640001)*gconst3);
IkReal x132=(gconst13*x109);
IkReal x133=(gconst14*x86);
IkReal x134=((2.49091217856)*x88);
IkReal x135=((1.0)*x125);
IkReal x136=(gconst5*x109);
IkReal x137=(gconst3*x86);
IkReal x138=((0.00256613179485893)*x87);
IkReal x139=(gconst6*x86);
IkReal x140=(gconst11*x86);
IkReal x141=(gconst1*x88);
IkReal x142=(gconst9*x138);
IkReal x143=(x86*x87);
IkReal x144=(gconst12*x101*x96);
IkReal x145=((0.622728044640001)*x105*x96);
IkReal x146=(x128*x133);
IkReal x147=(gconst9*x111*x88);
IkReal x148=(gconst9*x124*x96);
IkReal x149=(gconst12*x124*x96);
IkReal x150=(x133*x99);
IkReal x151=(x140*x99);
IkReal x152=(gconst4*x101*x96);
IkReal x153=(gconst12*x131*x96);
IkReal x154=((0.622728044640001)*x108*x96);
IkReal x155=(gconst9*x106*x96);
IkReal x156=((1.24545608928)*x100*x88);
IkReal x157=(x111*x141);
IkReal x158=((0.000799001117450518)*x143);
IkReal x159=(x128*x139);
IkReal x160=((0.31136402232)*gconst3*x133);
IkReal x161=(gconst4*x124*x96);
IkReal x162=(gconst1*x124*x96);
IkReal x163=(x139*x99);
IkReal x164=(x137*x99);
IkReal x165=(gconst4*x131*x96);
IkReal x166=((0.622728044640001)*x92*x96);
IkReal x167=((0.31136402232)*gconst6*x137);
IkReal x168=(x117*x141);
IkReal x169=(x148+x149);
IkReal x170=(x146+x147);
IkReal x171=(x168+x167);
IkReal x172=(x166+x165);
IkReal x173=(x151+x150);
IkReal x174=(x163+x164);
IkReal x175=(x144+x145);
IkReal x176=(x162+x161);
IkReal x177=(x155+x154+x153+x152);
IkReal x178=(x160+x157+x156+x159+x158);
op[0]=((((-1.0)*x170))+(((-1.0)*x93*x94))+((x129*x93))+x175+((x104*x94))+(((-1.0)*gconst15*x104*x91)));
op[1]=(((gconst8*x109*x94))+((gconst12*x109*x93))+(((-1.0)*gconst12*x104*x109))+(((-1.0)*x173))+x169+((x104*x132))+(((-1.0)*x132*x93))+(((-1.0)*gconst15*x109*x112))+(((-1.0)*gconst9*x109*x94))+((gconst15*x109*x119)));
op[2]=((((-1.0)*x104*x120))+(((-1.0)*x101*x133))+(((-1.0)*x103*x94))+((x89*x94))+(((-1.0)*gconst9*x94*x98))+(((-1.0)*gconst7*x104*x91))+(((-1.0)*x112*x138))+(((-1.0)*gconst15*x118*x91))+(((-1.0)*x178))+(((-1.0)*x93*x95))+((gconst11*x111*x96))+((x103*x129))+(((-1.0)*gconst6*x107*x93))+((x114*x138))+x177+(((1.24545608928)*x105*x96))+((x118*x94))+(((-1.0)*gconst13*x142))+((x104*x122))+((x115*x93))+((x120*x93))+(((-1.0)*gconst15*x89*x91))+((x119*x138))+((x119*x130))+((x104*x95))+(((-1.0)*x119*x134)));
op[3]=((((-1.0)*gconst3*x109*x112))+((gconst8*x109*x95))+((gconst12*x96*x97))+((gconst2*x109*x119))+((gconst12*x103*x109))+(((-1.0)*gconst8*x109*x120))+((gconst15*x100*x109))+(((-1.0)*gconst7*x109*x112))+(((-1.0)*x174))+(((-1.0)*gconst1*x109*x94))+((gconst9*x109*x115))+(((-1.0)*x124*x140))+(((-1.0)*gconst4*x104*x109))+(((-1.0)*gconst12*x109*x89))+(((-1.0)*x124*x133))+((gconst9*x96*x97))+x176+(((-1.0)*gconst0*x109*x129))+((x104*x136))+((gconst6*x109*x114))+(((-1.0)*gconst9*x109*x122))+((x132*x89))+((gconst4*x109*x93))+(((-1.0)*x136*x93))+(((-1.0)*gconst9*x109*x95))+(((-1.0)*x127*x132))+((gconst0*x109*x94))+((gconst3*x109*x114))+((gconst15*x109*x113))+(((-1.0)*x103*x132)));
op[4]=((((-1.0)*x101*x139))+(((-1.0)*gconst0*gconst12*x138))+((gconst11*x117*x96))+(((-1.0)*x104*x135))+(((-1.0)*x113*x134))+(((-1.0)*gconst7*x118*x91))+(((-1.0)*x103*x95))+((x89*x95))+(((-1.0)*x118*x120))+(((-1.0)*gconst1*x94*x98))+(((-1.0)*x170))+(((-1.0)*x171))+((x125*x93))+(((-1.0)*gconst9*x95*x98))+((x102*x94))+((x103*x120))+(((-1.0)*x90*x93))+(((-1.0)*gconst9*x122*x98))+((x103*x115))+((gconst5*gconst8*x138))+x172+x175+(((-1.0)*gconst5*x142))+(((-1.0)*gconst10*x107*x92))+((gconst0*gconst13*x138))+((x113*x138))+((x113*x130))+((x118*x95))+(((1.24545608928)*x123*x96))+((x115*x127))+((gconst3*gconst6*x114))+((x122*x89))+(((-1.0)*gconst7*x89*x91))+(((-1.0)*gconst15*x102*x91))+(((-0.00159800223490104)*x143))+((gconst3*x111*x96))+(((-1.0)*gconst1*gconst13*x138))+(((-1.0)*gconst4*gconst8*x138))+((x100*x138))+((x100*x130))+(((-1.0)*x131*x133))+(((1.24545608928)*x108*x96))+((x104*x90))+(((-1.0)*x120*x89))+(((-1.0)*x100*x134)));
op[5]=(((gconst8*x109*x90))+((gconst2*x109*x113))+(((-1.0)*gconst8*x109*x125))+(((-1.0)*x173))+(((-1.0)*gconst4*x109*x89))+(((-1.0)*gconst1*x109*x95))+((x102*x132))+(((-1.0)*gconst0*x109*x115))+((x136*x89))+(((-1.0)*x124*x139))+(((-1.0)*x124*x137))+((gconst4*x96*x97))+((gconst4*x103*x109))+x169+((gconst12*x109*x110))+((gconst1*x109*x120))+((gconst2*x100*x109))+(((-1.0)*x121*x132))+((gconst0*x109*x122))+((gconst1*x96*x97))+(((-1.0)*x132*x92))+(((-1.0)*gconst12*x102*x109))+(((-1.0)*gconst15*x109*x116))+(((-1.0)*gconst9*x109*x90))+(((-1.0)*gconst4*x109*x118))+(((-1.0)*x127*x136))+((gconst0*x109*x95))+((x118*x136))+((gconst7*x100*x109))+(((-1.0)*x103*x136)));
op[6]=((((1.24545608928)*x92*x96))+((gconst0*gconst5*x138))+(((-1.0)*x103*x90))+((x89*x90))+(((-1.0)*x178))+((x102*x95))+(((-1.0)*x106*x137))+((x103*x125))+((gconst12*gconst2*x110))+((x102*x122))+(((-1.0)*x116*x138))+(((-1.0)*x126*x134))+x177+(((-1.0)*x102*x120))+((x120*x121))+(((-1.0)*gconst1*gconst5*x138))+((gconst3*x117*x96))+((x118*x90))+(((-1.0)*gconst7*x102*x91))+((x126*x138))+(((-1.0)*gconst13*x92*x98))+(((-1.0)*gconst9*x90*x98))+(((-1.0)*x135*x89))+((gconst2*gconst7*x100))+(((-1.0)*x118*x135))+(((-1.0)*gconst1*x95*x98)));
op[7]=(((gconst4*x109*x121))+(((-1.0)*gconst7*x109*x116))+(((-1.0)*x174))+(((-1.0)*gconst1*x109*x90))+((x102*x136))+x176+(((-1.0)*x121*x136))+(((-1.0)*gconst4*x102*x109))+((gconst0*x109*x90))+((gconst4*x109*x110)));
op[8]=(((gconst2*gconst4*x110))+(((-1.0)*x171))+((x102*x90))+x172+(((-1.0)*gconst1*x90*x98))+(((-1.0)*x102*x135)));
polyroots8(op,zeror,numroots);
IkReal j1array[8], cj1array[8], sj1array[8], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[8]={true,true,true,true,true,true,true,true};
_nj1 = 8;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j6eval[3];
IkReal x179=(npy*r20);
IkReal x180=((100000000.0)*pz);
IkReal x181=((50000000.0)*pp);
IkReal x182=(npx*r21);
IkReal x183=((1266425.0359918)*cj2*sj1);
IkReal x184=((17900000.508718)*cj1*cj2);
j6eval[0]=((((-1.0)*x182))+x179);
j6eval[1]=((IKabs((((r20*x183))+(((-2039722.06293948)*r20))+((npx*x184))+((npx*x180))+(((-1.0)*r20*x181)))))+(IKabs(((((-2039722.06293948)*r21))+((r21*x183))+((npy*x180))+((npy*x184))+(((-1.0)*r21*x181))))));
j6eval[2]=IKsign(((((27900001.0)*x179))+(((-27900001.0)*x182))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r21))+(IKabs(r20)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[2];
IkReal x185=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x185);
rxp1_0=(pz*r11);
rxp1_1=(r01*x185);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x186=r00*r00;
IkReal x187=((0.15568201116)*pp);
IkReal x188=((0.0407944412587896)*r10);
IkReal x189=(px*r01);
IkReal x190=(py*r11);
IkReal x191=(py*x186);
IkReal x192=((0.00394319193173158)*cj2*sj1);
IkReal x193=((1.0)*pp*r10);
IkReal x194=(px*r00*r10);
IkReal x195=((0.025328500719836)*cj2*r10*sj1);
j6eval[0]=0;
j6eval[1]=((IKabs(((((-1.0)*x188*x189))+(((-1.0)*x188*x190))+(((-1.0)*x189*x193))+(((-1.0)*x190*x193))+((x189*x195))+((x190*x195)))))+(((6.42334970205558)*(IKabs(((((-1.0)*x192*x194))+((x187*x194))+(((-0.00635096065931685)*x191))+(((-1.0)*py*x192))+(((-1.0)*x187*x191))+((x191*x192))+(((0.00635096065931685)*py))+(((0.00635096065931685)*x194))+((py*x187))))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
IkReal x196=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x196);
rxp1_0=(pz*r11);
rxp1_1=(r01*x196);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x197=r00*r00;
IkReal x198=((0.00635096065931685)*px);
IkReal x199=(py*r01);
IkReal x200=((1.0)*pp);
IkReal x201=(cj2*sj1);
IkReal x202=((0.00394319193173158)*px);
IkReal x203=(px*r00*r01);
IkReal x204=((0.15568201116)*pp*px);
j6eval[0]=0;
j6eval[1]=((IKabs(((((-1.0)*x200*x203))+(((0.025328500719836)*x201*x203))+(((-1.0)*r10*x199*x200))+(((-0.0407944412587896)*x203))+(((-0.0407944412587896)*r10*x199))+(((0.025328500719836)*r10*x199*x201)))))+(((6.42334970205558)*(IKabs(((((-1.0)*x197*x201*x202))+((x201*x202))+(((0.00394319193173158)*r11*x199*x201))+(((-1.0)*x198))+(((-1.0)*x204))+((x197*x204))+(((-0.00635096065931685)*r11*x199))+(((-0.15568201116)*pp*r11*x199))+((x197*x198))))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
IkReal x205=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x205);
rxp1_0=(pz*r11);
rxp1_1=(r01*x205);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x206=py*py;
IkReal x207=((2.0)*px*py);
j6eval[0]=(pp+(((-1.0)*(pz*pz))));
j6eval[1]=(((r01*r11*x207))+(((-1.0)*x206*(r00*r00)))+(px*px)+((x206*(r11*r11)))+x206+((r00*r10*x207)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
IkReal x208=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x208);
rxp1_0=(pz*r11);
rxp1_1=(r01*x208);
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
px=0;
py=0;
pp=pz*pz;
rxp0_2=0;
rxp1_2=0;
IkReal x209=pz*pz;
IkReal x210=(r00*r11);
IkReal x211=(r01*r10);
IkReal x212=((0.31136402232)*x209);
IkReal x213=((0.00788638386346316)*cj2*sj1);
IkReal x214=(((x210*x212))+((x211*x213))+(((0.0127019213186337)*x210)));
IkReal x215=(((x210*x213))+((x211*x212))+(((0.0127019213186337)*x211)));
j0eval[0]=((IKabs((x215+(((-1.0)*x214)))))+(((2.0)*(IKabs((x214+(((-1.0)*x215))))))));
if( IKabs(j0eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j0, j6]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j0evalpoly[1];
IkReal x216=pz*pz;
IkReal x217=(r00*r11);
IkReal x218=(r01*r10);
IkReal x219=((0.31136402232)*x216);
IkReal x220=((0.00788638386346316)*cj2*sj1);
IkReal x221=(((x218*x219))+(((0.0127019213186337)*x218))+((x217*x220)));
IkReal x222=((((0.0127019213186337)*x217))+((x218*x220))+((x217*x219)));
IkReal x223=(x222+(((-1.0)*x221)));
IkReal x224=(x221+(((-1.0)*x222)));
op[0]=x223;
op[1]=0;
op[2]=x223;
op[3]=0;
op[4]=x224;
op[5]=0;
op[6]=x224;
polyroots6(op,zeror,numroots);
IkReal j0array[6], cj0array[6], sj0array[6], tempj0array[1];
int numsolutions = 0;
for(int ij0 = 0; ij0 < numroots; ++ij0)
{
IkReal htj0 = zeror[ij0];
tempj0array[0]=((2.0)*(atan(htj0)));
for(int kj0 = 0; kj0 < 1; ++kj0)
{
j0array[numsolutions] = tempj0array[kj0];
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
numsolutions++;
}
}
bool j0valid[6]={true,true,true,true,true,true};
_nj0 = 6;
for(int ij0 = 0; ij0 < numsolutions; ++ij0)
    {
if( !j0valid[ij0] )
{
    continue;
}
    j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
htj0 = IKtan(j0/2);

IkReal x225=pz*pz;
IkReal x226=(r00*r11);
IkReal x227=(r01*r10);
IkReal x228=((0.0127019213186337)*x227);
IkReal x229=((0.31136402232)*x225);
IkReal x230=((0.00788638386346316)*cj2*sj1);
IkReal x231=(x226*x230);
IkReal x232=(x227*x229);
IkReal x233=((((0.0127019213186337)*x226))+((x227*x230))+((x226*x229)));
IkReal x234=(x228+x232+x231);
IkReal x235=((((-1.0)*x234))+x233);
j0evalpoly[0]=((((htj0*htj0)*(((((-1.0)*x233))+x234))))+((x235*(htj0*htj0*htj0*htj0)))+(((-1.0)*x233))+x234+((x235*(htj0*htj0*htj0*htj0*htj0*htj0))));
if( IKabs(j0evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < numsolutions; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
{
IkReal j6eval[2];
IkReal x236=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x236);
rxp1_0=(pz*r11);
rxp1_1=(r01*x236);
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
px=0;
py=0;
pp=pz*pz;
rxp0_2=0;
rxp1_2=0;
j6eval[0]=r22;
j6eval[1]=IKsign(r22);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
IkReal x237=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x237);
rxp1_0=(pz*r11);
rxp1_1=(r01*x237);
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
px=0;
py=0;
pp=pz*pz;
rxp0_2=0;
rxp1_2=0;
IkReal x238=(cj0*r22);
j6eval[0]=x238;
j6eval[1]=IKsign(x238);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
IkReal x239=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x239);
rxp1_0=(pz*r11);
rxp1_1=(r01*x239);
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
px=0;
py=0;
pp=pz*pz;
rxp0_2=0;
rxp1_2=0;
IkReal x240=(r22*sj0);
j6eval[0]=x240;
j6eval[1]=IKsign(x240);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j0))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
IkReal x241=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x241);
rxp1_0=(pz*r11);
rxp1_1=(r01*x241);
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
px=0;
py=0;
pp=pz*pz;
rxp0_2=0;
rxp1_2=0;
sj0=0;
cj0=1.0;
j0=0;
j6eval[0]=r22;
j6eval[1]=((4.02349648299051)+(((1558.76639228497)*(pz*pz*pz*pz)))+(sj2*sj2)+(((158.388018450417)*(pz*pz))));
j6eval[2]=IKsign(r22);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x242=pz*pz;
IkReal x243=((5.0e+15)*sj2);
IkReal x244=((1.9740607844523e+17)*x242);
CheckValue<IkReal> x245 = IKatan2WithCheck(IkReal(((((1.00293275983369e+16)*r10))+(((-1.0)*r00*x243))+((r10*x244)))),IkReal(((((1.00293275983369e+16)*r11))+(((-1.0)*r01*x243))+((r11*x244)))),IKFAST_ATAN2_MAGTHRESH);
if(!x245.valid){
continue;
}
CheckValue<IkReal> x246=IKPowWithIntegerCheck(IKsign(r22),-1);
if(!x246.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x245.value)+(((1.5707963267949)*(x246.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x247=IKcos(j6);
IkReal x248=IKsin(j6);
IkReal x249=pz*pz;
IkReal x250=(r00*x247);
IkReal x251=(r01*x248);
evalcond[0]=((((-0.27900001)*r11*x248))+(((0.27900001)*r10*x247))+(((-0.17900000508718)*sj2)));
evalcond[1]=((-0.359049938224661)+(((-7.06713780918728)*x249))+(((0.27900001)*x250))+(((-0.27900001)*x251)));
evalcond[2]=((-0.0508055662587896)+(((0.039478501415)*x250))+(((-1.0)*x249))+(((-0.039478501415)*x251)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
IkReal x1016=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1016);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1016);
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
px=0;
py=0;
pp=pz*pz;
rxp0_2=0;
rxp1_2=0;
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
j6eval[0]=r22;
j6eval[1]=IKsign(r22);
j6eval[2]=((4.02349648299051)+(((1558.76639228497)*(pz*pz*pz*pz)))+(sj2*sj2)+(((158.388018450417)*(pz*pz))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1017=pz*pz;
IkReal x1018=((5.0e+15)*sj2);
IkReal x1019=((1.9740607844523e+17)*x1017);
CheckValue<IkReal> x1020 = IKatan2WithCheck(IkReal(((((-1.00293275983369e+16)*r10))+((r00*x1018))+(((-1.0)*r10*x1019)))),IkReal(((((-1.00293275983369e+16)*r11))+(((-1.0)*r11*x1019))+((r01*x1018)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1020.valid){
continue;
}
CheckValue<IkReal> x1021=IKPowWithIntegerCheck(IKsign(r22),-1);
if(!x1021.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1020.value)+(((1.5707963267949)*(x1021.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1022=IKcos(j6);
IkReal x1023=IKsin(j6);
IkReal x1024=pz*pz;
IkReal x1025=(r00*x1022);
IkReal x1026=(r01*x1023);
evalcond[0]=((((0.17900000508718)*sj2))+(((0.27900001)*r10*x1022))+(((-0.27900001)*r11*x1023)));
evalcond[1]=((0.359049938224661)+(((7.06713780918728)*x1024))+(((0.27900001)*x1025))+(((-0.27900001)*x1026)));
evalcond[2]=((-0.0508055662587896)+(((-1.0)*x1024))+(((0.039478501415)*x1026))+(((-0.039478501415)*x1025)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
IkReal x1027=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1027);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1027);
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
px=0;
py=0;
pp=pz*pz;
rxp0_2=0;
rxp1_2=0;
sj0=1.0;
cj0=0;
j0=1.5707963267949;
j6eval[0]=r22;
j6eval[1]=((4.02349648299051)+(((1558.76639228497)*(pz*pz*pz*pz)))+(sj2*sj2)+(((158.388018450417)*(pz*pz))));
j6eval[2]=IKsign(r22);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1028=pz*pz;
IkReal x1029=((5.0e+15)*sj2);
IkReal x1030=((1.9740607844523e+17)*x1028);
CheckValue<IkReal> x1031 = IKatan2WithCheck(IkReal(((((-1.0)*r10*x1029))+(((-1.0)*r00*x1030))+(((-1.00293275983369e+16)*r00)))),IkReal(((((-1.0)*r11*x1029))+(((-1.0)*r01*x1030))+(((-1.00293275983369e+16)*r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1031.valid){
continue;
}
CheckValue<IkReal> x1032=IKPowWithIntegerCheck(IKsign(r22),-1);
if(!x1032.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1031.value)+(((1.5707963267949)*(x1032.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1033=IKcos(j6);
IkReal x1034=IKsin(j6);
IkReal x1035=pz*pz;
IkReal x1036=(r10*x1033);
IkReal x1037=((0.27900001)*x1034);
evalcond[0]=((((0.17900000508718)*sj2))+(((-1.0)*r01*x1037))+(((0.27900001)*r00*x1033)));
evalcond[1]=((-0.359049938224661)+(((-7.06713780918728)*x1035))+(((0.27900001)*x1036))+(((-1.0)*r11*x1037)));
evalcond[2]=((-0.0508055662587896)+(((-1.0)*x1035))+(((0.039478501415)*x1036))+(((-0.039478501415)*r11*x1034)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
IkReal x1038=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1038);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1038);
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
px=0;
py=0;
pp=pz*pz;
rxp0_2=0;
rxp1_2=0;
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
j6eval[0]=r22;
j6eval[1]=((4.02349648299051)+(((1558.76639228497)*(pz*pz*pz*pz)))+(sj2*sj2)+(((158.388018450417)*(pz*pz))));
j6eval[2]=IKsign(r22);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1039=pz*pz;
IkReal x1040=((5.0e+15)*sj2);
IkReal x1041=((1.9740607844523e+17)*x1039);
CheckValue<IkReal> x1042 = IKatan2WithCheck(IkReal(((((1.00293275983369e+16)*r00))+((r00*x1041))+((r10*x1040)))),IkReal((((r11*x1040))+(((1.00293275983369e+16)*r01))+((r01*x1041)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1042.valid){
continue;
}
CheckValue<IkReal> x1043=IKPowWithIntegerCheck(IKsign(r22),-1);
if(!x1043.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1042.value)+(((1.5707963267949)*(x1043.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1044=IKcos(j6);
IkReal x1045=IKsin(j6);
IkReal x1046=pz*pz;
IkReal x1047=(r10*x1044);
IkReal x1048=((0.27900001)*x1045);
evalcond[0]=((((-1.0)*r01*x1048))+(((0.27900001)*r00*x1044))+(((-0.17900000508718)*sj2)));
evalcond[1]=((0.359049938224661)+(((-1.0)*r11*x1048))+(((7.06713780918728)*x1046))+(((0.27900001)*x1047)));
evalcond[2]=((-0.0508055662587896)+(((-0.039478501415)*x1047))+(((0.039478501415)*r11*x1045))+(((-1.0)*x1046)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1049=cj0*cj0;
IkReal x1050=((551375702416494.0)*r01);
IkReal x1051=(cj0*sj0);
IkReal x1052=((551375702416494.0)*r00);
IkReal x1053=((1.39500005e+15)*r00);
IkReal x1054=(cj2*sj1);
IkReal x1055=((1.39500005e+15)*sj2);
IkReal x1056=((1.39500005e+15)*r01);
IkReal x1057=(r11*x1055);
CheckValue<IkReal> x1058 = IKatan2WithCheck(IkReal((x1052+(((-1.39500005e+15)*r10*x1051*x1054))+((x1053*x1054))+(((-1.0)*x1049*x1053*x1054))+((r10*x1055))+(((-551375702416494.0)*r10*x1051))+(((-1.0)*r10*x1049*x1055))+(((-1.0)*x1049*x1052))+((sj2*x1051*x1053)))),IkReal((((r01*x1051*x1055))+((x1054*x1056))+x1050+x1057+(((-1.39500005e+15)*r11*x1051*x1054))+(((-1.0)*x1049*x1050))+(((-1.0)*x1049*x1057))+(((-551375702416494.0)*r11*x1051))+(((-1.0)*x1049*x1054*x1056)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1058.valid){
continue;
}
CheckValue<IkReal> x1059=IKPowWithIntegerCheck(IKsign((r22*sj0)),-1);
if(!x1059.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1058.value)+(((-1.5707963267949)*(x1059.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x1060=IKcos(j6);
IkReal x1061=IKsin(j6);
IkReal x1062=((0.17900000508718)*cj0);
IkReal x1063=(cj2*sj1);
IkReal x1064=((0.039478501415)*cj0);
IkReal x1065=((0.27900001)*r01);
IkReal x1066=((0.17900000508718)*sj0);
IkReal x1067=((0.27900001)*sj0);
IkReal x1068=((0.27900001)*cj0);
IkReal x1069=(sj0*x1061);
IkReal x1070=(r00*x1060);
IkReal x1071=(r11*x1061);
IkReal x1072=(r10*x1060);
evalcond[0]=((((-0.07075)*cj0))+(((0.27900001)*x1070))+((sj2*x1066))+(((-1.0)*x1062*x1063))+(((-1.0)*x1061*x1065)));
evalcond[1]=((((-1.0)*x1063*x1066))+(((0.27900001)*x1072))+(((-0.07075)*sj0))+(((-0.27900001)*x1071))+(((-1.0)*sj2*x1062)));
evalcond[2]=(((x1068*x1072))+(((-1.0)*x1068*x1071))+(((-1.0)*x1067*x1070))+(((-0.17900000508718)*sj2))+((x1065*x1069)));
evalcond[3]=((-0.07075)+((x1068*x1070))+(((-1.0)*cj0*x1061*x1065))+((x1067*x1072))+(((-0.17900000508718)*x1063))+(((-1.0)*x1067*x1071)));
evalcond[4]=((-0.0508055662587896)+(((-0.039478501415)*r11*x1069))+(((-1.0)*r01*x1061*x1064))+(((0.039478501415)*sj0*x1072))+(((-1.0)*(pz*pz)))+((x1064*x1070)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1073=cj0*cj0;
IkReal x1074=(cj0*sj0);
IkReal x1075=((1.39500005e+15)*sj2);
IkReal x1076=((1.39500005e+15)*cj2*sj1);
IkReal x1077=(r10*x1073);
IkReal x1078=(r11*x1073);
CheckValue<IkReal> x1079=IKPowWithIntegerCheck(IKsign((cj0*r22)),-1);
if(!x1079.valid){
continue;
}
CheckValue<IkReal> x1080 = IKatan2WithCheck(IkReal(((((-551375702416494.0)*x1077))+((r10*x1074*x1075))+(((-1.0)*x1076*x1077))+((r00*x1074*x1076))+((r00*x1073*x1075))+(((551375702416494.0)*r00*x1074)))),IkReal(((((551375702416494.0)*r01*x1074))+(((-551375702416494.0)*x1078))+(((-1.0)*x1076*x1078))+((r01*x1074*x1076))+((r01*x1073*x1075))+((r11*x1074*x1075)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1080.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((-1.5707963267949)*(x1079.value)))+(x1080.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x1081=IKcos(j6);
IkReal x1082=IKsin(j6);
IkReal x1083=((0.17900000508718)*cj0);
IkReal x1084=(cj2*sj1);
IkReal x1085=((0.039478501415)*cj0);
IkReal x1086=((0.27900001)*r01);
IkReal x1087=((0.17900000508718)*sj0);
IkReal x1088=((0.27900001)*sj0);
IkReal x1089=((0.27900001)*cj0);
IkReal x1090=(sj0*x1082);
IkReal x1091=(r00*x1081);
IkReal x1092=(r11*x1082);
IkReal x1093=(r10*x1081);
evalcond[0]=((((-0.07075)*cj0))+((sj2*x1087))+(((0.27900001)*x1091))+(((-1.0)*x1082*x1086))+(((-1.0)*x1083*x1084)));
evalcond[1]=((((-1.0)*sj2*x1083))+(((-0.07075)*sj0))+(((0.27900001)*x1093))+(((-1.0)*x1084*x1087))+(((-0.27900001)*x1092)));
evalcond[2]=((((-1.0)*x1088*x1091))+((x1089*x1093))+((x1086*x1090))+(((-1.0)*x1089*x1092))+(((-0.17900000508718)*sj2)));
evalcond[3]=((-0.07075)+(((-1.0)*x1088*x1092))+((x1089*x1091))+((x1088*x1093))+(((-1.0)*cj0*x1082*x1086))+(((-0.17900000508718)*x1084)));
evalcond[4]=((-0.0508055662587896)+((x1085*x1091))+(((-1.0)*r01*x1082*x1085))+(((-1.0)*(pz*pz)))+(((0.039478501415)*sj0*x1093))+(((-0.039478501415)*r11*x1090)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1094=((7075000.0)*sj0);
IkReal x1095=((17900000.508718)*sj2);
IkReal x1096=(cj0*r10);
IkReal x1097=(cj0*r11);
IkReal x1098=((17900000.508718)*cj2*sj1);
CheckValue<IkReal> x1099 = IKatan2WithCheck(IkReal(((((-1.0)*r00*sj0*x1098))+(((-1.0)*r10*sj0*x1095))+(((-1.0)*cj0*r00*x1095))+(((7075000.0)*x1096))+((x1096*x1098))+(((-1.0)*r00*x1094)))),IkReal(((((-1.0)*r11*sj0*x1095))+(((-1.0)*cj0*r01*x1095))+(((7075000.0)*x1097))+(((-1.0)*r01*sj0*x1098))+(((-1.0)*r01*x1094))+((x1097*x1098)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1099.valid){
continue;
}
CheckValue<IkReal> x1100=IKPowWithIntegerCheck(IKsign(r22),-1);
if(!x1100.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1099.value)+(((1.5707963267949)*(x1100.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x1101=IKcos(j6);
IkReal x1102=IKsin(j6);
IkReal x1103=((0.17900000508718)*cj0);
IkReal x1104=(cj2*sj1);
IkReal x1105=((0.039478501415)*cj0);
IkReal x1106=((0.27900001)*r01);
IkReal x1107=((0.17900000508718)*sj0);
IkReal x1108=((0.27900001)*sj0);
IkReal x1109=((0.27900001)*cj0);
IkReal x1110=(sj0*x1102);
IkReal x1111=(r00*x1101);
IkReal x1112=(r11*x1102);
IkReal x1113=(r10*x1101);
evalcond[0]=((((-1.0)*x1103*x1104))+((sj2*x1107))+(((-0.07075)*cj0))+(((0.27900001)*x1111))+(((-1.0)*x1102*x1106)));
evalcond[1]=((((-0.27900001)*x1112))+(((-0.07075)*sj0))+(((0.27900001)*x1113))+(((-1.0)*sj2*x1103))+(((-1.0)*x1104*x1107)));
evalcond[2]=(((x1109*x1113))+(((-1.0)*x1109*x1112))+(((-1.0)*x1108*x1111))+(((-0.17900000508718)*sj2))+((x1106*x1110)));
evalcond[3]=((-0.07075)+((x1109*x1111))+((x1108*x1113))+(((-0.17900000508718)*x1104))+(((-1.0)*x1108*x1112))+(((-1.0)*cj0*x1102*x1106)));
evalcond[4]=((-0.0508055662587896)+(((-0.039478501415)*r11*x1110))+((x1105*x1111))+(((0.039478501415)*sj0*x1113))+(((-1.0)*(pz*pz)))+(((-1.0)*r01*x1102*x1105)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1114=((0.55800002)*px);
IkReal x1115=((0.55800002)*py);
IkReal x1116=(((r00*x1114))+((r10*x1115)));
IkReal x1117=((((-1.0)*r11*x1115))+(((-1.0)*r01*x1114)));
CheckValue<IkReal> x1120 = IKatan2WithCheck(IkReal(x1116),IkReal(x1117),IKFAST_ATAN2_MAGTHRESH);
if(!x1120.valid){
continue;
}
IkReal x1118=((1.0)*(x1120.value));
if((((x1117*x1117)+(x1116*x1116))) < -0.00001)
continue;
CheckValue<IkReal> x1121=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1117*x1117)+(x1116*x1116)))),-1);
if(!x1121.valid){
continue;
}
if( (((x1121.value)*(((-0.0407944412587896)+(((0.025328500719836)*cj2*sj1))+(((-1.0)*pp)))))) < -1-IKFAST_SINCOS_THRESH || (((x1121.value)*(((-0.0407944412587896)+(((0.025328500719836)*cj2*sj1))+(((-1.0)*pp)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1119=IKasin(((x1121.value)*(((-0.0407944412587896)+(((0.025328500719836)*cj2*sj1))+(((-1.0)*pp))))));
j6array[0]=((((-1.0)*x1119))+(((-1.0)*x1118)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+x1119+(((-1.0)*x1118)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];

{
IkReal j0eval[2];
IkReal x1122=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1122);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1122);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x1123=cj1*cj1;
IkReal x1124=cj2*cj2;
IkReal x1125=(cj2*sj1);
IkReal x1126=(x1123*x1124);
j0eval[0]=((-1.46264339650383)+(((1.26501770379633)*x1126))+(((-1.0)*x1125)));
j0eval[1]=IKsign(((-2.89055914418119e+15)+(((-1.976256927075e+15)*x1125))+(((2.5e+15)*x1126))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
IkReal x1127=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1127);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1127);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x1128=(cj6*r10);
IkReal x1129=(cj2*sj1);
IkReal x1130=(r11*sj6);
IkReal x1131=(px*sj2);
IkReal x1132=(r01*sj2*sj6);
IkReal x1133=(cj6*r00*sj2);
j0eval[0]=(x1130+(((-2.53003540759265)*x1128*x1129))+(((9.06822694233112)*x1131))+(((2.53003540759265)*x1132))+(((-1.0)*x1128))+(((2.53003540759265)*x1129*x1130))+(((-2.53003540759265)*x1133))+(((3.584229262214)*py))+(((9.06822694233112)*py*x1129)));
j0eval[1]=IKsign(((((-13950000.5)*x1128*x1129))+(((13950000.5)*x1132))+(((-5513757.02416494)*x1128))+(((-13950000.5)*x1133))+(((50000000.0)*x1131))+(((50000000.0)*py*x1129))+(((13950000.5)*x1129*x1130))+(((5513757.02416494)*x1130))+(((19762569.27075)*py))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
IkReal x1134=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1134);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1134);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x1135=(cj6*r00);
IkReal x1136=((2.53003540759265)*sj6);
IkReal x1137=(cj2*sj1);
j0eval[0]=((((-9.06822694233112)*px*x1137))+x1135+(((-2.53003540759265)*cj6*r10*sj2))+(((-1.0)*r01*sj6))+(((2.53003540759265)*x1135*x1137))+((r11*sj2*x1136))+(((-1.0)*r01*x1136*x1137))+(((-3.584229262214)*px))+(((9.06822694233112)*py*sj2)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1138=cj6*cj6;
IkReal x1139=r01*r01;
IkReal x1140=(r01*sj6);
IkReal x1141=(cj6*r10);
IkReal x1142=(cj2*sj1);
IkReal x1143=((3.8966480736148e+15)*sj2);
IkReal x1144=(r11*sj6);
IkReal x1145=((77932961.472296)*py);
IkReal x1146=((4.35379660656096e+16)*px);
IkReal x1147=(cj6*r00);
IkReal x1148=(py*sj2);
IkReal x1149=((13950000.5)*sj2);
IkReal x1150=((77932961.472296)*px);
IkReal x1151=((6.07354648384237e+15)*x1139);
IkReal x1152=((21743297.0301002)*r01*r11);
CheckValue<IkReal> x1153=IKPowWithIntegerCheck(((((50000000.0)*x1148))+(((13950000.5)*x1142*x1147))+(((-1.0)*x1141*x1149))+(((-50000000.0)*px*x1142))+(((-19762569.27075)*px))+(((5513757.02416494)*x1147))+((x1144*x1149))+(((-13950000.5)*x1140*x1142))+(((-5513757.02416494)*x1140))),-1);
if(!x1153.valid){
continue;
}
CheckValue<IkReal> x1154=IKPowWithIntegerCheck((((x1143*x1144))+(((1.54015554957094e+15)*x1147))+(((-1.0)*x1141*x1143))+(((-3.8966480736148e+15)*x1140*x1142))+(((1.396648005e+16)*x1148))+(((3.8966480736148e+15)*x1142*x1147))+(((-1.54015554957094e+15)*x1140))+(((-1.396648005e+16)*px*x1142))+(((-5.52027058913346e+15)*px))),-1);
if(!x1154.valid){
continue;
}
if( IKabs(((x1153.value)*(((((-1.0)*x1145*x1147))+(((-1.0)*x1141*x1150))+((x1140*x1145))+x1152+(((-1.0)*x1138*x1152))+(((-3537500.0)*sj2))+(((279329601.0)*px*py))+(((21743297.0301002)*r00*r10*x1138))+(((-8950000.25435901)*sj2*x1142))+(((-21743297.0301002)*x1144*x1147))+(((-21743297.0301002)*x1140*x1141))+((x1144*x1150)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1154.value)*(((-2.5e+15)+((x1140*x1146))+x1151+(((-1.0)*x1138*x1151))+(((-1.0)*x1146*x1147))+(((-1.21470929676847e+16)*x1140*x1147))+(((7.80250259948192e+16)*(px*px)))+(((6.07354648384237e+15)*x1138*(r00*r00)))+(((2.5e+15)*(cj2*cj2))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1153.value)*(((((-1.0)*x1145*x1147))+(((-1.0)*x1141*x1150))+((x1140*x1145))+x1152+(((-1.0)*x1138*x1152))+(((-3537500.0)*sj2))+(((279329601.0)*px*py))+(((21743297.0301002)*r00*r10*x1138))+(((-8950000.25435901)*sj2*x1142))+(((-21743297.0301002)*x1144*x1147))+(((-21743297.0301002)*x1140*x1141))+((x1144*x1150))))))+IKsqr(((x1154.value)*(((-2.5e+15)+((x1140*x1146))+x1151+(((-1.0)*x1138*x1151))+(((-1.0)*x1146*x1147))+(((-1.21470929676847e+16)*x1140*x1147))+(((7.80250259948192e+16)*(px*px)))+(((6.07354648384237e+15)*x1138*(r00*r00)))+(((2.5e+15)*(cj2*cj2)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((x1153.value)*(((((-1.0)*x1145*x1147))+(((-1.0)*x1141*x1150))+((x1140*x1145))+x1152+(((-1.0)*x1138*x1152))+(((-3537500.0)*sj2))+(((279329601.0)*px*py))+(((21743297.0301002)*r00*r10*x1138))+(((-8950000.25435901)*sj2*x1142))+(((-21743297.0301002)*x1144*x1147))+(((-21743297.0301002)*x1140*x1141))+((x1144*x1150))))), ((x1154.value)*(((-2.5e+15)+((x1140*x1146))+x1151+(((-1.0)*x1138*x1151))+(((-1.0)*x1146*x1147))+(((-1.21470929676847e+16)*x1140*x1147))+(((7.80250259948192e+16)*(px*px)))+(((6.07354648384237e+15)*x1138*(r00*r00)))+(((2.5e+15)*(cj2*cj2)))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1155=IKcos(j0);
IkReal x1156=IKsin(j0);
IkReal x1157=((1.0)*px);
IkReal x1158=((1.0)*py);
IkReal x1159=(r01*sj6);
IkReal x1160=((0.55800002)*cj6);
IkReal x1161=(r11*sj6);
IkReal x1162=((0.17900000508718)*sj2);
IkReal x1163=((0.27900001)*cj6);
IkReal x1164=((0.039478501415)*x1155);
IkReal x1165=((0.27900001)*x1155);
IkReal x1166=((0.27900001)*x1156);
IkReal x1167=((0.039478501415)*x1156);
IkReal x1168=((0.17900000508718)*cj2*sj1);
evalcond[0]=((((-1.0)*x1157))+((r00*x1163))+((x1156*x1162))+(((-0.27900001)*x1159))+(((-0.07075)*x1155))+(((-1.0)*x1155*x1168)));
evalcond[1]=((((-1.0)*x1156*x1168))+(((-1.0)*x1158))+((r10*x1163))+(((-0.27900001)*x1161))+(((-0.07075)*x1156))+(((-1.0)*x1155*x1162)));
evalcond[2]=(((x1159*x1166))+(((-1.0)*x1155*x1158))+((r10*x1155*x1163))+(((-1.0)*r00*x1156*x1163))+(((-1.0)*x1162))+(((-1.0)*x1161*x1165))+((px*x1156)));
evalcond[3]=((-0.07075)+((r10*x1156*x1163))+(((-1.0)*x1155*x1157))+(((-1.0)*x1159*x1165))+((r00*x1155*x1163))+(((-1.0)*x1156*x1158))+(((-1.0)*x1168))+(((-1.0)*x1161*x1166)));
evalcond[4]=((-0.0508055662587896)+(((-0.55800002)*px*x1159))+(((-1.0)*x1159*x1164))+((cj6*r10*x1167))+((cj6*r00*x1164))+(((-0.55800002)*py*x1161))+((py*r10*x1160))+(((-1.0)*pp))+((px*r00*x1160))+(((-0.1415)*py*x1156))+(((-0.1415)*px*x1155))+(((-1.0)*x1161*x1167)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1169=cj6*cj6;
IkReal x1170=r01*r01;
IkReal x1171=cj2*cj2;
IkReal x1172=(r01*sj6);
IkReal x1173=((13950000.5)*sj2);
IkReal x1174=(cj6*r00);
IkReal x1175=((155865922.944592)*px);
IkReal x1176=(cj6*r10);
IkReal x1177=(cj2*sj1);
IkReal x1178=((77932961.472296)*py);
IkReal x1179=(r01*r11);
IkReal x1180=(r11*sj6);
IkReal x1181=((77932961.472296)*px);
IkReal x1182=((21743297.0301002)*x1169);
IkReal x1183=((8950000.25435901)*x1171);
CheckValue<IkReal> x1184=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1173*x1174))+(((-13950000.5)*x1176*x1177))+(((50000000.0)*px*sj2))+(((13950000.5)*x1177*x1180))+(((-5513757.02416494)*x1176))+(((5513757.02416494)*x1180))+(((50000000.0)*py*x1177))+((x1172*x1173))+(((19762569.27075)*py)))),-1);
if(!x1184.valid){
continue;
}
CheckValue<IkReal> x1185 = IKatan2WithCheck(IkReal(((-1398201.77590556)+(((21743297.0301002)*x1170))+(((-7075000.0)*x1177))+(((-1.0)*x1183))+((x1172*x1175))+(((-43486594.0602004)*x1172*x1174))+((x1182*(r00*r00)))+(((-1.0)*x1170*x1182))+(((279329601.0)*(px*px)))+(((-1.0)*x1174*x1175))+((x1183*(cj1*cj1))))),IkReal(((((-8950000.25435901)*sj2*x1177))+((x1174*x1178))+((x1179*x1182))+(((-1.0)*x1172*x1178))+(((21743297.0301002)*x1172*x1176))+((x1176*x1181))+(((-279329601.0)*px*py))+(((-3537500.0)*sj2))+(((-1.0)*x1180*x1181))+(((21743297.0301002)*x1174*x1180))+(((-1.0)*r00*r10*x1182))+(((-21743297.0301002)*x1179)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1185.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1184.value)))+(x1185.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1186=IKcos(j0);
IkReal x1187=IKsin(j0);
IkReal x1188=((1.0)*px);
IkReal x1189=((1.0)*py);
IkReal x1190=(r01*sj6);
IkReal x1191=((0.55800002)*cj6);
IkReal x1192=(r11*sj6);
IkReal x1193=((0.17900000508718)*sj2);
IkReal x1194=((0.27900001)*cj6);
IkReal x1195=((0.039478501415)*x1186);
IkReal x1196=((0.27900001)*x1186);
IkReal x1197=((0.27900001)*x1187);
IkReal x1198=((0.039478501415)*x1187);
IkReal x1199=((0.17900000508718)*cj2*sj1);
evalcond[0]=(((x1187*x1193))+((r00*x1194))+(((-1.0)*x1186*x1199))+(((-0.27900001)*x1190))+(((-1.0)*x1188))+(((-0.07075)*x1186)));
evalcond[1]=(((r10*x1194))+(((-1.0)*x1186*x1193))+(((-0.27900001)*x1192))+(((-1.0)*x1187*x1199))+(((-1.0)*x1189))+(((-0.07075)*x1187)));
evalcond[2]=((((-1.0)*r00*x1187*x1194))+(((-1.0)*x1186*x1189))+((r10*x1186*x1194))+(((-1.0)*x1193))+((px*x1187))+(((-1.0)*x1192*x1196))+((x1190*x1197)));
evalcond[3]=((-0.07075)+(((-1.0)*x1190*x1196))+(((-1.0)*x1186*x1188))+((r00*x1186*x1194))+(((-1.0)*x1199))+(((-1.0)*x1187*x1189))+((r10*x1187*x1194))+(((-1.0)*x1192*x1197)));
evalcond[4]=((-0.0508055662587896)+(((-1.0)*x1190*x1195))+(((-0.1415)*px*x1186))+(((-0.1415)*py*x1187))+(((-1.0)*pp))+((cj6*r10*x1198))+(((-0.55800002)*py*x1192))+(((-0.55800002)*px*x1190))+((cj6*r00*x1195))+(((-1.0)*x1192*x1198))+((px*r00*x1191))+((py*r10*x1191)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1200=(r11*sj6);
IkReal x1201=(cj6*r10);
IkReal x1202=((1.396648005e+16)*sj2);
IkReal x1203=(r01*sj6);
IkReal x1204=(cj6*r00);
IkReal x1205=((3.8966480736148e+15)*sj2);
IkReal x1206=((3.8966480736148e+15)*cj2*sj1);
IkReal x1207=(cj6*x1205);
IkReal x1208=((1.396648005e+16)*cj2*sj1);
CheckValue<IkReal> x1209 = IKatan2WithCheck(IkReal((((x1204*x1205))+(((-1.54015554957094e+15)*x1201))+(((1.54015554957094e+15)*x1200))+((x1200*x1206))+(((-1.0)*x1203*x1205))+((py*x1208))+(((-1.0)*px*x1202))+(((-1.0)*x1201*x1206))+(((5.52027058913346e+15)*py)))),IkReal(((((-1.0)*x1204*x1206))+((px*x1208))+(((-1.54015554957094e+15)*x1204))+(((1.54015554957094e+15)*x1203))+((x1200*x1205))+((x1203*x1206))+((py*x1202))+(((-1.0)*x1201*x1205))+(((5.52027058913346e+15)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1209.valid){
continue;
}
CheckValue<IkReal> x1210=IKPowWithIntegerCheck(IKsign(((-2.89055914418119e+15)+(((2.5e+15)*(cj1*cj1)*(cj2*cj2)))+(((-1.976256927075e+15)*cj2*sj1)))),-1);
if(!x1210.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1209.value)+(((1.5707963267949)*(x1210.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1211=IKcos(j0);
IkReal x1212=IKsin(j0);
IkReal x1213=((1.0)*px);
IkReal x1214=((1.0)*py);
IkReal x1215=(r01*sj6);
IkReal x1216=((0.55800002)*cj6);
IkReal x1217=(r11*sj6);
IkReal x1218=((0.17900000508718)*sj2);
IkReal x1219=((0.27900001)*cj6);
IkReal x1220=((0.039478501415)*x1211);
IkReal x1221=((0.27900001)*x1211);
IkReal x1222=((0.27900001)*x1212);
IkReal x1223=((0.039478501415)*x1212);
IkReal x1224=((0.17900000508718)*cj2*sj1);
evalcond[0]=(((x1212*x1218))+(((-0.27900001)*x1215))+((r00*x1219))+(((-0.07075)*x1211))+(((-1.0)*x1213))+(((-1.0)*x1211*x1224)));
evalcond[1]=((((-1.0)*x1212*x1224))+(((-0.27900001)*x1217))+((r10*x1219))+(((-0.07075)*x1212))+(((-1.0)*x1211*x1218))+(((-1.0)*x1214)));
evalcond[2]=((((-1.0)*r00*x1212*x1219))+((px*x1212))+((r10*x1211*x1219))+(((-1.0)*x1211*x1214))+(((-1.0)*x1217*x1221))+(((-1.0)*x1218))+((x1215*x1222)));
evalcond[3]=((-0.07075)+((r00*x1211*x1219))+(((-1.0)*x1224))+(((-1.0)*x1212*x1214))+(((-1.0)*x1215*x1221))+(((-1.0)*x1211*x1213))+(((-1.0)*x1217*x1222))+((r10*x1212*x1219)));
evalcond[4]=((-0.0508055662587896)+((cj6*r00*x1220))+(((-0.55800002)*px*x1215))+((px*r00*x1216))+(((-0.55800002)*py*x1217))+(((-1.0)*pp))+(((-1.0)*x1215*x1220))+(((-0.1415)*px*x1211))+(((-1.0)*x1217*x1223))+((py*r10*x1216))+((cj6*r10*x1223))+(((-0.1415)*py*x1212)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1225=((0.15568201116)*px);
IkReal x1226=((0.55800002)*px);
IkReal x1227=(py*r11);
IkReal x1228=((0.15568201116)*r01);
IkReal x1229=(cj2*sj1);
IkReal x1230=(py*r10);
IkReal x1231=((-0.0407944412587896)+(((-1.0)*pp))+(((0.025328500719836)*x1229)));
IkReal x1232=(((r01*x1226))+(((0.55800002)*x1227)));
IkReal x1233=(((r00*x1226))+(((0.55800002)*x1230)));
IkReal x1234=((((-0.27900001)*pp*r01))+(((-0.0113816495191467)*r01))+(((0.00706665195411925)*r01*x1229)));
IkReal x1235=(((x1228*x1230))+((r00*r01*x1225)));
IkReal x1236=(((x1225*(r01*r01)))+((x1227*x1228)));
CheckValue<IkReal> x1237=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1233*x1236))+((x1232*x1235)))),-1);
if(!x1237.valid){
continue;
}
CheckValue<IkReal> x1238 = IKatan2WithCheck(IkReal((((x1231*x1235))+(((-1.0)*x1233*x1234)))),IkReal((((x1231*x1236))+(((-1.0)*x1232*x1234)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1238.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1237.value)))+(x1238.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x1239=IKcos(j6);
IkReal x1240=IKsin(j6);
IkReal x1241=((0.15568201116)*py);
IkReal x1242=((0.55800002)*py);
IkReal x1243=(cj2*sj1);
IkReal x1244=((0.15568201116)*px);
IkReal x1245=((0.55800002)*px);
IkReal x1246=(r00*r11);
IkReal x1247=(r00*r10);
IkReal x1248=(r01*r10);
IkReal x1249=(r01*r11);
IkReal x1250=((0.27900001)*pp);
IkReal x1251=(r10*r11*x1241);
IkReal x1252=(r00*r01*x1244);
evalcond[0]=((-0.0407944412587896)+((x1240*(((((-1.0)*r11*x1242))+(((-1.0)*r01*x1245))))))+((x1239*((((r00*x1245))+((r10*x1242))))))+(((0.025328500719836)*x1243))+(((-1.0)*pp)));
evalcond[1]=(((r10*x1250))+(((-0.00706665195411925)*r10*x1243))+((x1240*((x1251+((x1244*x1248))))))+((x1239*(((((-1.0)*x1244*x1247))+(((-1.0)*x1241*(r10*r10)))))))+(((0.0113816495191467)*r10)));
evalcond[2]=(((x1239*((x1251+((x1244*x1246))))))+(((-1.0)*r11*x1250))+(((-0.0113816495191467)*r11))+(((0.00706665195411925)*r11*x1243))+((x1240*(((((-1.0)*x1244*x1249))+(((-1.0)*x1241*(r11*r11))))))));
evalcond[3]=(((x1239*(((((-1.0)*x1244*(r00*r00)))+(((-1.0)*x1241*x1247))))))+((x1240*((x1252+((x1241*x1246))))))+(((0.0113816495191467)*r00))+(((-0.00706665195411925)*r00*x1243))+((r00*x1250)));
evalcond[4]=(((x1240*(((((-1.0)*x1244*(r01*r01)))+(((-1.0)*x1241*x1249))))))+(((-0.0113816495191467)*r01))+(((-1.0)*r01*x1250))+((x1239*((x1252+((x1241*x1248))))))+(((0.00706665195411925)*r01*x1243)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0eval[2];
IkReal x1253=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1253);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1253);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x1254=cj1*cj1;
IkReal x1255=cj2*cj2;
IkReal x1256=(cj2*sj1);
IkReal x1257=(x1254*x1255);
j0eval[0]=((-1.46264339650383)+(((1.26501770379633)*x1257))+(((-1.0)*x1256)));
j0eval[1]=IKsign(((-2.89055914418119e+15)+(((2.5e+15)*x1257))+(((-1.976256927075e+15)*x1256))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
IkReal x1258=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1258);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1258);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x1259=(cj6*r10);
IkReal x1260=(cj2*sj1);
IkReal x1261=(r11*sj6);
IkReal x1262=(px*sj2);
IkReal x1263=(r01*sj2*sj6);
IkReal x1264=(cj6*r00*sj2);
j0eval[0]=(x1261+(((-2.53003540759265)*x1259*x1260))+(((9.06822694233112)*py*x1260))+(((-2.53003540759265)*x1264))+(((2.53003540759265)*x1260*x1261))+(((9.06822694233112)*x1262))+(((-1.0)*x1259))+(((2.53003540759265)*x1263))+(((3.584229262214)*py)));
j0eval[1]=IKsign(((((50000000.0)*py*x1260))+(((-5513757.02416494)*x1259))+(((13950000.5)*x1263))+(((5513757.02416494)*x1261))+(((19762569.27075)*py))+(((50000000.0)*x1262))+(((-13950000.5)*x1264))+(((-13950000.5)*x1259*x1260))+(((13950000.5)*x1260*x1261))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
IkReal x1265=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1265);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1265);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x1266=(cj6*r00);
IkReal x1267=((2.53003540759265)*sj6);
IkReal x1268=(cj2*sj1);
j0eval[0]=((((-2.53003540759265)*cj6*r10*sj2))+x1266+(((2.53003540759265)*x1266*x1268))+(((-1.0)*r01*sj6))+(((-1.0)*r01*x1267*x1268))+(((-3.584229262214)*px))+(((9.06822694233112)*py*sj2))+((r11*sj2*x1267))+(((-9.06822694233112)*px*x1268)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1269=cj6*cj6;
IkReal x1270=r01*r01;
IkReal x1271=(r01*sj6);
IkReal x1272=(cj6*r10);
IkReal x1273=(cj2*sj1);
IkReal x1274=((3.8966480736148e+15)*sj2);
IkReal x1275=(r11*sj6);
IkReal x1276=((77932961.472296)*py);
IkReal x1277=((4.35379660656096e+16)*px);
IkReal x1278=(cj6*r00);
IkReal x1279=(py*sj2);
IkReal x1280=((13950000.5)*sj2);
IkReal x1281=((77932961.472296)*px);
IkReal x1282=((6.07354648384237e+15)*x1270);
IkReal x1283=((21743297.0301002)*r01*r11);
CheckValue<IkReal> x1284=IKPowWithIntegerCheck(((((-5513757.02416494)*x1271))+((x1275*x1280))+(((5513757.02416494)*x1278))+(((-19762569.27075)*px))+(((-1.0)*x1272*x1280))+(((13950000.5)*x1273*x1278))+(((50000000.0)*x1279))+(((-50000000.0)*px*x1273))+(((-13950000.5)*x1271*x1273))),-1);
if(!x1284.valid){
continue;
}
CheckValue<IkReal> x1285=IKPowWithIntegerCheck(((((1.396648005e+16)*x1279))+(((-3.8966480736148e+15)*x1271*x1273))+(((-1.54015554957094e+15)*x1271))+((x1274*x1275))+(((-1.0)*x1272*x1274))+(((3.8966480736148e+15)*x1273*x1278))+(((1.54015554957094e+15)*x1278))+(((-1.396648005e+16)*px*x1273))+(((-5.52027058913346e+15)*px))),-1);
if(!x1285.valid){
continue;
}
if( IKabs(((x1284.value)*((x1283+((x1275*x1281))+(((21743297.0301002)*r00*r10*x1269))+(((-1.0)*x1276*x1278))+(((-1.0)*x1269*x1283))+(((-3537500.0)*sj2))+(((-8950000.25435901)*sj2*x1273))+(((-1.0)*x1272*x1281))+(((-21743297.0301002)*x1271*x1272))+(((279329601.0)*px*py))+(((-21743297.0301002)*x1275*x1278))+((x1271*x1276)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1285.value)*(((-2.5e+15)+x1282+(((-1.0)*x1269*x1282))+(((-1.0)*x1277*x1278))+(((7.80250259948192e+16)*(px*px)))+(((6.07354648384237e+15)*x1269*(r00*r00)))+((x1271*x1277))+(((2.5e+15)*(cj2*cj2)))+(((-1.21470929676847e+16)*x1271*x1278)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1284.value)*((x1283+((x1275*x1281))+(((21743297.0301002)*r00*r10*x1269))+(((-1.0)*x1276*x1278))+(((-1.0)*x1269*x1283))+(((-3537500.0)*sj2))+(((-8950000.25435901)*sj2*x1273))+(((-1.0)*x1272*x1281))+(((-21743297.0301002)*x1271*x1272))+(((279329601.0)*px*py))+(((-21743297.0301002)*x1275*x1278))+((x1271*x1276))))))+IKsqr(((x1285.value)*(((-2.5e+15)+x1282+(((-1.0)*x1269*x1282))+(((-1.0)*x1277*x1278))+(((7.80250259948192e+16)*(px*px)))+(((6.07354648384237e+15)*x1269*(r00*r00)))+((x1271*x1277))+(((2.5e+15)*(cj2*cj2)))+(((-1.21470929676847e+16)*x1271*x1278))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((x1284.value)*((x1283+((x1275*x1281))+(((21743297.0301002)*r00*r10*x1269))+(((-1.0)*x1276*x1278))+(((-1.0)*x1269*x1283))+(((-3537500.0)*sj2))+(((-8950000.25435901)*sj2*x1273))+(((-1.0)*x1272*x1281))+(((-21743297.0301002)*x1271*x1272))+(((279329601.0)*px*py))+(((-21743297.0301002)*x1275*x1278))+((x1271*x1276))))), ((x1285.value)*(((-2.5e+15)+x1282+(((-1.0)*x1269*x1282))+(((-1.0)*x1277*x1278))+(((7.80250259948192e+16)*(px*px)))+(((6.07354648384237e+15)*x1269*(r00*r00)))+((x1271*x1277))+(((2.5e+15)*(cj2*cj2)))+(((-1.21470929676847e+16)*x1271*x1278))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1286=IKcos(j0);
IkReal x1287=IKsin(j0);
IkReal x1288=((1.0)*px);
IkReal x1289=((1.0)*py);
IkReal x1290=(r01*sj6);
IkReal x1291=((0.55800002)*cj6);
IkReal x1292=(r11*sj6);
IkReal x1293=((0.17900000508718)*sj2);
IkReal x1294=((0.27900001)*cj6);
IkReal x1295=((0.039478501415)*x1286);
IkReal x1296=((0.27900001)*x1286);
IkReal x1297=((0.27900001)*x1287);
IkReal x1298=((0.039478501415)*x1287);
IkReal x1299=((0.17900000508718)*cj2*sj1);
evalcond[0]=((((-1.0)*x1286*x1299))+((x1287*x1293))+(((-0.07075)*x1286))+(((-0.27900001)*x1290))+(((-1.0)*x1288))+((r00*x1294)));
evalcond[1]=((((-1.0)*x1287*x1299))+(((-1.0)*x1286*x1293))+(((-0.07075)*x1287))+(((-0.27900001)*x1292))+(((-1.0)*x1289))+((r10*x1294)));
evalcond[2]=((((-1.0)*x1293))+((x1290*x1297))+((r10*x1286*x1294))+((px*x1287))+(((-1.0)*x1292*x1296))+(((-1.0)*x1286*x1289))+(((-1.0)*r00*x1287*x1294)));
evalcond[3]=((-0.07075)+(((-1.0)*x1299))+((r10*x1287*x1294))+((r00*x1286*x1294))+(((-1.0)*x1292*x1297))+(((-1.0)*x1290*x1296))+(((-1.0)*x1287*x1289))+(((-1.0)*x1286*x1288)));
evalcond[4]=((-0.0508055662587896)+((px*r00*x1291))+((py*r10*x1291))+((cj6*r10*x1298))+(((-1.0)*pp))+((cj6*r00*x1295))+(((-1.0)*x1292*x1298))+(((-1.0)*x1290*x1295))+(((-0.1415)*px*x1286))+(((-0.55800002)*py*x1292))+(((-0.55800002)*px*x1290))+(((-0.1415)*py*x1287)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1300=cj6*cj6;
IkReal x1301=r01*r01;
IkReal x1302=cj2*cj2;
IkReal x1303=(r01*sj6);
IkReal x1304=((13950000.5)*sj2);
IkReal x1305=(cj6*r00);
IkReal x1306=((155865922.944592)*px);
IkReal x1307=(cj6*r10);
IkReal x1308=(cj2*sj1);
IkReal x1309=((77932961.472296)*py);
IkReal x1310=(r01*r11);
IkReal x1311=(r11*sj6);
IkReal x1312=((77932961.472296)*px);
IkReal x1313=((21743297.0301002)*x1300);
IkReal x1314=((8950000.25435901)*x1302);
CheckValue<IkReal> x1315=IKPowWithIntegerCheck(IKsign(((((50000000.0)*py*x1308))+(((50000000.0)*px*sj2))+(((13950000.5)*x1308*x1311))+(((-5513757.02416494)*x1307))+((x1303*x1304))+(((19762569.27075)*py))+(((5513757.02416494)*x1311))+(((-13950000.5)*x1307*x1308))+(((-1.0)*x1304*x1305)))),-1);
if(!x1315.valid){
continue;
}
CheckValue<IkReal> x1316 = IKatan2WithCheck(IkReal(((-1398201.77590556)+(((-43486594.0602004)*x1303*x1305))+(((-1.0)*x1314))+((x1303*x1306))+(((-7075000.0)*x1308))+(((-1.0)*x1305*x1306))+((x1313*(r00*r00)))+(((21743297.0301002)*x1301))+((x1314*(cj1*cj1)))+(((-1.0)*x1301*x1313))+(((279329601.0)*(px*px))))),IkReal(((((-1.0)*x1311*x1312))+((x1310*x1313))+((x1307*x1312))+((x1305*x1309))+(((-21743297.0301002)*x1310))+(((21743297.0301002)*x1303*x1307))+(((-1.0)*r00*r10*x1313))+(((-279329601.0)*px*py))+(((21743297.0301002)*x1305*x1311))+(((-1.0)*x1303*x1309))+(((-3537500.0)*sj2))+(((-8950000.25435901)*sj2*x1308)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1316.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1315.value)))+(x1316.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1317=IKcos(j0);
IkReal x1318=IKsin(j0);
IkReal x1319=((1.0)*px);
IkReal x1320=((1.0)*py);
IkReal x1321=(r01*sj6);
IkReal x1322=((0.55800002)*cj6);
IkReal x1323=(r11*sj6);
IkReal x1324=((0.17900000508718)*sj2);
IkReal x1325=((0.27900001)*cj6);
IkReal x1326=((0.039478501415)*x1317);
IkReal x1327=((0.27900001)*x1317);
IkReal x1328=((0.27900001)*x1318);
IkReal x1329=((0.039478501415)*x1318);
IkReal x1330=((0.17900000508718)*cj2*sj1);
evalcond[0]=((((-0.27900001)*x1321))+((r00*x1325))+(((-0.07075)*x1317))+(((-1.0)*x1319))+((x1318*x1324))+(((-1.0)*x1317*x1330)));
evalcond[1]=((((-0.27900001)*x1323))+(((-1.0)*x1318*x1330))+(((-0.07075)*x1318))+(((-1.0)*x1320))+((r10*x1325))+(((-1.0)*x1317*x1324)));
evalcond[2]=((((-1.0)*x1323*x1327))+((r10*x1317*x1325))+((px*x1318))+(((-1.0)*x1324))+((x1321*x1328))+(((-1.0)*r00*x1318*x1325))+(((-1.0)*x1317*x1320)));
evalcond[3]=((-0.07075)+(((-1.0)*x1317*x1319))+(((-1.0)*x1323*x1328))+(((-1.0)*x1321*x1327))+((r00*x1317*x1325))+((r10*x1318*x1325))+(((-1.0)*x1330))+(((-1.0)*x1318*x1320)));
evalcond[4]=((-0.0508055662587896)+(((-0.1415)*px*x1317))+(((-1.0)*x1323*x1329))+((px*r00*x1322))+((cj6*r00*x1326))+((py*r10*x1322))+(((-0.55800002)*py*x1323))+(((-1.0)*pp))+(((-1.0)*x1321*x1326))+(((-0.55800002)*px*x1321))+(((-0.1415)*py*x1318))+((cj6*r10*x1329)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1331=(r11*sj6);
IkReal x1332=(cj6*r10);
IkReal x1333=((1.396648005e+16)*sj2);
IkReal x1334=(r01*sj6);
IkReal x1335=(cj6*r00);
IkReal x1336=((3.8966480736148e+15)*sj2);
IkReal x1337=((3.8966480736148e+15)*cj2*sj1);
IkReal x1338=(cj6*x1336);
IkReal x1339=((1.396648005e+16)*cj2*sj1);
CheckValue<IkReal> x1340 = IKatan2WithCheck(IkReal((((x1331*x1337))+(((-1.0)*px*x1333))+(((-1.0)*x1334*x1336))+((x1335*x1336))+((py*x1339))+(((1.54015554957094e+15)*x1331))+(((-1.54015554957094e+15)*x1332))+(((-1.0)*x1332*x1337))+(((5.52027058913346e+15)*py)))),IkReal(((((-1.0)*x1335*x1337))+((px*x1339))+((x1331*x1336))+((py*x1333))+(((1.54015554957094e+15)*x1334))+(((-1.54015554957094e+15)*x1335))+(((-1.0)*x1332*x1336))+((x1334*x1337))+(((5.52027058913346e+15)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1340.valid){
continue;
}
CheckValue<IkReal> x1341=IKPowWithIntegerCheck(IKsign(((-2.89055914418119e+15)+(((2.5e+15)*(cj1*cj1)*(cj2*cj2)))+(((-1.976256927075e+15)*cj2*sj1)))),-1);
if(!x1341.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1340.value)+(((1.5707963267949)*(x1341.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1342=IKcos(j0);
IkReal x1343=IKsin(j0);
IkReal x1344=((1.0)*px);
IkReal x1345=((1.0)*py);
IkReal x1346=(r01*sj6);
IkReal x1347=((0.55800002)*cj6);
IkReal x1348=(r11*sj6);
IkReal x1349=((0.17900000508718)*sj2);
IkReal x1350=((0.27900001)*cj6);
IkReal x1351=((0.039478501415)*x1342);
IkReal x1352=((0.27900001)*x1342);
IkReal x1353=((0.27900001)*x1343);
IkReal x1354=((0.039478501415)*x1343);
IkReal x1355=((0.17900000508718)*cj2*sj1);
evalcond[0]=((((-1.0)*x1344))+(((-0.07075)*x1342))+(((-0.27900001)*x1346))+((r00*x1350))+(((-1.0)*x1342*x1355))+((x1343*x1349)));
evalcond[1]=(((r10*x1350))+(((-1.0)*x1345))+(((-0.07075)*x1343))+(((-0.27900001)*x1348))+(((-1.0)*x1342*x1349))+(((-1.0)*x1343*x1355)));
evalcond[2]=((((-1.0)*x1349))+((px*x1343))+((x1346*x1353))+((r10*x1342*x1350))+(((-1.0)*x1342*x1345))+(((-1.0)*x1348*x1352))+(((-1.0)*r00*x1343*x1350)));
evalcond[3]=((-0.07075)+(((-1.0)*x1355))+((r10*x1343*x1350))+(((-1.0)*x1346*x1352))+((r00*x1342*x1350))+(((-1.0)*x1342*x1344))+(((-1.0)*x1348*x1353))+(((-1.0)*x1343*x1345)));
evalcond[4]=((-0.0508055662587896)+((cj6*r00*x1351))+(((-0.1415)*px*x1342))+((px*r00*x1347))+((py*r10*x1347))+(((-1.0)*x1346*x1351))+(((-1.0)*pp))+(((-0.55800002)*px*x1346))+(((-1.0)*x1348*x1354))+(((-0.55800002)*py*x1348))+((cj6*r10*x1354))+(((-0.1415)*py*x1343)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1356=(cj2*sj1);
IkReal x1357=((0.15568201116)*r10);
IkReal x1358=(px*r01);
IkReal x1359=(px*r00);
IkReal x1360=(py*r11);
IkReal x1361=((-0.0407944412587896)+(((0.025328500719836)*x1356))+(((-1.0)*pp)));
IkReal x1362=((((0.55800002)*py*r10))+(((0.55800002)*x1359)));
IkReal x1363=((((-0.55800002)*x1358))+(((-0.55800002)*x1360)));
IkReal x1364=(((x1357*x1359))+((py*r10*x1357)));
IkReal x1365=(((x1357*x1360))+((x1357*x1358)));
IkReal x1366=((((-0.00706665195411925)*r10*x1356))+(((0.27900001)*pp*r10))+(((0.0113816495191467)*r10)));
CheckValue<IkReal> x1367 = IKatan2WithCheck(IkReal(((((-1.0)*x1362*x1366))+(((-1.0)*x1361*x1364)))),IkReal((((x1363*x1366))+(((-1.0)*x1361*x1365)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1367.valid){
continue;
}
CheckValue<IkReal> x1368=IKPowWithIntegerCheck(IKsign((((x1363*x1364))+((x1362*x1365)))),-1);
if(!x1368.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1367.value)+(((1.5707963267949)*(x1368.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x1369=IKcos(j6);
IkReal x1370=IKsin(j6);
IkReal x1371=((0.15568201116)*py);
IkReal x1372=((0.55800002)*py);
IkReal x1373=(cj2*sj1);
IkReal x1374=((0.15568201116)*px);
IkReal x1375=((0.55800002)*px);
IkReal x1376=(r00*r11);
IkReal x1377=(r00*r10);
IkReal x1378=(r01*r10);
IkReal x1379=(r01*r11);
IkReal x1380=((0.27900001)*pp);
IkReal x1381=(r10*r11*x1371);
IkReal x1382=(r00*r01*x1374);
evalcond[0]=((-0.0407944412587896)+(((-1.0)*pp))+((x1370*(((((-1.0)*r01*x1375))+(((-1.0)*r11*x1372))))))+((x1369*((((r10*x1372))+((r00*x1375))))))+(((0.025328500719836)*x1373)));
evalcond[1]=(((r10*x1380))+(((-0.00706665195411925)*r10*x1373))+((x1370*((x1381+((x1374*x1378))))))+((x1369*(((((-1.0)*x1374*x1377))+(((-1.0)*x1371*(r10*r10)))))))+(((0.0113816495191467)*r10)));
evalcond[2]=((((-1.0)*r11*x1380))+(((0.00706665195411925)*r11*x1373))+(((-0.0113816495191467)*r11))+((x1370*(((((-1.0)*x1371*(r11*r11)))+(((-1.0)*x1374*x1379))))))+((x1369*((x1381+((x1374*x1376)))))));
evalcond[3]=(((x1369*(((((-1.0)*x1371*x1377))+(((-1.0)*x1374*(r00*r00)))))))+((r00*x1380))+(((0.0113816495191467)*r00))+(((-0.00706665195411925)*r00*x1373))+((x1370*((x1382+((x1371*x1376)))))));
evalcond[4]=((((-0.0113816495191467)*r01))+((x1370*(((((-1.0)*x1371*x1379))+(((-1.0)*x1374*(r01*r01)))))))+(((-1.0)*r01*x1380))+((x1369*((x1382+((x1371*x1378))))))+(((0.00706665195411925)*r01*x1373)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0eval[2];
IkReal x1383=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1383);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1383);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x1384=cj1*cj1;
IkReal x1385=cj2*cj2;
IkReal x1386=(cj2*sj1);
IkReal x1387=(x1384*x1385);
j0eval[0]=((-1.46264339650383)+(((-1.0)*x1386))+(((1.26501770379633)*x1387)));
j0eval[1]=IKsign(((-2.89055914418119e+15)+(((-1.976256927075e+15)*x1386))+(((2.5e+15)*x1387))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
IkReal x1388=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1388);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1388);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x1389=(cj6*r10);
IkReal x1390=(cj2*sj1);
IkReal x1391=(r11*sj6);
IkReal x1392=(px*sj2);
IkReal x1393=(r01*sj2*sj6);
IkReal x1394=(cj6*r00*sj2);
j0eval[0]=((((2.53003540759265)*x1390*x1391))+x1391+(((-2.53003540759265)*x1394))+(((2.53003540759265)*x1393))+(((-1.0)*x1389))+(((-2.53003540759265)*x1389*x1390))+(((9.06822694233112)*x1392))+(((3.584229262214)*py))+(((9.06822694233112)*py*x1390)));
j0eval[1]=IKsign(((((-5513757.02416494)*x1389))+(((5513757.02416494)*x1391))+(((13950000.5)*x1393))+(((50000000.0)*py*x1390))+(((50000000.0)*x1392))+(((13950000.5)*x1390*x1391))+(((19762569.27075)*py))+(((-13950000.5)*x1389*x1390))+(((-13950000.5)*x1394))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
IkReal x1395=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1395);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1395);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x1396=(cj6*r00);
IkReal x1397=((2.53003540759265)*sj6);
IkReal x1398=(cj2*sj1);
j0eval[0]=(x1396+(((-2.53003540759265)*cj6*r10*sj2))+(((-1.0)*r01*sj6))+(((-9.06822694233112)*px*x1398))+(((-1.0)*r01*x1397*x1398))+(((-3.584229262214)*px))+(((9.06822694233112)*py*sj2))+(((2.53003540759265)*x1396*x1398))+((r11*sj2*x1397)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1399=cj6*cj6;
IkReal x1400=r01*r01;
IkReal x1401=(r01*sj6);
IkReal x1402=(cj6*r10);
IkReal x1403=(cj2*sj1);
IkReal x1404=((3.8966480736148e+15)*sj2);
IkReal x1405=(r11*sj6);
IkReal x1406=((77932961.472296)*py);
IkReal x1407=((4.35379660656096e+16)*px);
IkReal x1408=(cj6*r00);
IkReal x1409=(py*sj2);
IkReal x1410=((13950000.5)*sj2);
IkReal x1411=((77932961.472296)*px);
IkReal x1412=((6.07354648384237e+15)*x1400);
IkReal x1413=((21743297.0301002)*r01*r11);
CheckValue<IkReal> x1414=IKPowWithIntegerCheck(((((-13950000.5)*x1401*x1403))+(((13950000.5)*x1403*x1408))+(((5513757.02416494)*x1408))+(((-19762569.27075)*px))+((x1405*x1410))+(((-5513757.02416494)*x1401))+(((-1.0)*x1402*x1410))+(((50000000.0)*x1409))+(((-50000000.0)*px*x1403))),-1);
if(!x1414.valid){
continue;
}
CheckValue<IkReal> x1415=IKPowWithIntegerCheck(((((-1.396648005e+16)*px*x1403))+(((-1.0)*x1402*x1404))+(((1.396648005e+16)*x1409))+((x1404*x1405))+(((-3.8966480736148e+15)*x1401*x1403))+(((-5.52027058913346e+15)*px))+(((1.54015554957094e+15)*x1408))+(((-1.54015554957094e+15)*x1401))+(((3.8966480736148e+15)*x1403*x1408))),-1);
if(!x1415.valid){
continue;
}
if( IKabs(((x1414.value)*(((((-8950000.25435901)*sj2*x1403))+(((-1.0)*x1399*x1413))+(((-1.0)*x1406*x1408))+(((-3537500.0)*sj2))+((x1405*x1411))+(((-21743297.0301002)*x1405*x1408))+(((279329601.0)*px*py))+x1413+(((-1.0)*x1402*x1411))+(((-21743297.0301002)*x1401*x1402))+(((21743297.0301002)*r00*r10*x1399))+((x1401*x1406)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1415.value)*(((-2.5e+15)+(((-1.0)*x1399*x1412))+(((6.07354648384237e+15)*x1399*(r00*r00)))+(((-1.21470929676847e+16)*x1401*x1408))+(((7.80250259948192e+16)*(px*px)))+x1412+(((2.5e+15)*(cj2*cj2)))+(((-1.0)*x1407*x1408))+((x1401*x1407)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1414.value)*(((((-8950000.25435901)*sj2*x1403))+(((-1.0)*x1399*x1413))+(((-1.0)*x1406*x1408))+(((-3537500.0)*sj2))+((x1405*x1411))+(((-21743297.0301002)*x1405*x1408))+(((279329601.0)*px*py))+x1413+(((-1.0)*x1402*x1411))+(((-21743297.0301002)*x1401*x1402))+(((21743297.0301002)*r00*r10*x1399))+((x1401*x1406))))))+IKsqr(((x1415.value)*(((-2.5e+15)+(((-1.0)*x1399*x1412))+(((6.07354648384237e+15)*x1399*(r00*r00)))+(((-1.21470929676847e+16)*x1401*x1408))+(((7.80250259948192e+16)*(px*px)))+x1412+(((2.5e+15)*(cj2*cj2)))+(((-1.0)*x1407*x1408))+((x1401*x1407))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((x1414.value)*(((((-8950000.25435901)*sj2*x1403))+(((-1.0)*x1399*x1413))+(((-1.0)*x1406*x1408))+(((-3537500.0)*sj2))+((x1405*x1411))+(((-21743297.0301002)*x1405*x1408))+(((279329601.0)*px*py))+x1413+(((-1.0)*x1402*x1411))+(((-21743297.0301002)*x1401*x1402))+(((21743297.0301002)*r00*r10*x1399))+((x1401*x1406))))), ((x1415.value)*(((-2.5e+15)+(((-1.0)*x1399*x1412))+(((6.07354648384237e+15)*x1399*(r00*r00)))+(((-1.21470929676847e+16)*x1401*x1408))+(((7.80250259948192e+16)*(px*px)))+x1412+(((2.5e+15)*(cj2*cj2)))+(((-1.0)*x1407*x1408))+((x1401*x1407))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1416=IKcos(j0);
IkReal x1417=IKsin(j0);
IkReal x1418=((1.0)*px);
IkReal x1419=((1.0)*py);
IkReal x1420=(r01*sj6);
IkReal x1421=((0.55800002)*cj6);
IkReal x1422=(r11*sj6);
IkReal x1423=((0.17900000508718)*sj2);
IkReal x1424=((0.27900001)*cj6);
IkReal x1425=((0.039478501415)*x1416);
IkReal x1426=((0.27900001)*x1416);
IkReal x1427=((0.27900001)*x1417);
IkReal x1428=((0.039478501415)*x1417);
IkReal x1429=((0.17900000508718)*cj2*sj1);
evalcond[0]=((((-0.27900001)*x1420))+((r00*x1424))+(((-1.0)*x1418))+(((-1.0)*x1416*x1429))+(((-0.07075)*x1416))+((x1417*x1423)));
evalcond[1]=((((-0.27900001)*x1422))+(((-1.0)*x1419))+(((-1.0)*x1416*x1423))+(((-1.0)*x1417*x1429))+((r10*x1424))+(((-0.07075)*x1417)));
evalcond[2]=(((x1420*x1427))+(((-1.0)*x1416*x1419))+((px*x1417))+(((-1.0)*x1422*x1426))+((r10*x1416*x1424))+(((-1.0)*r00*x1417*x1424))+(((-1.0)*x1423)));
evalcond[3]=((-0.07075)+(((-1.0)*x1417*x1419))+(((-1.0)*x1420*x1426))+(((-1.0)*x1416*x1418))+(((-1.0)*x1422*x1427))+((r10*x1417*x1424))+((r00*x1416*x1424))+(((-1.0)*x1429)));
evalcond[4]=((-0.0508055662587896)+(((-0.1415)*py*x1417))+((cj6*r00*x1425))+(((-0.1415)*px*x1416))+(((-1.0)*x1420*x1425))+(((-1.0)*pp))+((py*r10*x1421))+(((-1.0)*x1422*x1428))+((cj6*r10*x1428))+((px*r00*x1421))+(((-0.55800002)*py*x1422))+(((-0.55800002)*px*x1420)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1430=cj6*cj6;
IkReal x1431=r01*r01;
IkReal x1432=cj2*cj2;
IkReal x1433=(r01*sj6);
IkReal x1434=((13950000.5)*sj2);
IkReal x1435=(cj6*r00);
IkReal x1436=((155865922.944592)*px);
IkReal x1437=(cj6*r10);
IkReal x1438=(cj2*sj1);
IkReal x1439=((77932961.472296)*py);
IkReal x1440=(r01*r11);
IkReal x1441=(r11*sj6);
IkReal x1442=((77932961.472296)*px);
IkReal x1443=((21743297.0301002)*x1430);
IkReal x1444=((8950000.25435901)*x1432);
CheckValue<IkReal> x1445=IKPowWithIntegerCheck(IKsign(((((-13950000.5)*x1437*x1438))+(((5513757.02416494)*x1441))+(((-1.0)*x1434*x1435))+(((50000000.0)*px*sj2))+(((50000000.0)*py*x1438))+((x1433*x1434))+(((13950000.5)*x1438*x1441))+(((-5513757.02416494)*x1437))+(((19762569.27075)*py)))),-1);
if(!x1445.valid){
continue;
}
CheckValue<IkReal> x1446 = IKatan2WithCheck(IkReal(((-1398201.77590556)+((x1443*(r00*r00)))+(((-1.0)*x1435*x1436))+((x1433*x1436))+((x1444*(cj1*cj1)))+(((-43486594.0602004)*x1433*x1435))+(((-7075000.0)*x1438))+(((-1.0)*x1444))+(((-1.0)*x1431*x1443))+(((21743297.0301002)*x1431))+(((279329601.0)*(px*px))))),IkReal(((((-21743297.0301002)*x1440))+((x1437*x1442))+(((-8950000.25435901)*sj2*x1438))+((x1440*x1443))+((x1435*x1439))+(((-1.0)*r00*r10*x1443))+(((-1.0)*x1441*x1442))+(((-279329601.0)*px*py))+(((-3537500.0)*sj2))+(((21743297.0301002)*x1433*x1437))+(((21743297.0301002)*x1435*x1441))+(((-1.0)*x1433*x1439)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1446.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1445.value)))+(x1446.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1447=IKcos(j0);
IkReal x1448=IKsin(j0);
IkReal x1449=((1.0)*px);
IkReal x1450=((1.0)*py);
IkReal x1451=(r01*sj6);
IkReal x1452=((0.55800002)*cj6);
IkReal x1453=(r11*sj6);
IkReal x1454=((0.17900000508718)*sj2);
IkReal x1455=((0.27900001)*cj6);
IkReal x1456=((0.039478501415)*x1447);
IkReal x1457=((0.27900001)*x1447);
IkReal x1458=((0.27900001)*x1448);
IkReal x1459=((0.039478501415)*x1448);
IkReal x1460=((0.17900000508718)*cj2*sj1);
evalcond[0]=((((-0.07075)*x1447))+((x1448*x1454))+(((-0.27900001)*x1451))+((r00*x1455))+(((-1.0)*x1449))+(((-1.0)*x1447*x1460)));
evalcond[1]=(((r10*x1455))+(((-1.0)*x1447*x1454))+(((-0.07075)*x1448))+(((-1.0)*x1448*x1460))+(((-1.0)*x1450))+(((-0.27900001)*x1453)));
evalcond[2]=((((-1.0)*x1447*x1450))+(((-1.0)*x1454))+((r10*x1447*x1455))+(((-1.0)*x1453*x1457))+((px*x1448))+(((-1.0)*r00*x1448*x1455))+((x1451*x1458)));
evalcond[3]=((-0.07075)+((r00*x1447*x1455))+(((-1.0)*x1448*x1450))+(((-1.0)*x1460))+(((-1.0)*x1447*x1449))+(((-1.0)*x1453*x1458))+(((-1.0)*x1451*x1457))+((r10*x1448*x1455)));
evalcond[4]=((-0.0508055662587896)+((py*r10*x1452))+((cj6*r10*x1459))+(((-0.55800002)*py*x1453))+(((-0.55800002)*px*x1451))+((px*r00*x1452))+(((-0.1415)*py*x1448))+(((-0.1415)*px*x1447))+(((-1.0)*pp))+((cj6*r00*x1456))+(((-1.0)*x1453*x1459))+(((-1.0)*x1451*x1456)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1461=(r11*sj6);
IkReal x1462=(cj6*r10);
IkReal x1463=((1.396648005e+16)*sj2);
IkReal x1464=(r01*sj6);
IkReal x1465=(cj6*r00);
IkReal x1466=((3.8966480736148e+15)*sj2);
IkReal x1467=((3.8966480736148e+15)*cj2*sj1);
IkReal x1468=(cj6*x1466);
IkReal x1469=((1.396648005e+16)*cj2*sj1);
CheckValue<IkReal> x1470 = IKatan2WithCheck(IkReal(((((1.54015554957094e+15)*x1461))+(((-1.54015554957094e+15)*x1462))+((py*x1469))+((x1465*x1466))+((x1461*x1467))+(((-1.0)*x1462*x1467))+(((-1.0)*x1464*x1466))+(((-1.0)*px*x1463))+(((5.52027058913346e+15)*py)))),IkReal(((((1.54015554957094e+15)*x1464))+(((-1.54015554957094e+15)*x1465))+((py*x1463))+((x1461*x1466))+(((-1.0)*x1462*x1466))+((x1464*x1467))+((px*x1469))+(((-1.0)*x1465*x1467))+(((5.52027058913346e+15)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1470.valid){
continue;
}
CheckValue<IkReal> x1471=IKPowWithIntegerCheck(IKsign(((-2.89055914418119e+15)+(((2.5e+15)*(cj1*cj1)*(cj2*cj2)))+(((-1.976256927075e+15)*cj2*sj1)))),-1);
if(!x1471.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1470.value)+(((1.5707963267949)*(x1471.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1472=IKcos(j0);
IkReal x1473=IKsin(j0);
IkReal x1474=((1.0)*px);
IkReal x1475=((1.0)*py);
IkReal x1476=(r01*sj6);
IkReal x1477=((0.55800002)*cj6);
IkReal x1478=(r11*sj6);
IkReal x1479=((0.17900000508718)*sj2);
IkReal x1480=((0.27900001)*cj6);
IkReal x1481=((0.039478501415)*x1472);
IkReal x1482=((0.27900001)*x1472);
IkReal x1483=((0.27900001)*x1473);
IkReal x1484=((0.039478501415)*x1473);
IkReal x1485=((0.17900000508718)*cj2*sj1);
evalcond[0]=((((-0.07075)*x1472))+((r00*x1480))+(((-0.27900001)*x1476))+((x1473*x1479))+(((-1.0)*x1474))+(((-1.0)*x1472*x1485)));
evalcond[1]=((((-0.07075)*x1473))+((r10*x1480))+(((-0.27900001)*x1478))+(((-1.0)*x1475))+(((-1.0)*x1473*x1485))+(((-1.0)*x1472*x1479)));
evalcond[2]=(((x1476*x1483))+(((-1.0)*r00*x1473*x1480))+((r10*x1472*x1480))+(((-1.0)*x1479))+((px*x1473))+(((-1.0)*x1472*x1475))+(((-1.0)*x1478*x1482)));
evalcond[3]=((-0.07075)+(((-1.0)*x1485))+((r00*x1472*x1480))+((r10*x1473*x1480))+(((-1.0)*x1472*x1474))+(((-1.0)*x1478*x1483))+(((-1.0)*x1476*x1482))+(((-1.0)*x1473*x1475)));
evalcond[4]=((-0.0508055662587896)+(((-0.1415)*py*x1473))+((py*r10*x1477))+((cj6*r10*x1484))+(((-1.0)*pp))+((cj6*r00*x1481))+(((-0.1415)*px*x1472))+(((-0.55800002)*py*x1478))+(((-0.55800002)*px*x1476))+(((-1.0)*x1478*x1484))+(((-1.0)*x1476*x1481))+((px*r00*x1477)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1486=((50000000.0)*pp);
IkReal x1487=((100000000.0)*pz);
IkReal x1488=((1266425.0359918)*cj2*sj1);
IkReal x1489=((17900000.508718)*cj1*cj2);
CheckValue<IkReal> x1490=IKPowWithIntegerCheck(IKsign(((((-27900001.0)*npx*r21))+(((27900001.0)*npy*r20)))),-1);
if(!x1490.valid){
continue;
}
CheckValue<IkReal> x1491 = IKatan2WithCheck(IkReal((((r20*x1488))+((npx*x1487))+((npx*x1489))+(((-1.0)*r20*x1486))+(((-2039722.06293948)*r20)))),IkReal(((((-1.0)*r21*x1486))+((r21*x1488))+((npy*x1489))+((npy*x1487))+(((-2039722.06293948)*r21)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1491.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1490.value)))+(x1491.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
IkReal x1492=IKcos(j6);
IkReal x1493=IKsin(j6);
evalcond[0]=((((0.27900001)*r20*x1492))+(((-0.17900000508718)*cj1*cj2))+(((-1.0)*pz))+(((-0.27900001)*r21*x1493)));
evalcond[1]=((-0.0407944412587896)+(((-0.55800002)*npy*x1493))+(((0.025328500719836)*cj2*sj1))+(((-1.0)*pp))+(((0.55800002)*npx*x1492)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0eval[2];
IkReal x1494=cj1*cj1;
IkReal x1495=cj2*cj2;
IkReal x1496=(cj2*sj1);
IkReal x1497=(x1494*x1495);
j0eval[0]=((-1.46264339650383)+(((1.26501770379633)*x1497))+(((-1.0)*x1496)));
j0eval[1]=IKsign(((-2.89055914418119e+15)+(((2.5e+15)*x1497))+(((-1.976256927075e+15)*x1496))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
IkReal x1498=(cj6*r10);
IkReal x1499=(cj2*sj1);
IkReal x1500=(r11*sj6);
IkReal x1501=(px*sj2);
IkReal x1502=(r01*sj2*sj6);
IkReal x1503=(cj6*r00*sj2);
j0eval[0]=((((9.06822694233112)*py*x1499))+(((-1.0)*x1498))+(((2.53003540759265)*x1499*x1500))+(((-2.53003540759265)*x1503))+x1500+(((2.53003540759265)*x1502))+(((-2.53003540759265)*x1498*x1499))+(((3.584229262214)*py))+(((9.06822694233112)*x1501)));
j0eval[1]=IKsign(((((50000000.0)*py*x1499))+(((13950000.5)*x1502))+(((5513757.02416494)*x1500))+(((-13950000.5)*x1503))+(((-5513757.02416494)*x1498))+(((-13950000.5)*x1498*x1499))+(((19762569.27075)*py))+(((50000000.0)*x1501))+(((13950000.5)*x1499*x1500))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
IkReal x1504=(cj6*r00);
IkReal x1505=((2.53003540759265)*sj6);
IkReal x1506=(cj2*sj1);
j0eval[0]=((((-2.53003540759265)*cj6*r10*sj2))+(((-1.0)*r01*sj6))+(((-1.0)*r01*x1505*x1506))+x1504+(((-3.584229262214)*px))+((r11*sj2*x1505))+(((2.53003540759265)*x1504*x1506))+(((-9.06822694233112)*px*x1506))+(((9.06822694233112)*py*sj2)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1507=cj6*cj6;
IkReal x1508=r01*r01;
IkReal x1509=(r01*sj6);
IkReal x1510=(cj6*r10);
IkReal x1511=(cj2*sj1);
IkReal x1512=((3.8966480736148e+15)*sj2);
IkReal x1513=(r11*sj6);
IkReal x1514=((77932961.472296)*py);
IkReal x1515=((4.35379660656096e+16)*px);
IkReal x1516=(cj6*r00);
IkReal x1517=(py*sj2);
IkReal x1518=((13950000.5)*sj2);
IkReal x1519=((77932961.472296)*px);
IkReal x1520=((6.07354648384237e+15)*x1508);
IkReal x1521=((21743297.0301002)*r01*r11);
CheckValue<IkReal> x1522=IKPowWithIntegerCheck((((x1513*x1518))+(((50000000.0)*x1517))+(((5513757.02416494)*x1516))+(((-13950000.5)*x1509*x1511))+(((-1.0)*x1510*x1518))+(((13950000.5)*x1511*x1516))+(((-19762569.27075)*px))+(((-50000000.0)*px*x1511))+(((-5513757.02416494)*x1509))),-1);
if(!x1522.valid){
continue;
}
CheckValue<IkReal> x1523=IKPowWithIntegerCheck(((((-1.0)*x1510*x1512))+(((-3.8966480736148e+15)*x1509*x1511))+(((1.54015554957094e+15)*x1516))+(((-1.54015554957094e+15)*x1509))+(((1.396648005e+16)*x1517))+(((-5.52027058913346e+15)*px))+(((3.8966480736148e+15)*x1511*x1516))+((x1512*x1513))+(((-1.396648005e+16)*px*x1511))),-1);
if(!x1523.valid){
continue;
}
if( IKabs(((x1522.value)*((((x1513*x1519))+((x1509*x1514))+(((-1.0)*x1507*x1521))+(((-1.0)*x1510*x1519))+(((-3537500.0)*sj2))+(((-21743297.0301002)*x1509*x1510))+x1521+(((-1.0)*x1514*x1516))+(((21743297.0301002)*r00*r10*x1507))+(((-21743297.0301002)*x1513*x1516))+(((279329601.0)*px*py))+(((-8950000.25435901)*sj2*x1511)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1523.value)*(((-2.5e+15)+(((-1.21470929676847e+16)*x1509*x1516))+((x1509*x1515))+(((-1.0)*x1515*x1516))+(((-1.0)*x1507*x1520))+(((6.07354648384237e+15)*x1507*(r00*r00)))+(((7.80250259948192e+16)*(px*px)))+x1520+(((2.5e+15)*(cj2*cj2))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1522.value)*((((x1513*x1519))+((x1509*x1514))+(((-1.0)*x1507*x1521))+(((-1.0)*x1510*x1519))+(((-3537500.0)*sj2))+(((-21743297.0301002)*x1509*x1510))+x1521+(((-1.0)*x1514*x1516))+(((21743297.0301002)*r00*r10*x1507))+(((-21743297.0301002)*x1513*x1516))+(((279329601.0)*px*py))+(((-8950000.25435901)*sj2*x1511))))))+IKsqr(((x1523.value)*(((-2.5e+15)+(((-1.21470929676847e+16)*x1509*x1516))+((x1509*x1515))+(((-1.0)*x1515*x1516))+(((-1.0)*x1507*x1520))+(((6.07354648384237e+15)*x1507*(r00*r00)))+(((7.80250259948192e+16)*(px*px)))+x1520+(((2.5e+15)*(cj2*cj2)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((x1522.value)*((((x1513*x1519))+((x1509*x1514))+(((-1.0)*x1507*x1521))+(((-1.0)*x1510*x1519))+(((-3537500.0)*sj2))+(((-21743297.0301002)*x1509*x1510))+x1521+(((-1.0)*x1514*x1516))+(((21743297.0301002)*r00*r10*x1507))+(((-21743297.0301002)*x1513*x1516))+(((279329601.0)*px*py))+(((-8950000.25435901)*sj2*x1511))))), ((x1523.value)*(((-2.5e+15)+(((-1.21470929676847e+16)*x1509*x1516))+((x1509*x1515))+(((-1.0)*x1515*x1516))+(((-1.0)*x1507*x1520))+(((6.07354648384237e+15)*x1507*(r00*r00)))+(((7.80250259948192e+16)*(px*px)))+x1520+(((2.5e+15)*(cj2*cj2)))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1524=IKcos(j0);
IkReal x1525=IKsin(j0);
IkReal x1526=((1.0)*px);
IkReal x1527=((1.0)*py);
IkReal x1528=(r01*sj6);
IkReal x1529=((0.17900000508718)*sj2);
IkReal x1530=((0.27900001)*cj6);
IkReal x1531=(r11*sj6);
IkReal x1532=((0.039478501415)*x1524);
IkReal x1533=((0.27900001)*x1524);
IkReal x1534=(r10*x1525);
IkReal x1535=((0.17900000508718)*cj2*sj1);
IkReal x1536=(x1525*x1531);
evalcond[0]=((((-1.0)*x1524*x1535))+(((-0.27900001)*x1528))+((x1525*x1529))+(((-1.0)*x1526))+((r00*x1530))+(((-0.07075)*x1524)));
evalcond[1]=((((-1.0)*x1524*x1529))+(((-1.0)*x1525*x1535))+((r10*x1530))+(((-1.0)*x1527))+(((-0.07075)*x1525))+(((-0.27900001)*x1531)));
evalcond[2]=(((r10*x1524*x1530))+(((-1.0)*x1524*x1527))+(((-1.0)*x1531*x1533))+(((-1.0)*x1529))+((px*x1525))+(((0.27900001)*x1525*x1528))+(((-1.0)*r00*x1525*x1530)));
evalcond[3]=((-0.07075)+(((-1.0)*x1524*x1526))+(((-1.0)*x1535))+(((-1.0)*x1525*x1527))+((x1530*x1534))+(((-1.0)*x1528*x1533))+((r00*x1524*x1530))+(((-0.27900001)*x1536)));
evalcond[4]=((-0.0508055662587896)+(((0.039478501415)*cj6*x1534))+((cj6*r00*x1532))+(((0.55800002)*cj6*npx))+(((-1.0)*pp))+(((-0.1415)*px*x1524))+(((-0.039478501415)*x1536))+(((-1.0)*x1528*x1532))+(((-0.1415)*py*x1525))+(((-0.55800002)*npy*sj6)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1537=cj6*cj6;
IkReal x1538=r01*r01;
IkReal x1539=cj2*cj2;
IkReal x1540=(r01*sj6);
IkReal x1541=((13950000.5)*sj2);
IkReal x1542=(cj6*r00);
IkReal x1543=((155865922.944592)*px);
IkReal x1544=(cj6*r10);
IkReal x1545=(cj2*sj1);
IkReal x1546=((77932961.472296)*py);
IkReal x1547=(r01*r11);
IkReal x1548=(r11*sj6);
IkReal x1549=((77932961.472296)*px);
IkReal x1550=((21743297.0301002)*x1537);
IkReal x1551=((8950000.25435901)*x1539);
CheckValue<IkReal> x1552 = IKatan2WithCheck(IkReal(((-1398201.77590556)+(((-7075000.0)*x1545))+((x1540*x1543))+(((-1.0)*x1538*x1550))+((x1551*(cj1*cj1)))+((x1550*(r00*r00)))+(((-1.0)*x1542*x1543))+(((-43486594.0602004)*x1540*x1542))+(((-1.0)*x1551))+(((21743297.0301002)*x1538))+(((279329601.0)*(px*px))))),IkReal((((x1547*x1550))+((x1544*x1549))+(((-1.0)*x1548*x1549))+(((-1.0)*x1540*x1546))+(((21743297.0301002)*x1540*x1544))+(((-8950000.25435901)*sj2*x1545))+(((-279329601.0)*px*py))+(((21743297.0301002)*x1542*x1548))+(((-3537500.0)*sj2))+(((-1.0)*r00*r10*x1550))+(((-21743297.0301002)*x1547))+((x1542*x1546)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1552.valid){
continue;
}
CheckValue<IkReal> x1553=IKPowWithIntegerCheck(IKsign(((((50000000.0)*py*x1545))+(((50000000.0)*px*sj2))+(((5513757.02416494)*x1548))+(((13950000.5)*x1545*x1548))+(((-13950000.5)*x1544*x1545))+(((-5513757.02416494)*x1544))+((x1540*x1541))+(((19762569.27075)*py))+(((-1.0)*x1541*x1542)))),-1);
if(!x1553.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1552.value)+(((1.5707963267949)*(x1553.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1554=IKcos(j0);
IkReal x1555=IKsin(j0);
IkReal x1556=((1.0)*px);
IkReal x1557=((1.0)*py);
IkReal x1558=(r01*sj6);
IkReal x1559=((0.17900000508718)*sj2);
IkReal x1560=((0.27900001)*cj6);
IkReal x1561=(r11*sj6);
IkReal x1562=((0.039478501415)*x1554);
IkReal x1563=((0.27900001)*x1554);
IkReal x1564=(r10*x1555);
IkReal x1565=((0.17900000508718)*cj2*sj1);
IkReal x1566=(x1555*x1561);
evalcond[0]=(((x1555*x1559))+(((-0.27900001)*x1558))+(((-0.07075)*x1554))+(((-1.0)*x1556))+(((-1.0)*x1554*x1565))+((r00*x1560)));
evalcond[1]=((((-1.0)*x1555*x1565))+(((-0.07075)*x1555))+(((-0.27900001)*x1561))+((r10*x1560))+(((-1.0)*x1557))+(((-1.0)*x1554*x1559)));
evalcond[2]=((((0.27900001)*x1555*x1558))+(((-1.0)*r00*x1555*x1560))+((r10*x1554*x1560))+(((-1.0)*x1559))+((px*x1555))+(((-1.0)*x1561*x1563))+(((-1.0)*x1554*x1557)));
evalcond[3]=((-0.07075)+((x1560*x1564))+((r00*x1554*x1560))+(((-0.27900001)*x1566))+(((-1.0)*x1555*x1557))+(((-1.0)*x1565))+(((-1.0)*x1554*x1556))+(((-1.0)*x1558*x1563)));
evalcond[4]=((-0.0508055662587896)+(((-0.1415)*px*x1554))+(((0.039478501415)*cj6*x1564))+(((0.55800002)*cj6*npx))+(((-1.0)*pp))+(((-0.55800002)*npy*sj6))+((cj6*r00*x1562))+(((-0.1415)*py*x1555))+(((-1.0)*x1558*x1562))+(((-0.039478501415)*x1566)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1567=(r11*sj6);
IkReal x1568=(cj6*r10);
IkReal x1569=((1.396648005e+16)*sj2);
IkReal x1570=(r01*sj6);
IkReal x1571=(cj6*r00);
IkReal x1572=((3.8966480736148e+15)*sj2);
IkReal x1573=((3.8966480736148e+15)*cj2*sj1);
IkReal x1574=(cj6*x1572);
IkReal x1575=((1.396648005e+16)*cj2*sj1);
CheckValue<IkReal> x1576 = IKatan2WithCheck(IkReal((((x1571*x1572))+((x1567*x1573))+(((-1.54015554957094e+15)*x1568))+(((-1.0)*x1570*x1572))+(((-1.0)*x1568*x1573))+(((-1.0)*px*x1569))+((py*x1575))+(((5.52027058913346e+15)*py))+(((1.54015554957094e+15)*x1567)))),IkReal(((((-1.54015554957094e+15)*x1571))+((x1567*x1572))+(((-1.0)*x1571*x1573))+((x1570*x1573))+(((-1.0)*x1568*x1572))+((px*x1575))+((py*x1569))+(((1.54015554957094e+15)*x1570))+(((5.52027058913346e+15)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1576.valid){
continue;
}
CheckValue<IkReal> x1577=IKPowWithIntegerCheck(IKsign(((-2.89055914418119e+15)+(((2.5e+15)*(cj1*cj1)*(cj2*cj2)))+(((-1.976256927075e+15)*cj2*sj1)))),-1);
if(!x1577.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1576.value)+(((1.5707963267949)*(x1577.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1578=IKcos(j0);
IkReal x1579=IKsin(j0);
IkReal x1580=((1.0)*px);
IkReal x1581=((1.0)*py);
IkReal x1582=(r01*sj6);
IkReal x1583=((0.17900000508718)*sj2);
IkReal x1584=((0.27900001)*cj6);
IkReal x1585=(r11*sj6);
IkReal x1586=((0.039478501415)*x1578);
IkReal x1587=((0.27900001)*x1578);
IkReal x1588=(r10*x1579);
IkReal x1589=((0.17900000508718)*cj2*sj1);
IkReal x1590=(x1579*x1585);
evalcond[0]=((((-1.0)*x1580))+(((-0.07075)*x1578))+(((-1.0)*x1578*x1589))+(((-0.27900001)*x1582))+((x1579*x1583))+((r00*x1584)));
evalcond[1]=((((-1.0)*x1581))+(((-0.07075)*x1579))+(((-1.0)*x1578*x1583))+(((-0.27900001)*x1585))+(((-1.0)*x1579*x1589))+((r10*x1584)));
evalcond[2]=((((-1.0)*x1583))+((r10*x1578*x1584))+(((-1.0)*x1578*x1581))+(((-1.0)*x1585*x1587))+(((-1.0)*r00*x1579*x1584))+(((0.27900001)*x1579*x1582))+((px*x1579)));
evalcond[3]=((-0.07075)+(((-1.0)*x1589))+(((-1.0)*x1578*x1580))+((x1584*x1588))+(((-0.27900001)*x1590))+((r00*x1578*x1584))+(((-1.0)*x1579*x1581))+(((-1.0)*x1582*x1587)));
evalcond[4]=((-0.0508055662587896)+(((-0.1415)*px*x1578))+((cj6*r00*x1586))+(((0.55800002)*cj6*npx))+(((0.039478501415)*cj6*x1588))+(((-1.0)*pp))+(((-0.1415)*py*x1579))+(((-0.55800002)*npy*sj6))+(((-0.039478501415)*x1590))+(((-1.0)*x1582*x1586)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
    }
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x252=(cj1*sj2);
IkReal x253=(cj2*sj1);
IkReal x254=((1.0)*cj6);
IkReal x255=((1.0)*r20);
IkReal x256=(cj1*sj0);
IkReal x257=(cj0*cj1);
IkReal x258=((1.0)*sj0);
IkReal x259=((1.0)*sj1);
IkReal x260=(cj0*sj2);
IkReal x261=(cj1*cj2);
IkReal x262=((((-1.0)*sj2*x258))+((cj0*x253)));
IkReal x263=(((sj0*x253))+x260);
IkReal x264=((((-1.0)*sj1*sj2*x258))+((cj0*cj2)));
IkReal x265=(r11*x264);
IkReal x266=(r10*x264);
IkReal x267=((((-1.0)*x259*x260))+(((-1.0)*cj2*x258)));
IkReal x268=(((r11*x256))+((r01*x257))+(((-1.0)*r21*x259)));
IkReal x269=(((r00*x257))+((r10*x256))+(((-1.0)*sj1*x255)));
IkReal x270=(r01*x267);
IkReal x271=(r00*x267);
IkReal x272=(x266+x271);
IkReal x273=(x265+x270);
IkReal x274=(((r21*x261))+((r11*x263))+((r01*x262)));
IkReal x275=(((r00*x262))+((r10*x263))+((r20*x261)));
new_r00=(((r22*x261))+((r02*x262))+((r12*x263)));
new_r01=(((sj6*x275))+((cj6*x274)));
new_r02=(((sj6*x274))+(((-1.0)*x254*x275)));
new_r10=((((-1.0)*r22*x259))+((r12*x256))+((r02*x257)));
new_r11=(((sj6*x269))+((cj6*x268)));
new_r12=(((sj6*x268))+(((-1.0)*x254*x269)));
new_r20=((((-1.0)*r22*x252))+((r02*x267))+((r12*x264)));
new_r21=(((cj6*(((((-1.0)*r21*x252))+x273))))+((sj6*(((((-1.0)*x252*x255))+x272)))));
new_r22=((((-1.0)*x254*((x272+(((-1.0)*r20*x252))))))+((sj6*(((((-1.0)*r21*x252))+x273)))));
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
sj4array[0]=((-1.0)*new_r22);
if( sj4array[0] >= -1-IKFAST_SINCOS_THRESH && sj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKasin(sj4array[0]);
    cj4array[0] = IKcos(j4array[0]);
    sj4array[1] = sj4array[0];
    j4array[1] = j4array[0] > 0 ? (IKPI-j4array[0]) : (-IKPI-j4array[0]);
    cj4array[1] = -cj4array[0];
}
else if( isnan(sj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IkReal j5eval[3];
j5eval[0]=cj4;
j5eval[1]=IKsign(cj4);
j5eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
j3eval[0]=cj4;
j3eval[1]=IKsign(cj4);
j3eval[2]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
j3eval[0]=cj4;
j3eval[1]=new_r02;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j5mul = 1;
j5=0;
j3mul=1.0;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3=IKatan2(new_r01, ((-1.0)*new_r11));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].fmul = j3mul;
vinfos[3].freeind = 0;
vinfos[3].maxsolutions = 0;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].fmul = j5mul;
vinfos[5].freeind = 0;
vinfos[5].maxsolutions = 0;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(1);
vfree[0] = 5;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j5mul = 1;
j5=0;
j3mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3=IKatan2(((-1.0)*new_r01), new_r11);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].fmul = j3mul;
vinfos[3].freeind = 0;
vinfos[3].maxsolutions = 0;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].fmul = j5mul;
vinfos[5].freeind = 0;
vinfos[5].maxsolutions = 0;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(1);
vfree[0] = 5;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
IkReal x276=new_r22*new_r22;
IkReal x277=((16.0)*new_r10);
IkReal x278=((16.0)*new_r01);
IkReal x279=((16.0)*new_r00);
IkReal x280=(new_r11*new_r22);
IkReal x281=((8.0)*new_r00);
IkReal x282=(x276*x277);
IkReal x283=(x276*x278);
j3eval[0]=((IKabs(((((32.0)*new_r00))+(((-16.0)*x280))+(((-1.0)*x276*x279)))))+(IKabs(((((-8.0)*x280))+((x276*x281)))))+(IKabs((((new_r22*x281))+(((-8.0)*new_r11)))))+(IKabs((x282+(((-1.0)*x277)))))+(IKabs((((new_r22*x279))+(((-32.0)*new_r11*x276))+(((16.0)*new_r11)))))+(IKabs((x278+(((-1.0)*x283)))))+(IKabs((x283+(((-1.0)*x278)))))+(IKabs((x277+(((-1.0)*x282))))));
if( IKabs(j3eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j3, j5]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j3evalpoly[1];
IkReal x284=new_r22*new_r22;
IkReal x285=((16.0)*new_r01);
IkReal x286=(new_r00*new_r22);
IkReal x287=(x284*x285);
IkReal x288=((((8.0)*x286))+(((-8.0)*new_r11)));
op[0]=x288;
op[1]=(x287+(((-1.0)*x285)));
op[2]=((((-32.0)*new_r11*x284))+(((16.0)*x286))+(((16.0)*new_r11)));
op[3]=(x285+(((-1.0)*x287)));
op[4]=x288;
polyroots4(op,zeror,numroots);
IkReal j3array[4], cj3array[4], sj3array[4], tempj3array[1];
int numsolutions = 0;
for(int ij3 = 0; ij3 < numroots; ++ij3)
{
IkReal htj3 = zeror[ij3];
tempj3array[0]=((2.0)*(atan(htj3)));
for(int kj3 = 0; kj3 < 1; ++kj3)
{
j3array[numsolutions] = tempj3array[kj3];
if( j3array[numsolutions] > IKPI )
{
    j3array[numsolutions]-=IK2PI;
}
else if( j3array[numsolutions] < -IKPI )
{
    j3array[numsolutions]+=IK2PI;
}
sj3array[numsolutions] = IKsin(j3array[numsolutions]);
cj3array[numsolutions] = IKcos(j3array[numsolutions]);
numsolutions++;
}
}
bool j3valid[4]={true,true,true,true};
_nj3 = 4;
for(int ij3 = 0; ij3 < numsolutions; ++ij3)
    {
if( !j3valid[ij3] )
{
    continue;
}
    j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
htj3 = IKtan(j3/2);

IkReal x289=new_r22*new_r22;
IkReal x290=((16.0)*new_r10);
IkReal x291=(new_r11*new_r22);
IkReal x292=((8.0)*x291);
IkReal x293=(new_r00*x289);
IkReal x294=(x289*x290);
IkReal x295=((8.0)*x293);
j3evalpoly[0]=((((htj3*htj3*htj3)*(((((-1.0)*x294))+x290))))+(((htj3*htj3*htj3*htj3)*(((((-1.0)*x292))+x295))))+(((-1.0)*x292))+x295+((htj3*(((((-1.0)*x290))+x294))))+(((htj3*htj3)*(((((32.0)*new_r00))+(((-16.0)*x293))+(((-16.0)*x291)))))));
if( IKabs(j3evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < numsolutions; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
{
IkReal j5eval[3];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
IkReal x296=cj3*cj3;
IkReal x297=new_r22*new_r22;
IkReal x298=(new_r22*sj3);
IkReal x299=((((-1.0)*x296))+(((-1.0)*x297))+((x296*x297)));
j5eval[0]=x299;
j5eval[1]=IKsign(x299);
j5eval[2]=((IKabs((((new_r00*x298))+((cj3*new_r01)))))+(IKabs(((((-1.0)*cj3*new_r00))+((new_r01*x298))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j5eval[0]=new_r22;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j5eval[0]=cj3;
j5eval[1]=new_r22;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x300=IKsin(j5);
IkReal x301=IKcos(j5);
IkReal x302=((1.0)*new_r22);
IkReal x303=((1.0)*x301);
evalcond[0]=(x300+new_r11);
evalcond[1]=(new_r10+(((-1.0)*x303)));
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x300*x302)));
evalcond[3]=((((-1.0)*x301*x302))+(((-1.0)*new_r01)));
evalcond[4]=((((-1.0)*x300))+(((-1.0)*new_r00*x302)));
evalcond[5]=((((-1.0)*new_r01*x302))+(((-1.0)*x303)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x304=IKsin(j5);
IkReal x305=IKcos(j5);
IkReal x306=((1.0)*x305);
IkReal x307=((1.0)*x304);
evalcond[0]=(x304+(((-1.0)*new_r11)));
evalcond[1]=((((-1.0)*new_r22*x307))+new_r00);
evalcond[2]=((((-1.0)*new_r22*x306))+new_r01);
evalcond[3]=((((-1.0)*new_r10))+(((-1.0)*x306)));
evalcond[4]=(((new_r00*new_r22))+(((-1.0)*x307)));
evalcond[5]=(((new_r01*new_r22))+(((-1.0)*x306)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x308=new_r22*new_r22;
CheckValue<IkReal> x309=IKPowWithIntegerCheck(((-1.0)+x308),-1);
if(!x309.valid){
continue;
}
if(((x308*(x309.value))) < -0.00001)
continue;
IkReal gconst38=IKsqrt((x308*(x309.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj3+(((-1.0)*gconst38)))))+(IKabs(((-1.0)+(IKsign(sj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if((((1.0)+(((-1.0)*(gconst38*gconst38))))) < -0.00001)
continue;
IkReal x310=IKsqrt(((1.0)+(((-1.0)*(gconst38*gconst38)))));
if( IKabs(((((-1.0)*gconst38*new_r01))+(((-1.0)*new_r11*x310)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r10*x310))+((gconst38*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*gconst38*new_r01))+(((-1.0)*new_r11*x310))))+IKsqr((((new_r10*x310))+((gconst38*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*gconst38*new_r01))+(((-1.0)*new_r11*x310))), (((new_r10*x310))+((gconst38*new_r00))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[10];
IkReal x311=IKcos(j5);
IkReal x312=IKsin(j5);
IkReal x313=(gconst38*new_r22);
IkReal x314=((1.0)*x311);
IkReal x315=(new_r22*x311);
IkReal x316=((1.0)*x312);
IkReal x317=x310;
IkReal x318=((1.0)*x317);
IkReal x319=(x312*x317);
evalcond[0]=(x312+((new_r11*x317))+((gconst38*new_r01)));
evalcond[1]=((((-1.0)*x314))+((new_r10*x317))+((gconst38*new_r00)));
evalcond[2]=(((gconst38*x312))+((x315*x317))+new_r01);
evalcond[3]=((((-1.0)*x313*x314))+x319+new_r11);
evalcond[4]=((((-1.0)*new_r00*x318))+(((-1.0)*new_r22*x316))+((gconst38*new_r10)));
evalcond[5]=((((-1.0)*new_r22*x314))+((gconst38*new_r11))+(((-1.0)*new_r01*x318)));
evalcond[6]=(new_r00+(((-1.0)*gconst38*x314))+((new_r22*x319)));
evalcond[7]=((((-1.0)*x313*x316))+(((-1.0)*x314*x317))+new_r10);
evalcond[8]=((((-1.0)*new_r00*new_r22*x318))+(((-1.0)*x316))+((new_r10*x313)));
evalcond[9]=((((-1.0)*new_r01*new_r22*x318))+(((-1.0)*x314))+((new_r11*x313)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x320=new_r22*new_r22;
CheckValue<IkReal> x321=IKPowWithIntegerCheck(((-1.0)+x320),-1);
if(!x321.valid){
continue;
}
if(((x320*(x321.value))) < -0.00001)
continue;
IkReal gconst38=IKsqrt((x320*(x321.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj3+(((-1.0)*gconst38)))))+(IKabs(((1.0)+(IKsign(sj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if((((1.0)+(((-1.0)*(gconst38*gconst38))))) < -0.00001)
continue;
IkReal x322=IKsqrt(((1.0)+(((-1.0)*(gconst38*gconst38)))));
if( IKabs(((((-1.0)*gconst38*new_r01))+((new_r11*x322)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r10*x322))+((gconst38*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*gconst38*new_r01))+((new_r11*x322))))+IKsqr(((((-1.0)*new_r10*x322))+((gconst38*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*gconst38*new_r01))+((new_r11*x322))), ((((-1.0)*new_r10*x322))+((gconst38*new_r00))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[10];
IkReal x323=IKsin(j5);
IkReal x324=IKcos(j5);
IkReal x325=(gconst38*new_r22);
IkReal x326=((1.0)*x324);
IkReal x327=((1.0)*x323);
IkReal x328=(new_r22*x324);
IkReal x329=x322;
IkReal x330=((1.0)*x329);
IkReal x331=(new_r00*x329);
IkReal x332=(new_r01*x329);
evalcond[0]=((((-1.0)*new_r11*x330))+x323+((gconst38*new_r01)));
evalcond[1]=((((-1.0)*new_r10*x330))+(((-1.0)*x326))+((gconst38*new_r00)));
evalcond[2]=((((-1.0)*new_r22*x327))+x331+((gconst38*new_r10)));
evalcond[3]=((((-1.0)*new_r22*x326))+x332+((gconst38*new_r11)));
evalcond[4]=(((gconst38*x323))+(((-1.0)*new_r22*x326*x329))+new_r01);
evalcond[5]=((((-1.0)*x325*x327))+((x324*x329))+new_r10);
evalcond[6]=(((new_r22*x331))+(((-1.0)*x327))+((new_r10*x325)));
evalcond[7]=(((new_r22*x332))+(((-1.0)*x326))+((new_r11*x325)));
evalcond[8]=((((-1.0)*x325*x326))+(((-1.0)*x327*x329))+new_r11);
evalcond[9]=((((-1.0)*gconst38*x326))+(((-1.0)*new_r22*x327*x329))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x333=new_r22*new_r22;
CheckValue<IkReal> x334=IKPowWithIntegerCheck(((-1.0)+x333),-1);
if(!x334.valid){
continue;
}
if(((x333*(x334.value))) < -0.00001)
continue;
IkReal gconst39=((-1.0)*(IKsqrt((x333*(x334.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.0)+(IKsign(sj3)))))+(IKabs((cj3+(((-1.0)*gconst39)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if((((1.0)+(((-1.0)*(gconst39*gconst39))))) < -0.00001)
continue;
IkReal x335=IKsqrt(((1.0)+(((-1.0)*(gconst39*gconst39)))));
if( IKabs(((((-1.0)*gconst39*new_r01))+(((-1.0)*new_r11*x335)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r10*x335))+((gconst39*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*gconst39*new_r01))+(((-1.0)*new_r11*x335))))+IKsqr((((new_r10*x335))+((gconst39*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*gconst39*new_r01))+(((-1.0)*new_r11*x335))), (((new_r10*x335))+((gconst39*new_r00))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[10];
IkReal x336=IKsin(j5);
IkReal x337=IKcos(j5);
IkReal x338=(gconst39*new_r22);
IkReal x339=((1.0)*new_r01);
IkReal x340=((1.0)*x337);
IkReal x341=((1.0)*x336);
IkReal x342=x335;
IkReal x343=(new_r22*x342);
IkReal x344=((1.0)*new_r00*x342);
IkReal x345=(x336*x342);
evalcond[0]=(((new_r11*x342))+((gconst39*new_r01))+x336);
evalcond[1]=(((new_r10*x342))+((gconst39*new_r00))+(((-1.0)*x340)));
evalcond[2]=(((x337*x343))+((gconst39*x336))+new_r01);
evalcond[3]=(x345+new_r11+(((-1.0)*x338*x340)));
evalcond[4]=(((gconst39*new_r10))+(((-1.0)*x344))+(((-1.0)*new_r22*x341)));
evalcond[5]=(((gconst39*new_r11))+(((-1.0)*new_r22*x340))+(((-1.0)*x339*x342)));
evalcond[6]=((((-1.0)*gconst39*x340))+((x336*x343))+new_r00);
evalcond[7]=((((-1.0)*x340*x342))+new_r10+(((-1.0)*x338*x341)));
evalcond[8]=((((-1.0)*new_r00*x343))+((new_r10*x338))+(((-1.0)*x341)));
evalcond[9]=(((new_r11*x338))+(((-1.0)*x340))+(((-1.0)*x339*x343)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x346=new_r22*new_r22;
CheckValue<IkReal> x347=IKPowWithIntegerCheck(((-1.0)+x346),-1);
if(!x347.valid){
continue;
}
if(((x346*(x347.value))) < -0.00001)
continue;
IkReal gconst39=((-1.0)*(IKsqrt((x346*(x347.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj3+(((-1.0)*gconst39)))))+(IKabs(((1.0)+(IKsign(sj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if((((1.0)+(((-1.0)*(gconst39*gconst39))))) < -0.00001)
continue;
IkReal x348=IKsqrt(((1.0)+(((-1.0)*(gconst39*gconst39)))));
if( IKabs((((new_r11*x348))+(((-1.0)*gconst39*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r10*x348))+((gconst39*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r11*x348))+(((-1.0)*gconst39*new_r01))))+IKsqr(((((-1.0)*new_r10*x348))+((gconst39*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((new_r11*x348))+(((-1.0)*gconst39*new_r01))), ((((-1.0)*new_r10*x348))+((gconst39*new_r00))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[10];
IkReal x349=IKsin(j5);
IkReal x350=IKcos(j5);
IkReal x351=((1.0)*new_r22);
IkReal x352=(gconst39*new_r10);
IkReal x353=(gconst39*new_r11);
IkReal x354=((1.0)*x350);
IkReal x355=(gconst39*x350);
IkReal x356=(gconst39*x349);
IkReal x357=x348;
IkReal x358=((1.0)*x357);
IkReal x359=(new_r22*x357);
IkReal x360=(x349*x357);
IkReal x361=(x350*x357);
evalcond[0]=(((gconst39*new_r01))+x349+(((-1.0)*new_r11*x358)));
evalcond[1]=((((-1.0)*x354))+((gconst39*new_r00))+(((-1.0)*new_r10*x358)));
evalcond[2]=((((-1.0)*x349*x351))+x352+((new_r00*x357)));
evalcond[3]=(((new_r01*x357))+x353+(((-1.0)*x350*x351)));
evalcond[4]=(x356+new_r01+(((-1.0)*x351*x361)));
evalcond[5]=(x361+(((-1.0)*x351*x356))+new_r10);
evalcond[6]=(((new_r22*x352))+(((-1.0)*x349))+((new_r00*x359)));
evalcond[7]=(((new_r01*x359))+((new_r22*x353))+(((-1.0)*x354)));
evalcond[8]=((((-1.0)*x349*x358))+(((-1.0)*x351*x355))+new_r11);
evalcond[9]=((((-1.0)*gconst39*x354))+new_r00+(((-1.0)*x351*x360)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x362=((1.0)*cj3*new_r01);
CheckValue<IkReal> x363=IKPowWithIntegerCheck(cj3,-1);
if(!x363.valid){
continue;
}
CheckValue<IkReal> x364=IKPowWithIntegerCheck(new_r22,-1);
if(!x364.valid){
continue;
}
if( IKabs(((((-1.0)*x362))+(((-1.0)*new_r11*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x363.value)*(x364.value)*(((((-1.0)*sj3*x362))+((new_r11*(cj3*cj3))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x362))+(((-1.0)*new_r11*sj3))))+IKsqr(((x363.value)*(x364.value)*(((((-1.0)*sj3*x362))+((new_r11*(cj3*cj3)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*x362))+(((-1.0)*new_r11*sj3))), ((x363.value)*(x364.value)*(((((-1.0)*sj3*x362))+((new_r11*(cj3*cj3)))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[10];
IkReal x365=IKsin(j5);
IkReal x366=IKcos(j5);
IkReal x367=((1.0)*cj3);
IkReal x368=((1.0)*sj3);
IkReal x369=(cj3*new_r10);
IkReal x370=(cj3*new_r11);
IkReal x371=((1.0)*x366);
IkReal x372=(new_r22*x366);
IkReal x373=(sj3*x365);
IkReal x374=(new_r22*x365);
evalcond[0]=(((new_r11*sj3))+x365+((cj3*new_r01)));
evalcond[1]=(((new_r10*sj3))+(((-1.0)*x371))+((cj3*new_r00)));
evalcond[2]=(((sj3*x372))+new_r01+((cj3*x365)));
evalcond[3]=((((-1.0)*x367*x372))+x373+new_r11);
evalcond[4]=((((-1.0)*x374))+(((-1.0)*new_r00*x368))+x369);
evalcond[5]=((((-1.0)*new_r22*x371))+x370+(((-1.0)*new_r01*x368)));
evalcond[6]=((((-1.0)*x366*x367))+new_r00+((new_r22*x373)));
evalcond[7]=((((-1.0)*x367*x374))+(((-1.0)*x366*x368))+new_r10);
evalcond[8]=(((new_r22*x369))+(((-1.0)*x365))+(((-1.0)*new_r00*new_r22*x368)));
evalcond[9]=((((-1.0)*x371))+(((-1.0)*new_r01*new_r22*x368))+((new_r22*x370)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x375=((1.0)*new_r01);
CheckValue<IkReal> x376=IKPowWithIntegerCheck(new_r22,-1);
if(!x376.valid){
continue;
}
if( IKabs(((((-1.0)*cj3*x375))+(((-1.0)*new_r11*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x376.value)*(((((-1.0)*sj3*x375))+((cj3*new_r11)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj3*x375))+(((-1.0)*new_r11*sj3))))+IKsqr(((x376.value)*(((((-1.0)*sj3*x375))+((cj3*new_r11))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*cj3*x375))+(((-1.0)*new_r11*sj3))), ((x376.value)*(((((-1.0)*sj3*x375))+((cj3*new_r11))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[10];
IkReal x377=IKsin(j5);
IkReal x378=IKcos(j5);
IkReal x379=((1.0)*cj3);
IkReal x380=((1.0)*sj3);
IkReal x381=(cj3*new_r10);
IkReal x382=(cj3*new_r11);
IkReal x383=((1.0)*x378);
IkReal x384=(new_r22*x378);
IkReal x385=(sj3*x377);
IkReal x386=(new_r22*x377);
evalcond[0]=(((new_r11*sj3))+x377+((cj3*new_r01)));
evalcond[1]=(((new_r10*sj3))+(((-1.0)*x383))+((cj3*new_r00)));
evalcond[2]=(new_r01+((cj3*x377))+((sj3*x384)));
evalcond[3]=((((-1.0)*x379*x384))+x385+new_r11);
evalcond[4]=((((-1.0)*new_r00*x380))+x381+(((-1.0)*x386)));
evalcond[5]=((((-1.0)*new_r01*x380))+x382+(((-1.0)*new_r22*x383)));
evalcond[6]=((((-1.0)*x378*x379))+((new_r22*x385))+new_r00);
evalcond[7]=((((-1.0)*x379*x386))+(((-1.0)*x378*x380))+new_r10);
evalcond[8]=((((-1.0)*x377))+(((-1.0)*new_r00*new_r22*x380))+((new_r22*x381)));
evalcond[9]=((((-1.0)*new_r01*new_r22*x380))+((new_r22*x382))+(((-1.0)*x383)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x387=cj3*cj3;
IkReal x388=new_r22*new_r22;
IkReal x389=(new_r22*sj3);
CheckValue<IkReal> x390=IKPowWithIntegerCheck(IKsign((((x387*x388))+(((-1.0)*x388))+(((-1.0)*x387)))),-1);
if(!x390.valid){
continue;
}
CheckValue<IkReal> x391 = IKatan2WithCheck(IkReal((((new_r00*x389))+((cj3*new_r01)))),IkReal((((new_r01*x389))+(((-1.0)*cj3*new_r00)))),IKFAST_ATAN2_MAGTHRESH);
if(!x391.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x390.value)))+(x391.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[10];
IkReal x392=IKsin(j5);
IkReal x393=IKcos(j5);
IkReal x394=((1.0)*cj3);
IkReal x395=((1.0)*sj3);
IkReal x396=(cj3*new_r10);
IkReal x397=(cj3*new_r11);
IkReal x398=((1.0)*x393);
IkReal x399=(new_r22*x393);
IkReal x400=(sj3*x392);
IkReal x401=(new_r22*x392);
evalcond[0]=(((new_r11*sj3))+x392+((cj3*new_r01)));
evalcond[1]=((((-1.0)*x398))+((new_r10*sj3))+((cj3*new_r00)));
evalcond[2]=(((sj3*x399))+((cj3*x392))+new_r01);
evalcond[3]=((((-1.0)*x394*x399))+x400+new_r11);
evalcond[4]=(x396+(((-1.0)*new_r00*x395))+(((-1.0)*x401)));
evalcond[5]=((((-1.0)*new_r01*x395))+(((-1.0)*new_r22*x398))+x397);
evalcond[6]=(((new_r22*x400))+new_r00+(((-1.0)*x393*x394)));
evalcond[7]=((((-1.0)*x394*x401))+new_r10+(((-1.0)*x393*x395)));
evalcond[8]=((((-1.0)*x392))+(((-1.0)*new_r00*new_r22*x395))+((new_r22*x396)));
evalcond[9]=((((-1.0)*x398))+(((-1.0)*new_r01*new_r22*x395))+((new_r22*x397)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x403=IKPowWithIntegerCheck(cj4,-1);
if(!x403.valid){
continue;
}
IkReal x402=x403.value;
CheckValue<IkReal> x404=IKPowWithIntegerCheck(new_r02,-1);
if(!x404.valid){
continue;
}
CheckValue<IkReal> x405=IKPowWithIntegerCheck(x402,-2);
if(!x405.valid){
continue;
}
if( IKabs((x402*(x404.value)*(((((-1.0)*(new_r12*new_r12)))+(x405.value))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r12*x402)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x402*(x404.value)*(((((-1.0)*(new_r12*new_r12)))+(x405.value)))))+IKsqr(((-1.0)*new_r12*x402))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((x402*(x404.value)*(((((-1.0)*(new_r12*new_r12)))+(x405.value)))), ((-1.0)*new_r12*x402));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x406=IKsin(j3);
IkReal x407=IKcos(j3);
IkReal x408=(cj4*x407);
IkReal x409=(new_r12*x407);
IkReal x410=(new_r02*x406);
IkReal x411=((1.0)*cj4*x406);
evalcond[0]=(x408+new_r12);
evalcond[1]=(new_r02+(((-1.0)*x411)));
evalcond[2]=(((new_r12*x406))+((new_r02*x407)));
evalcond[3]=(cj4+x409+(((-1.0)*x410)));
evalcond[4]=(((new_r20*sj4))+((new_r10*x408))+(((-1.0)*new_r00*x411)));
evalcond[5]=(((new_r11*x408))+((new_r21*sj4))+(((-1.0)*new_r01*x411)));
evalcond[6]=(((cj4*new_r22))+(((-1.0)*sj4*x409))+((sj4*x410)));
evalcond[7]=((1.0)+((new_r22*sj4))+((new_r12*x408))+(((-1.0)*cj4*x410)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5eval[3];
j5eval[0]=cj4;
j5eval[1]=IKsign(cj4);
j5eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
j5eval[0]=cj4;
j5eval[1]=sj3;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[3];
j5eval[0]=cj4;
j5eval[1]=sj3;
j5eval[2]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x412=((1.0)*cj3);
if( IKabs(((((-1.0)*new_r11*sj3))+(((-1.0)*new_r01*x412)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj3))+(((-1.0)*new_r11*x412)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*sj3))+(((-1.0)*new_r01*x412))))+IKsqr((((new_r01*sj3))+(((-1.0)*new_r11*x412))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*new_r11*sj3))+(((-1.0)*new_r01*x412))), (((new_r01*sj3))+(((-1.0)*new_r11*x412))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x413=IKsin(j5);
IkReal x414=IKcos(j5);
IkReal x415=((1.0)*sj3);
IkReal x416=(cj3*x413);
IkReal x417=((1.0)*x414);
IkReal x418=(x414*x415);
evalcond[0]=(((new_r11*sj3))+x413+((cj3*new_r01)));
evalcond[1]=(x413+((cj3*new_r10))+(((-1.0)*new_r00*x415)));
evalcond[2]=(x414+((cj3*new_r11))+(((-1.0)*new_r01*x415)));
evalcond[3]=(((new_r10*sj3))+((cj3*new_r00))+(((-1.0)*x417)));
evalcond[4]=(((sj3*x413))+new_r11+((cj3*x414)));
evalcond[5]=(x416+new_r01+(((-1.0)*x418)));
evalcond[6]=(x416+new_r10+(((-1.0)*x418)));
evalcond[7]=((((-1.0)*cj3*x417))+(((-1.0)*x413*x415))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x419=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj3*x419))+(((-1.0)*new_r11*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj3*new_r11))+(((-1.0)*sj3*x419)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj3*x419))+(((-1.0)*new_r11*sj3))))+IKsqr((((cj3*new_r11))+(((-1.0)*sj3*x419))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*cj3*x419))+(((-1.0)*new_r11*sj3))), (((cj3*new_r11))+(((-1.0)*sj3*x419))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x420=IKsin(j5);
IkReal x421=IKcos(j5);
IkReal x422=((1.0)*sj3);
IkReal x423=((1.0)*x421);
IkReal x424=(sj3*x420);
IkReal x425=((1.0)*x420);
IkReal x426=(cj3*x423);
evalcond[0]=(((new_r11*sj3))+x420+((cj3*new_r01)));
evalcond[1]=(((new_r10*sj3))+(((-1.0)*x423))+((cj3*new_r00)));
evalcond[2]=(((sj3*x421))+((cj3*x420))+new_r01);
evalcond[3]=((((-1.0)*x426))+x424+new_r11);
evalcond[4]=((((-1.0)*new_r00*x422))+(((-1.0)*x425))+((cj3*new_r10)));
evalcond[5]=((((-1.0)*x423))+((cj3*new_r11))+(((-1.0)*new_r01*x422)));
evalcond[6]=((((-1.0)*x426))+x424+new_r00);
evalcond[7]=((((-1.0)*x421*x422))+(((-1.0)*cj3*x425))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-1.0)*new_r01), new_r00);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x427=IKcos(j5);
IkReal x428=IKsin(j5);
IkReal x429=((1.0)*cj4);
IkReal x430=((1.0)*sj4);
IkReal x431=((1.0)*x427);
evalcond[0]=(x428+new_r01);
evalcond[1]=((((-1.0)*x431))+new_r00);
evalcond[2]=(((sj4*x427))+new_r11);
evalcond[3]=(((sj4*x428))+new_r10);
evalcond[4]=((((-1.0)*x428*x429))+new_r20);
evalcond[5]=((((-1.0)*x427*x429))+new_r21);
evalcond[6]=((((-1.0)*x428))+((cj4*new_r20))+(((-1.0)*new_r10*x430)));
evalcond[7]=((((-1.0)*x431))+((cj4*new_r21))+(((-1.0)*new_r11*x430)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(new_r01, ((-1.0)*new_r00));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x432=IKsin(j5);
IkReal x433=IKcos(j5);
IkReal x434=((1.0)*cj4);
IkReal x435=((1.0)*x433);
evalcond[0]=(x432+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*x432*x434))+new_r20);
evalcond[2]=((((-1.0)*x433*x434))+new_r21);
evalcond[3]=(new_r11+(((-1.0)*sj4*x435)));
evalcond[4]=((((-1.0)*x435))+(((-1.0)*new_r00)));
evalcond[5]=(((sj4*x432))+(((-1.0)*new_r10)));
evalcond[6]=((((-1.0)*x432))+((new_r10*sj4))+((cj4*new_r20)));
evalcond[7]=((((-1.0)*x435))+((new_r11*sj4))+((cj4*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(new_r20, new_r21);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x436=IKsin(j5);
IkReal x437=IKcos(j5);
IkReal x438=((1.0)*x437);
IkReal x439=((1.0)*x436);
evalcond[0]=((((-1.0)*x439))+new_r20);
evalcond[1]=((((-1.0)*x438))+new_r21);
evalcond[2]=(((sj3*x436))+new_r11);
evalcond[3]=((((-1.0)*new_r12*x439))+new_r01);
evalcond[4]=((((-1.0)*sj3*x438))+new_r10);
evalcond[5]=((((-1.0)*cj3*x438))+new_r00);
evalcond[6]=(((new_r11*sj3))+x436+((cj3*new_r01)));
evalcond[7]=((((-1.0)*x438))+((new_r10*sj3))+((cj3*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20))+IKsqr(((-1.0)*new_r21))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-1.0)*new_r20), ((-1.0)*new_r21));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x440=IKsin(j5);
IkReal x441=IKcos(j5);
IkReal x442=((1.0)*x441);
evalcond[0]=(x440+new_r20);
evalcond[1]=(x441+new_r21);
evalcond[2]=(((sj3*x440))+new_r11);
evalcond[3]=(((new_r12*x440))+new_r01);
evalcond[4]=((((-1.0)*sj3*x442))+new_r10);
evalcond[5]=((((-1.0)*cj3*x442))+new_r00);
evalcond[6]=(((new_r11*sj3))+x440+((cj3*new_r01)));
evalcond[7]=((((-1.0)*x442))+((new_r10*sj3))+((cj3*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j5eval[0]=1.0;
if( IKabs(j5eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j5]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=1.0;
op[1]=0;
op[2]=-1.0;
polyroots2(op,zeror,numroots);
IkReal j5array[2], cj5array[2], sj5array[2], tempj5array[1];
int numsolutions = 0;
for(int ij5 = 0; ij5 < numroots; ++ij5)
{
IkReal htj5 = zeror[ij5];
tempj5array[0]=((2.0)*(atan(htj5)));
for(int kj5 = 0; kj5 < 1; ++kj5)
{
j5array[numsolutions] = tempj5array[kj5];
if( j5array[numsolutions] > IKPI )
{
    j5array[numsolutions]-=IK2PI;
}
else if( j5array[numsolutions] < -IKPI )
{
    j5array[numsolutions]+=IK2PI;
}
sj5array[numsolutions] = IKsin(j5array[numsolutions]);
cj5array[numsolutions] = IKcos(j5array[numsolutions]);
numsolutions++;
}
}
bool j5valid[2]={true,true};
_nj5 = 2;
for(int ij5 = 0; ij5 < numsolutions; ++ij5)
    {
if( !j5valid[ij5] )
{
    continue;
}
    j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
htj5 = IKtan(j5/2);

_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < numsolutions; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x444=IKPowWithIntegerCheck(cj4,-1);
if(!x444.valid){
continue;
}
IkReal x443=x444.value;
CheckValue<IkReal> x445=IKPowWithIntegerCheck(sj3,-1);
if(!x445.valid){
continue;
}
CheckValue<IkReal> x446=IKPowWithIntegerCheck(sj4,-1);
if(!x446.valid){
continue;
}
if( IKabs((new_r20*x443)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x443*(x445.value)*(x446.value)*((((cj4*new_r01))+((cj3*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r20*x443))+IKsqr((x443*(x445.value)*(x446.value)*((((cj4*new_r01))+((cj3*new_r20))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((new_r20*x443), (x443*(x445.value)*(x446.value)*((((cj4*new_r01))+((cj3*new_r20))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x447=IKsin(j5);
IkReal x448=IKcos(j5);
IkReal x449=(cj3*sj4);
IkReal x450=(sj3*sj4);
IkReal x451=((1.0)*sj3);
IkReal x452=((1.0)*x448);
IkReal x453=((1.0)*x447);
evalcond[0]=((((-1.0)*cj4*x453))+new_r20);
evalcond[1]=((((-1.0)*cj4*x452))+new_r21);
evalcond[2]=(((new_r11*sj3))+x447+((cj3*new_r01)));
evalcond[3]=(((new_r10*sj3))+(((-1.0)*x452))+((cj3*new_r00)));
evalcond[4]=(((sj3*x447))+((x448*x449))+new_r11);
evalcond[5]=(((sj4*x447))+(((-1.0)*new_r00*x451))+((cj3*new_r10)));
evalcond[6]=(((sj4*x448))+(((-1.0)*new_r01*x451))+((cj3*new_r11)));
evalcond[7]=((((-1.0)*x450*x452))+((cj3*x447))+new_r01);
evalcond[8]=(((x447*x449))+new_r10+(((-1.0)*x448*x451)));
evalcond[9]=((((-1.0)*x450*x453))+new_r00+(((-1.0)*cj3*x452)));
evalcond[10]=(((new_r00*x450))+((cj4*new_r20))+(((-1.0)*new_r10*x449))+(((-1.0)*x453)));
evalcond[11]=(((new_r01*x450))+((cj4*new_r21))+(((-1.0)*new_r11*x449))+(((-1.0)*x452)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x455=IKPowWithIntegerCheck(cj4,-1);
if(!x455.valid){
continue;
}
IkReal x454=x455.value;
CheckValue<IkReal> x456=IKPowWithIntegerCheck(sj3,-1);
if(!x456.valid){
continue;
}
if( IKabs((x454*(x456.value)*(((((-1.0)*cj4*new_r11))+(((-1.0)*cj3*new_r21*sj4)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r21*x454)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x454*(x456.value)*(((((-1.0)*cj4*new_r11))+(((-1.0)*cj3*new_r21*sj4))))))+IKsqr((new_r21*x454))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((x454*(x456.value)*(((((-1.0)*cj4*new_r11))+(((-1.0)*cj3*new_r21*sj4))))), (new_r21*x454));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x457=IKsin(j5);
IkReal x458=IKcos(j5);
IkReal x459=(cj3*sj4);
IkReal x460=(sj3*sj4);
IkReal x461=((1.0)*sj3);
IkReal x462=((1.0)*x458);
IkReal x463=((1.0)*x457);
evalcond[0]=((((-1.0)*cj4*x463))+new_r20);
evalcond[1]=((((-1.0)*cj4*x462))+new_r21);
evalcond[2]=(((new_r11*sj3))+x457+((cj3*new_r01)));
evalcond[3]=(((new_r10*sj3))+(((-1.0)*x462))+((cj3*new_r00)));
evalcond[4]=(((sj3*x457))+new_r11+((x458*x459)));
evalcond[5]=(((sj4*x457))+(((-1.0)*new_r00*x461))+((cj3*new_r10)));
evalcond[6]=((((-1.0)*new_r01*x461))+((sj4*x458))+((cj3*new_r11)));
evalcond[7]=((((-1.0)*x460*x462))+((cj3*x457))+new_r01);
evalcond[8]=((((-1.0)*x458*x461))+new_r10+((x457*x459)));
evalcond[9]=((((-1.0)*x460*x463))+new_r00+(((-1.0)*cj3*x462)));
evalcond[10]=(((new_r00*x460))+(((-1.0)*new_r10*x459))+((cj4*new_r20))+(((-1.0)*x463)));
evalcond[11]=(((new_r01*x460))+((cj4*new_r21))+(((-1.0)*new_r11*x459))+(((-1.0)*x462)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x464=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x464.valid){
continue;
}
CheckValue<IkReal> x465 = IKatan2WithCheck(IkReal(new_r20),IkReal(new_r21),IKFAST_ATAN2_MAGTHRESH);
if(!x465.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x464.value)))+(x465.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x466=IKsin(j5);
IkReal x467=IKcos(j5);
IkReal x468=(cj3*sj4);
IkReal x469=(sj3*sj4);
IkReal x470=((1.0)*sj3);
IkReal x471=((1.0)*x467);
IkReal x472=((1.0)*x466);
evalcond[0]=((((-1.0)*cj4*x472))+new_r20);
evalcond[1]=((((-1.0)*cj4*x471))+new_r21);
evalcond[2]=(((new_r11*sj3))+x466+((cj3*new_r01)));
evalcond[3]=(((new_r10*sj3))+(((-1.0)*x471))+((cj3*new_r00)));
evalcond[4]=(((sj3*x466))+((x467*x468))+new_r11);
evalcond[5]=((((-1.0)*new_r00*x470))+((sj4*x466))+((cj3*new_r10)));
evalcond[6]=((((-1.0)*new_r01*x470))+((sj4*x467))+((cj3*new_r11)));
evalcond[7]=((((-1.0)*x469*x471))+((cj3*x466))+new_r01);
evalcond[8]=((((-1.0)*x467*x470))+((x466*x468))+new_r10);
evalcond[9]=((((-1.0)*x469*x472))+(((-1.0)*cj3*x471))+new_r00);
evalcond[10]=(((new_r00*x469))+((cj4*new_r20))+(((-1.0)*new_r10*x468))+(((-1.0)*x472)));
evalcond[11]=((((-1.0)*new_r11*x468))+((new_r01*x469))+((cj4*new_r21))+(((-1.0)*x471)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x473=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x473.valid){
continue;
}
CheckValue<IkReal> x474 = IKatan2WithCheck(IkReal(new_r02),IkReal(((-1.0)*new_r12)),IKFAST_ATAN2_MAGTHRESH);
if(!x474.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x473.value)))+(x474.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x475=IKsin(j3);
IkReal x476=IKcos(j3);
IkReal x477=(cj4*x476);
IkReal x478=(new_r12*x476);
IkReal x479=(new_r02*x475);
IkReal x480=((1.0)*cj4*x475);
evalcond[0]=(x477+new_r12);
evalcond[1]=((((-1.0)*x480))+new_r02);
evalcond[2]=(((new_r12*x475))+((new_r02*x476)));
evalcond[3]=(cj4+(((-1.0)*x479))+x478);
evalcond[4]=(((new_r20*sj4))+(((-1.0)*new_r00*x480))+((new_r10*x477)));
evalcond[5]=((((-1.0)*new_r01*x480))+((new_r11*x477))+((new_r21*sj4)));
evalcond[6]=(((sj4*x479))+((cj4*new_r22))+(((-1.0)*sj4*x478)));
evalcond[7]=((1.0)+((new_r12*x477))+(((-1.0)*cj4*x479))+((new_r22*sj4)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5eval[3];
j5eval[0]=cj4;
j5eval[1]=IKsign(cj4);
j5eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
j5eval[0]=cj4;
j5eval[1]=sj3;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[3];
j5eval[0]=cj4;
j5eval[1]=sj3;
j5eval[2]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x481=((1.0)*cj3);
if( IKabs(((((-1.0)*new_r01*x481))+(((-1.0)*new_r11*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r11*x481))+((new_r01*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r01*x481))+(((-1.0)*new_r11*sj3))))+IKsqr(((((-1.0)*new_r11*x481))+((new_r01*sj3))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*new_r01*x481))+(((-1.0)*new_r11*sj3))), ((((-1.0)*new_r11*x481))+((new_r01*sj3))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x482=IKsin(j5);
IkReal x483=IKcos(j5);
IkReal x484=((1.0)*sj3);
IkReal x485=(cj3*x482);
IkReal x486=((1.0)*x483);
IkReal x487=(x483*x484);
evalcond[0]=(((new_r11*sj3))+x482+((cj3*new_r01)));
evalcond[1]=((((-1.0)*new_r00*x484))+x482+((cj3*new_r10)));
evalcond[2]=((((-1.0)*new_r01*x484))+x483+((cj3*new_r11)));
evalcond[3]=(((new_r10*sj3))+(((-1.0)*x486))+((cj3*new_r00)));
evalcond[4]=(((cj3*x483))+new_r11+((sj3*x482)));
evalcond[5]=((((-1.0)*x487))+x485+new_r01);
evalcond[6]=((((-1.0)*x487))+x485+new_r10);
evalcond[7]=((((-1.0)*cj3*x486))+(((-1.0)*x482*x484))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x488=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj3*x488))+(((-1.0)*new_r11*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj3*x488))+((cj3*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj3*x488))+(((-1.0)*new_r11*sj3))))+IKsqr(((((-1.0)*sj3*x488))+((cj3*new_r11))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*cj3*x488))+(((-1.0)*new_r11*sj3))), ((((-1.0)*sj3*x488))+((cj3*new_r11))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x489=IKsin(j5);
IkReal x490=IKcos(j5);
IkReal x491=((1.0)*sj3);
IkReal x492=((1.0)*x490);
IkReal x493=(sj3*x489);
IkReal x494=((1.0)*x489);
IkReal x495=(cj3*x492);
evalcond[0]=(((new_r11*sj3))+x489+((cj3*new_r01)));
evalcond[1]=((((-1.0)*x492))+((new_r10*sj3))+((cj3*new_r00)));
evalcond[2]=(((cj3*x489))+((sj3*x490))+new_r01);
evalcond[3]=((((-1.0)*x495))+x493+new_r11);
evalcond[4]=((((-1.0)*new_r00*x491))+(((-1.0)*x494))+((cj3*new_r10)));
evalcond[5]=((((-1.0)*x492))+(((-1.0)*new_r01*x491))+((cj3*new_r11)));
evalcond[6]=((((-1.0)*x495))+x493+new_r00);
evalcond[7]=((((-1.0)*cj3*x494))+(((-1.0)*x490*x491))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-1.0)*new_r01), new_r00);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x496=IKcos(j5);
IkReal x497=IKsin(j5);
IkReal x498=((1.0)*cj4);
IkReal x499=((1.0)*sj4);
IkReal x500=((1.0)*x496);
evalcond[0]=(x497+new_r01);
evalcond[1]=((((-1.0)*x500))+new_r00);
evalcond[2]=(((sj4*x496))+new_r11);
evalcond[3]=(((sj4*x497))+new_r10);
evalcond[4]=((((-1.0)*x497*x498))+new_r20);
evalcond[5]=((((-1.0)*x496*x498))+new_r21);
evalcond[6]=((((-1.0)*new_r10*x499))+((cj4*new_r20))+(((-1.0)*x497)));
evalcond[7]=((((-1.0)*x500))+((cj4*new_r21))+(((-1.0)*new_r11*x499)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(new_r01, ((-1.0)*new_r00));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x501=IKsin(j5);
IkReal x502=IKcos(j5);
IkReal x503=((1.0)*cj4);
IkReal x504=((1.0)*x502);
evalcond[0]=(x501+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*x501*x503))+new_r20);
evalcond[2]=((((-1.0)*x502*x503))+new_r21);
evalcond[3]=((((-1.0)*sj4*x504))+new_r11);
evalcond[4]=((((-1.0)*x504))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*new_r10))+((sj4*x501)));
evalcond[6]=(((new_r10*sj4))+((cj4*new_r20))+(((-1.0)*x501)));
evalcond[7]=((((-1.0)*x504))+((new_r11*sj4))+((cj4*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(new_r20, new_r21);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x505=IKsin(j5);
IkReal x506=IKcos(j5);
IkReal x507=((1.0)*x506);
IkReal x508=((1.0)*x505);
evalcond[0]=((((-1.0)*x508))+new_r20);
evalcond[1]=((((-1.0)*x507))+new_r21);
evalcond[2]=(((sj3*x505))+new_r11);
evalcond[3]=(new_r01+(((-1.0)*new_r12*x508)));
evalcond[4]=((((-1.0)*sj3*x507))+new_r10);
evalcond[5]=((((-1.0)*cj3*x507))+new_r00);
evalcond[6]=(((new_r11*sj3))+x505+((cj3*new_r01)));
evalcond[7]=(((new_r10*sj3))+(((-1.0)*x507))+((cj3*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20))+IKsqr(((-1.0)*new_r21))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-1.0)*new_r20), ((-1.0)*new_r21));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x509=IKsin(j5);
IkReal x510=IKcos(j5);
IkReal x511=((1.0)*x510);
evalcond[0]=(x509+new_r20);
evalcond[1]=(x510+new_r21);
evalcond[2]=(((sj3*x509))+new_r11);
evalcond[3]=(((new_r12*x509))+new_r01);
evalcond[4]=((((-1.0)*sj3*x511))+new_r10);
evalcond[5]=((((-1.0)*cj3*x511))+new_r00);
evalcond[6]=(((new_r11*sj3))+x509+((cj3*new_r01)));
evalcond[7]=(((new_r10*sj3))+((cj3*new_r00))+(((-1.0)*x511)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j5eval[0]=1.0;
if( IKabs(j5eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j5]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=1.0;
op[1]=0;
op[2]=-1.0;
polyroots2(op,zeror,numroots);
IkReal j5array[2], cj5array[2], sj5array[2], tempj5array[1];
int numsolutions = 0;
for(int ij5 = 0; ij5 < numroots; ++ij5)
{
IkReal htj5 = zeror[ij5];
tempj5array[0]=((2.0)*(atan(htj5)));
for(int kj5 = 0; kj5 < 1; ++kj5)
{
j5array[numsolutions] = tempj5array[kj5];
if( j5array[numsolutions] > IKPI )
{
    j5array[numsolutions]-=IK2PI;
}
else if( j5array[numsolutions] < -IKPI )
{
    j5array[numsolutions]+=IK2PI;
}
sj5array[numsolutions] = IKsin(j5array[numsolutions]);
cj5array[numsolutions] = IKcos(j5array[numsolutions]);
numsolutions++;
}
}
bool j5valid[2]={true,true};
_nj5 = 2;
for(int ij5 = 0; ij5 < numsolutions; ++ij5)
    {
if( !j5valid[ij5] )
{
    continue;
}
    j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
htj5 = IKtan(j5/2);

_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < numsolutions; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x513=IKPowWithIntegerCheck(cj4,-1);
if(!x513.valid){
continue;
}
IkReal x512=x513.value;
CheckValue<IkReal> x514=IKPowWithIntegerCheck(sj3,-1);
if(!x514.valid){
continue;
}
CheckValue<IkReal> x515=IKPowWithIntegerCheck(sj4,-1);
if(!x515.valid){
continue;
}
if( IKabs((new_r20*x512)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x512*(x514.value)*(x515.value)*((((cj4*new_r01))+((cj3*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r20*x512))+IKsqr((x512*(x514.value)*(x515.value)*((((cj4*new_r01))+((cj3*new_r20))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((new_r20*x512), (x512*(x514.value)*(x515.value)*((((cj4*new_r01))+((cj3*new_r20))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x516=IKsin(j5);
IkReal x517=IKcos(j5);
IkReal x518=(cj3*sj4);
IkReal x519=(sj3*sj4);
IkReal x520=((1.0)*sj3);
IkReal x521=((1.0)*x517);
IkReal x522=((1.0)*x516);
evalcond[0]=(new_r20+(((-1.0)*cj4*x522)));
evalcond[1]=(new_r21+(((-1.0)*cj4*x521)));
evalcond[2]=(((new_r11*sj3))+x516+((cj3*new_r01)));
evalcond[3]=(((new_r10*sj3))+(((-1.0)*x521))+((cj3*new_r00)));
evalcond[4]=(((x517*x518))+((sj3*x516))+new_r11);
evalcond[5]=(((sj4*x516))+(((-1.0)*new_r00*x520))+((cj3*new_r10)));
evalcond[6]=(((sj4*x517))+(((-1.0)*new_r01*x520))+((cj3*new_r11)));
evalcond[7]=(((cj3*x516))+new_r01+(((-1.0)*x519*x521)));
evalcond[8]=((((-1.0)*x517*x520))+((x516*x518))+new_r10);
evalcond[9]=((((-1.0)*cj3*x521))+new_r00+(((-1.0)*x519*x522)));
evalcond[10]=(((new_r00*x519))+((cj4*new_r20))+(((-1.0)*x522))+(((-1.0)*new_r10*x518)));
evalcond[11]=(((new_r01*x519))+((cj4*new_r21))+(((-1.0)*x521))+(((-1.0)*new_r11*x518)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x524=IKPowWithIntegerCheck(cj4,-1);
if(!x524.valid){
continue;
}
IkReal x523=x524.value;
CheckValue<IkReal> x525=IKPowWithIntegerCheck(sj3,-1);
if(!x525.valid){
continue;
}
if( IKabs((x523*(x525.value)*(((((-1.0)*cj4*new_r11))+(((-1.0)*cj3*new_r21*sj4)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r21*x523)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x523*(x525.value)*(((((-1.0)*cj4*new_r11))+(((-1.0)*cj3*new_r21*sj4))))))+IKsqr((new_r21*x523))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((x523*(x525.value)*(((((-1.0)*cj4*new_r11))+(((-1.0)*cj3*new_r21*sj4))))), (new_r21*x523));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x526=IKsin(j5);
IkReal x527=IKcos(j5);
IkReal x528=(cj3*sj4);
IkReal x529=(sj3*sj4);
IkReal x530=((1.0)*sj3);
IkReal x531=((1.0)*x527);
IkReal x532=((1.0)*x526);
evalcond[0]=(new_r20+(((-1.0)*cj4*x532)));
evalcond[1]=(new_r21+(((-1.0)*cj4*x531)));
evalcond[2]=(((new_r11*sj3))+x526+((cj3*new_r01)));
evalcond[3]=(((new_r10*sj3))+(((-1.0)*x531))+((cj3*new_r00)));
evalcond[4]=(((sj3*x526))+new_r11+((x527*x528)));
evalcond[5]=((((-1.0)*new_r00*x530))+((cj3*new_r10))+((sj4*x526)));
evalcond[6]=((((-1.0)*new_r01*x530))+((cj3*new_r11))+((sj4*x527)));
evalcond[7]=((((-1.0)*x529*x531))+new_r01+((cj3*x526)));
evalcond[8]=((((-1.0)*x527*x530))+((x526*x528))+new_r10);
evalcond[9]=((((-1.0)*cj3*x531))+(((-1.0)*x529*x532))+new_r00);
evalcond[10]=(((cj4*new_r20))+(((-1.0)*x532))+(((-1.0)*new_r10*x528))+((new_r00*x529)));
evalcond[11]=(((new_r01*x529))+((cj4*new_r21))+(((-1.0)*x531))+(((-1.0)*new_r11*x528)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x533=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x533.valid){
continue;
}
CheckValue<IkReal> x534 = IKatan2WithCheck(IkReal(new_r20),IkReal(new_r21),IKFAST_ATAN2_MAGTHRESH);
if(!x534.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x533.value)))+(x534.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x535=IKsin(j5);
IkReal x536=IKcos(j5);
IkReal x537=(cj3*sj4);
IkReal x538=(sj3*sj4);
IkReal x539=((1.0)*sj3);
IkReal x540=((1.0)*x536);
IkReal x541=((1.0)*x535);
evalcond[0]=(new_r20+(((-1.0)*cj4*x541)));
evalcond[1]=(new_r21+(((-1.0)*cj4*x540)));
evalcond[2]=(((new_r11*sj3))+x535+((cj3*new_r01)));
evalcond[3]=(((new_r10*sj3))+(((-1.0)*x540))+((cj3*new_r00)));
evalcond[4]=(((sj3*x535))+((x536*x537))+new_r11);
evalcond[5]=((((-1.0)*new_r00*x539))+((cj3*new_r10))+((sj4*x535)));
evalcond[6]=((((-1.0)*new_r01*x539))+((cj3*new_r11))+((sj4*x536)));
evalcond[7]=((((-1.0)*x538*x540))+new_r01+((cj3*x535)));
evalcond[8]=(((x535*x537))+new_r10+(((-1.0)*x536*x539)));
evalcond[9]=((((-1.0)*cj3*x540))+(((-1.0)*x538*x541))+new_r00);
evalcond[10]=(((cj4*new_r20))+(((-1.0)*x541))+(((-1.0)*new_r10*x537))+((new_r00*x538)));
evalcond[11]=(((new_r01*x538))+((cj4*new_r21))+(((-1.0)*x540))+(((-1.0)*new_r11*x537)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x542=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x542.valid){
continue;
}
CheckValue<IkReal> x543 = IKatan2WithCheck(IkReal(new_r20),IkReal(new_r21),IKFAST_ATAN2_MAGTHRESH);
if(!x543.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x542.value)))+(x543.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x544=((1.0)*cj4);
evalcond[0]=((((-1.0)*x544*(IKsin(j5))))+new_r20);
evalcond[1]=((((-1.0)*x544*(IKcos(j5))))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[3];
j3eval[0]=cj4;
j3eval[1]=IKsign(cj4);
j3eval[2]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
j3eval[0]=cj4;
j3eval[1]=new_r11;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
IkReal x545=((1.0)*sj5);
IkReal x546=(((new_r10*new_r11))+((new_r00*new_r01)));
j3eval[0]=x546;
j3eval[1]=IKsign(x546);
j3eval[2]=((IKabs((((new_r01*sj5))+(((-1.0)*new_r10*x545)))))+(IKabs(((((-1.0)*new_r00*x545))+(((-1.0)*new_r11*x545))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
IkReal x547=((1.0)*sj5);
IkReal x548=((new_r01*new_r01)+(new_r11*new_r11));
j3eval[0]=x548;
j3eval[1]=((IKabs(((((-1.0)*new_r01*x547))+(((-1.0)*cj5*new_r11)))))+(IKabs((((cj5*new_r01))+(((-1.0)*new_r11*x547))))));
j3eval[2]=IKsign(x548);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
IkReal x549=(((new_r11*sj5))+((cj5*new_r01)));
j3eval[0]=x549;
j3eval[1]=IKsign(x549);
j3eval[2]=((IKabs(((((-1.0)*cj5*sj5))+(((-1.0)*new_r01*new_r11)))))+(IKabs(((-1.0)+(new_r01*new_r01)+(cj5*cj5)))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x551 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x551)==0){
continue;
}
IkReal x550=pow(x551,-0.5);
CheckValue<IkReal> x552 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x552.valid){
continue;
}
IkReal gconst32=((-1.0)*(x552.value));
IkReal gconst33=((-1.0)*new_r01*x550);
IkReal gconst34=(new_r11*x550);
CheckValue<IkReal> x553 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x553.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x553.value)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
CheckValue<IkReal> x556 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x556.valid){
continue;
}
IkReal x554=((-1.0)*(x556.value));
IkReal x555=x550;
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x554;
IkReal gconst32=x554;
IkReal gconst33=((-1.0)*new_r01*x555);
IkReal gconst34=(new_r11*x555);
IkReal x557=new_r01*new_r01;
IkReal x558=(new_r00*new_r01);
IkReal x559=(((new_r10*new_r11))+x558);
IkReal x560=x550;
IkReal x561=(new_r01*x560);
j3eval[0]=x559;
j3eval[1]=IKsign(x559);
j3eval[2]=((IKabs((((x558*x560))+((new_r11*x561)))))+(IKabs((((new_r10*x561))+(((-1.0)*x557*x560))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
CheckValue<IkReal> x564 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x564.valid){
continue;
}
IkReal x562=((-1.0)*(x564.value));
IkReal x563=x550;
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x562;
IkReal gconst32=x562;
IkReal gconst33=((-1.0)*new_r01*x563);
IkReal gconst34=(new_r11*x563);
IkReal x565=((new_r01*new_r01)+(new_r11*new_r11));
j3eval[0]=x565;
j3eval[1]=IKsign(x565);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x568 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x568.valid){
continue;
}
IkReal x566=((-1.0)*(x568.value));
IkReal x567=x550;
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x566;
IkReal gconst32=x566;
IkReal gconst33=((-1.0)*new_r01*x567);
IkReal gconst34=(new_r11*x567);
IkReal x569=new_r01*new_r01;
IkReal x570=new_r11*new_r11;
IkReal x571=((1.0)*x569);
CheckValue<IkReal> x577=IKPowWithIntegerCheck((x570+x569),-1);
if(!x577.valid){
continue;
}
IkReal x572=x577.value;
CheckValue<IkReal> x578=IKPowWithIntegerCheck(((((-1.0)*x570))+(((-1.0)*x571))),-1);
if(!x578.valid){
continue;
}
IkReal x573=x578.value;
IkReal x574=((1.0)*x573);
IkReal x575=(new_r11*x574);
IkReal x576=(new_r01*x574);
j3eval[0]=((IKabs(((((-1.0)*x575*(new_r01*new_r01*new_r01)))+(((-1.0)*new_r01*x575*(new_r11*new_r11)))+(((-1.0)*new_r01*x575)))))+(IKabs(((((-1.0)*x571*x572))+((x572*(x570*x570)))+((x569*x570*x572))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
CheckValue<IkReal> x580 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x580.valid){
continue;
}
IkReal x579=((-1.0)*(x580.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x579;
new_r11=0;
new_r00=0;
IkReal gconst32=x579;
IkReal x581 = new_r01*new_r01;
if(IKabs(x581)==0){
continue;
}
IkReal gconst33=((-1.0)*new_r01*(pow(x581,-0.5)));
IkReal gconst34=0;
j3eval[0]=new_r01;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x583 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x583.valid){
continue;
}
IkReal x582=((-1.0)*(x583.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x582;
new_r11=0;
new_r00=0;
IkReal gconst32=x582;
IkReal x584 = new_r01*new_r01;
if(IKabs(x584)==0){
continue;
}
IkReal gconst33=((-1.0)*new_r01*(pow(x584,-0.5)));
IkReal gconst34=0;
j3eval[0]=new_r10;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x585=IKPowWithIntegerCheck(gconst33,-1);
if(!x585.valid){
continue;
}
cj3array[0]=((-1.0)*new_r01*(x585.value));
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x586=IKsin(j3);
IkReal x587=IKcos(j3);
evalcond[0]=(new_r10*x586);
evalcond[1]=(gconst33*x586);
evalcond[2]=((-1.0)*new_r01*x586);
evalcond[3]=(gconst33+((new_r01*x587)));
evalcond[4]=(gconst33+((new_r10*x587)));
evalcond[5]=(((gconst33*x587))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x588=IKPowWithIntegerCheck(new_r10,-1);
if(!x588.valid){
continue;
}
cj3array[0]=((-1.0)*gconst33*(x588.value));
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x589=IKsin(j3);
IkReal x590=IKcos(j3);
IkReal x591=(gconst33*x590);
evalcond[0]=(new_r10*x589);
evalcond[1]=(gconst33*x589);
evalcond[2]=((-1.0)*new_r01*x589);
evalcond[3]=(gconst33+((new_r01*x590)));
evalcond[4]=(x591+new_r01);
evalcond[5]=(x591+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x592=IKPowWithIntegerCheck(new_r01,-1);
if(!x592.valid){
continue;
}
cj3array[0]=((-1.0)*gconst33*(x592.value));
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x593=IKsin(j3);
IkReal x594=IKcos(j3);
IkReal x595=(gconst33*x594);
evalcond[0]=(new_r10*x593);
evalcond[1]=(gconst33*x593);
evalcond[2]=((-1.0)*new_r01*x593);
evalcond[3]=(((new_r10*x594))+gconst33);
evalcond[4]=(x595+new_r01);
evalcond[5]=(x595+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst33;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
CheckValue<IkReal> x597 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x597.valid){
continue;
}
IkReal x596=((-1.0)*(x597.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x596;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst32=x596;
IkReal gconst33=((-1.0)*new_r01);
IkReal gconst34=new_r11;
j3eval[0]=-1.0;
j3eval[1]=-1.0;
j3eval[2]=((IKabs(new_r01*new_r01))+(IKabs((new_r01*new_r11))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
CheckValue<IkReal> x599 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x599.valid){
continue;
}
IkReal x598=((-1.0)*(x599.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x598;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst32=x598;
IkReal gconst33=((-1.0)*new_r01);
IkReal gconst34=new_r11;
j3eval[0]=-1.0;
j3eval[1]=-1.0;
j3eval[2]=((IKabs((new_r01*new_r11)))+(IKabs(((1.0)+(((-1.0)*(new_r01*new_r01)))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
CheckValue<IkReal> x601 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x601.valid){
continue;
}
IkReal x600=((-1.0)*(x601.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x600;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst32=x600;
IkReal gconst33=((-1.0)*new_r01);
IkReal gconst34=new_r11;
j3eval[0]=1.0;
j3eval[1]=((((0.5)*(IKabs(((-1.0)+(((2.0)*(new_r01*new_r01))))))))+(IKabs((new_r01*new_r11))));
j3eval[2]=1.0;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x602=((1.0)*new_r11);
CheckValue<IkReal> x603=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x603.valid){
continue;
}
CheckValue<IkReal> x604 = IKatan2WithCheck(IkReal(((((-1.0)*gconst33*x602))+((gconst34*new_r01)))),IkReal(((((-1.0)*gconst34*x602))+(((-1.0)*gconst33*new_r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x604.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x603.value)))+(x604.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x605=IKsin(j3);
IkReal x606=IKcos(j3);
IkReal x607=(gconst33*x606);
IkReal x608=((1.0)*x605);
IkReal x609=(gconst34*x606);
IkReal x610=(gconst34*x608);
evalcond[0]=(gconst33+((new_r11*x605))+((new_r01*x606)));
evalcond[1]=(x609+((gconst33*x605))+new_r11);
evalcond[2]=((((-1.0)*x610))+x607);
evalcond[3]=(gconst34+((new_r11*x606))+(((-1.0)*new_r01*x608)));
evalcond[4]=((((-1.0)*x610))+x607+new_r01);
evalcond[5]=((((-1.0)*x609))+(((-1.0)*gconst33*x608)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x611=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst33*gconst33)))+(((-1.0)*(gconst34*gconst34))))),-1);
if(!x611.valid){
continue;
}
CheckValue<IkReal> x612 = IKatan2WithCheck(IkReal((gconst33*new_r11)),IkReal((gconst34*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x612.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x611.value)))+(x612.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x613=IKsin(j3);
IkReal x614=IKcos(j3);
IkReal x615=(gconst33*x614);
IkReal x616=((1.0)*x613);
IkReal x617=(gconst34*x614);
IkReal x618=(gconst34*x616);
evalcond[0]=(gconst33+((new_r11*x613))+((new_r01*x614)));
evalcond[1]=(x617+new_r11+((gconst33*x613)));
evalcond[2]=((((-1.0)*x618))+x615);
evalcond[3]=(gconst34+((new_r11*x614))+(((-1.0)*new_r01*x616)));
evalcond[4]=((((-1.0)*x618))+x615+new_r01);
evalcond[5]=((((-1.0)*x617))+(((-1.0)*gconst33*x616)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x619=IKPowWithIntegerCheck(IKsign((((gconst33*new_r01))+(((-1.0)*gconst34*new_r11)))),-1);
if(!x619.valid){
continue;
}
CheckValue<IkReal> x620 = IKatan2WithCheck(IkReal((gconst33*gconst34)),IkReal(((-1.0)*(gconst33*gconst33))),IKFAST_ATAN2_MAGTHRESH);
if(!x620.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x619.value)))+(x620.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x621=IKsin(j3);
IkReal x622=IKcos(j3);
IkReal x623=(gconst33*x622);
IkReal x624=((1.0)*x621);
IkReal x625=(gconst34*x622);
IkReal x626=(gconst34*x624);
evalcond[0]=(gconst33+((new_r01*x622))+((new_r11*x621)));
evalcond[1]=(((gconst33*x621))+x625+new_r11);
evalcond[2]=((((-1.0)*x626))+x623);
evalcond[3]=((((-1.0)*new_r01*x624))+gconst34+((new_r11*x622)));
evalcond[4]=((((-1.0)*x626))+x623+new_r01);
evalcond[5]=((((-1.0)*gconst33*x624))+(((-1.0)*x625)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x627=IKPowWithIntegerCheck(gconst34,-1);
if(!x627.valid){
continue;
}
cj3array[0]=(new_r00*(x627.value));
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x628=IKsin(j3);
IkReal x629=IKcos(j3);
IkReal x630=((-1.0)*x628);
evalcond[0]=(new_r11*x628);
evalcond[1]=(new_r00*x630);
evalcond[2]=(gconst34*x630);
evalcond[3]=(new_r11+((gconst34*x629)));
evalcond[4]=(gconst34+((new_r11*x629)));
evalcond[5]=(((new_r00*x629))+(((-1.0)*gconst34)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
CheckValue<IkReal> x632 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x632.valid){
continue;
}
IkReal x631=((-1.0)*(x632.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x631;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst32=x631;
IkReal gconst33=0;
IkReal x633 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x633)==0){
continue;
}
IkReal gconst34=(new_r11*(pow(x633,-0.5)));
j3eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x635 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x635.valid){
continue;
}
IkReal x634=((-1.0)*(x635.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x634;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst32=x634;
IkReal gconst33=0;
IkReal x636 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x636)==0){
continue;
}
IkReal gconst34=(new_r11*(pow(x636,-0.5)));
j3eval[0]=new_r11;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x638 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x638.valid){
continue;
}
IkReal x637=((-1.0)*(x638.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x637;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst32=x637;
IkReal gconst33=0;
IkReal x639 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x639)==0){
continue;
}
IkReal gconst34=(new_r11*(pow(x639,-0.5)));
j3eval[0]=new_r10;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x640=IKPowWithIntegerCheck(new_r10,-1);
if(!x640.valid){
continue;
}
CheckValue<IkReal> x641=IKPowWithIntegerCheck(gconst34,-1);
if(!x641.valid){
continue;
}
if( IKabs((gconst34*(x640.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11*(x641.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst34*(x640.value)))+IKsqr(((-1.0)*new_r11*(x641.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((gconst34*(x640.value)), ((-1.0)*new_r11*(x641.value)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x642=IKsin(j3);
IkReal x643=IKcos(j3);
IkReal x644=((1.0)*gconst34);
IkReal x645=(gconst34*x643);
evalcond[0]=(new_r11*x642);
evalcond[1]=(new_r10*x643);
evalcond[2]=((-1.0)*gconst34*x642);
evalcond[3]=((-1.0)*x645);
evalcond[4]=(x645+new_r11);
evalcond[5]=(gconst34+((new_r11*x643)));
evalcond[6]=((((-1.0)*x642*x644))+new_r10);
evalcond[7]=((((-1.0)*x644))+((new_r10*x642)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x646=IKPowWithIntegerCheck(gconst34,-1);
if(!x646.valid){
continue;
}
CheckValue<IkReal> x647=IKPowWithIntegerCheck(new_r11,-1);
if(!x647.valid){
continue;
}
if( IKabs((new_r10*(x646.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst34*(x647.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x646.value)))+IKsqr(((-1.0)*gconst34*(x647.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((new_r10*(x646.value)), ((-1.0)*gconst34*(x647.value)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x648=IKsin(j3);
IkReal x649=IKcos(j3);
IkReal x650=((1.0)*gconst34);
IkReal x651=(gconst34*x649);
evalcond[0]=(new_r11*x648);
evalcond[1]=(new_r10*x649);
evalcond[2]=((-1.0)*gconst34*x648);
evalcond[3]=((-1.0)*x651);
evalcond[4]=(x651+new_r11);
evalcond[5]=(gconst34+((new_r11*x649)));
evalcond[6]=(new_r10+(((-1.0)*x648*x650)));
evalcond[7]=((((-1.0)*x650))+((new_r10*x648)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x652 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x652.valid){
continue;
}
CheckValue<IkReal> x653=IKPowWithIntegerCheck(IKsign(gconst34),-1);
if(!x653.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x652.value)+(((1.5707963267949)*(x653.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x654=IKsin(j3);
IkReal x655=IKcos(j3);
IkReal x656=((1.0)*gconst34);
IkReal x657=(gconst34*x655);
evalcond[0]=(new_r11*x654);
evalcond[1]=(new_r10*x655);
evalcond[2]=((-1.0)*gconst34*x654);
evalcond[3]=((-1.0)*x657);
evalcond[4]=(x657+new_r11);
evalcond[5]=(gconst34+((new_r11*x655)));
evalcond[6]=(new_r10+(((-1.0)*x654*x656)));
evalcond[7]=((((-1.0)*x656))+((new_r10*x654)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
CheckValue<IkReal> x659 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x659.valid){
continue;
}
IkReal x658=((-1.0)*(x659.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x658;
new_r01=0;
IkReal gconst32=x658;
IkReal gconst33=0;
IkReal x660 = new_r11*new_r11;
if(IKabs(x660)==0){
continue;
}
IkReal gconst34=(new_r11*(pow(x660,-0.5)));
j3eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x662 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x662.valid){
continue;
}
IkReal x661=((-1.0)*(x662.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x661;
new_r01=0;
IkReal gconst32=x661;
IkReal gconst33=0;
IkReal x663 = new_r11*new_r11;
if(IKabs(x663)==0){
continue;
}
IkReal gconst34=(new_r11*(pow(x663,-0.5)));
j3eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x665 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x665.valid){
continue;
}
IkReal x664=((-1.0)*(x665.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x664;
new_r01=0;
IkReal gconst32=x664;
IkReal gconst33=0;
IkReal x666 = new_r11*new_r11;
if(IKabs(x666)==0){
continue;
}
IkReal gconst34=(new_r11*(pow(x666,-0.5)));
j3eval[0]=new_r11;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x667=IKPowWithIntegerCheck(gconst34,-1);
if(!x667.valid){
continue;
}
CheckValue<IkReal> x668=IKPowWithIntegerCheck(new_r11,-1);
if(!x668.valid){
continue;
}
if( IKabs((new_r10*(x667.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst34*(x668.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x667.value)))+IKsqr(((-1.0)*gconst34*(x668.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((new_r10*(x667.value)), ((-1.0)*gconst34*(x668.value)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x669=IKsin(j3);
IkReal x670=IKcos(j3);
IkReal x671=((1.0)*gconst34);
evalcond[0]=(new_r11*x669);
evalcond[1]=((-1.0)*gconst34*x669);
evalcond[2]=(((gconst34*x670))+new_r11);
evalcond[3]=(((new_r11*x670))+gconst34);
evalcond[4]=((((-1.0)*x669*x671))+new_r10);
evalcond[5]=((((-1.0)*x670*x671))+new_r00);
evalcond[6]=(((new_r10*x670))+(((-1.0)*new_r00*x669)));
evalcond[7]=(((new_r00*x670))+((new_r10*x669))+(((-1.0)*x671)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x672 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x672.valid){
continue;
}
CheckValue<IkReal> x673=IKPowWithIntegerCheck(IKsign(gconst34),-1);
if(!x673.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x672.value)+(((1.5707963267949)*(x673.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x674=IKsin(j3);
IkReal x675=IKcos(j3);
IkReal x676=((1.0)*gconst34);
evalcond[0]=(new_r11*x674);
evalcond[1]=((-1.0)*gconst34*x674);
evalcond[2]=(((gconst34*x675))+new_r11);
evalcond[3]=(((new_r11*x675))+gconst34);
evalcond[4]=((((-1.0)*x674*x676))+new_r10);
evalcond[5]=((((-1.0)*x675*x676))+new_r00);
evalcond[6]=(((new_r10*x675))+(((-1.0)*new_r00*x674)));
evalcond[7]=(((new_r00*x675))+((new_r10*x674))+(((-1.0)*x676)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x677 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x677.valid){
continue;
}
CheckValue<IkReal> x678=IKPowWithIntegerCheck(IKsign(gconst34),-1);
if(!x678.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x677.value)+(((1.5707963267949)*(x678.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x679=IKsin(j3);
IkReal x680=IKcos(j3);
IkReal x681=((1.0)*gconst34);
evalcond[0]=(new_r11*x679);
evalcond[1]=((-1.0)*gconst34*x679);
evalcond[2]=(((gconst34*x680))+new_r11);
evalcond[3]=(gconst34+((new_r11*x680)));
evalcond[4]=((((-1.0)*x679*x681))+new_r10);
evalcond[5]=((((-1.0)*x680*x681))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x679))+((new_r10*x680)));
evalcond[7]=(((new_r10*x679))+(((-1.0)*x681))+((new_r00*x680)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x682=((1.0)*new_r11);
CheckValue<IkReal> x683=IKPowWithIntegerCheck(IKsign((((gconst33*new_r01))+(((-1.0)*gconst34*x682)))),-1);
if(!x683.valid){
continue;
}
CheckValue<IkReal> x684 = IKatan2WithCheck(IkReal(((((-1.0)*new_r01*x682))+((gconst33*gconst34)))),IkReal(((((-1.0)*(gconst33*gconst33)))+(new_r11*new_r11))),IKFAST_ATAN2_MAGTHRESH);
if(!x684.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x683.value)))+(x684.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x685=IKsin(j3);
IkReal x686=IKcos(j3);
IkReal x687=(gconst33*x686);
IkReal x688=((1.0)*x685);
IkReal x689=(gconst34*x686);
IkReal x690=(gconst34*x688);
evalcond[0]=(gconst33+((new_r01*x686))+((new_r11*x685)));
evalcond[1]=(((gconst33*x685))+x689+new_r11);
evalcond[2]=(gconst33+((new_r10*x686))+(((-1.0)*new_r00*x688)));
evalcond[3]=((((-1.0)*new_r01*x688))+gconst34+((new_r11*x686)));
evalcond[4]=(x687+(((-1.0)*x690))+new_r01);
evalcond[5]=(x687+(((-1.0)*x690))+new_r10);
evalcond[6]=(((new_r00*x686))+((new_r10*x685))+(((-1.0)*gconst34)));
evalcond[7]=((((-1.0)*gconst33*x688))+new_r00+(((-1.0)*x689)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x691=((1.0)*new_r11);
CheckValue<IkReal> x692 = IKatan2WithCheck(IkReal(((((-1.0)*gconst33*x691))+((gconst34*new_r01)))),IkReal(((((-1.0)*gconst33*new_r01))+(((-1.0)*gconst34*x691)))),IKFAST_ATAN2_MAGTHRESH);
if(!x692.valid){
continue;
}
CheckValue<IkReal> x693=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x693.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x692.value)+(((1.5707963267949)*(x693.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x694=IKsin(j3);
IkReal x695=IKcos(j3);
IkReal x696=(gconst33*x695);
IkReal x697=((1.0)*x694);
IkReal x698=(gconst34*x695);
IkReal x699=(gconst34*x697);
evalcond[0]=(gconst33+((new_r11*x694))+((new_r01*x695)));
evalcond[1]=(x698+((gconst33*x694))+new_r11);
evalcond[2]=(gconst33+((new_r10*x695))+(((-1.0)*new_r00*x697)));
evalcond[3]=((((-1.0)*new_r01*x697))+gconst34+((new_r11*x695)));
evalcond[4]=(x696+(((-1.0)*x699))+new_r01);
evalcond[5]=(x696+(((-1.0)*x699))+new_r10);
evalcond[6]=(((new_r10*x694))+((new_r00*x695))+(((-1.0)*gconst34)));
evalcond[7]=((((-1.0)*gconst33*x697))+new_r00+(((-1.0)*x698)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x700=((1.0)*gconst33);
CheckValue<IkReal> x701 = IKatan2WithCheck(IkReal((((gconst33*new_r01))+(((-1.0)*new_r10*x700)))),IkReal(((((-1.0)*new_r11*x700))+(((-1.0)*new_r00*x700)))),IKFAST_ATAN2_MAGTHRESH);
if(!x701.valid){
continue;
}
CheckValue<IkReal> x702=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x702.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x701.value)+(((1.5707963267949)*(x702.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x703=IKsin(j3);
IkReal x704=IKcos(j3);
IkReal x705=(gconst33*x704);
IkReal x706=((1.0)*x703);
IkReal x707=(gconst34*x704);
IkReal x708=(gconst34*x706);
evalcond[0]=(((new_r01*x704))+gconst33+((new_r11*x703)));
evalcond[1]=(((gconst33*x703))+x707+new_r11);
evalcond[2]=(gconst33+((new_r10*x704))+(((-1.0)*new_r00*x706)));
evalcond[3]=(gconst34+((new_r11*x704))+(((-1.0)*new_r01*x706)));
evalcond[4]=((((-1.0)*x708))+x705+new_r01);
evalcond[5]=((((-1.0)*x708))+x705+new_r10);
evalcond[6]=(((new_r00*x704))+((new_r10*x703))+(((-1.0)*gconst34)));
evalcond[7]=((((-1.0)*x707))+(((-1.0)*gconst33*x706))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x710 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x710)==0){
continue;
}
IkReal x709=pow(x710,-0.5);
CheckValue<IkReal> x711 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x711.valid){
continue;
}
IkReal gconst35=((3.14159265358979)+(((-1.0)*(x711.value))));
IkReal gconst36=((1.0)*new_r01*x709);
IkReal gconst37=((-1.0)*new_r11*x709);
CheckValue<IkReal> x712 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x712.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x712.value)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
CheckValue<IkReal> x715 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x715.valid){
continue;
}
IkReal x713=((1.0)*(x715.value));
IkReal x714=x709;
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x713)));
IkReal gconst35=((3.14159265358979)+(((-1.0)*x713)));
IkReal gconst36=((1.0)*new_r01*x714);
IkReal gconst37=((-1.0)*new_r11*x714);
IkReal x716=new_r01*new_r01;
IkReal x717=(((new_r10*new_r11))+((new_r00*new_r01)));
IkReal x718=x709;
IkReal x719=((1.0)*new_r01*x718);
j3eval[0]=x717;
j3eval[1]=((IKabs((((x716*x718))+(((-1.0)*new_r10*x719)))))+(IKabs(((((-1.0)*new_r11*x719))+(((-1.0)*new_r00*x719))))));
j3eval[2]=IKsign(x717);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
CheckValue<IkReal> x722 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x722.valid){
continue;
}
IkReal x720=((1.0)*(x722.value));
IkReal x721=x709;
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x720)));
IkReal gconst35=((3.14159265358979)+(((-1.0)*x720)));
IkReal gconst36=((1.0)*new_r01*x721);
IkReal gconst37=((-1.0)*new_r11*x721);
IkReal x723=((new_r01*new_r01)+(new_r11*new_r11));
j3eval[0]=x723;
j3eval[1]=IKsign(x723);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x726 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x726.valid){
continue;
}
IkReal x724=((1.0)*(x726.value));
IkReal x725=x709;
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x724)));
IkReal gconst35=((3.14159265358979)+(((-1.0)*x724)));
IkReal gconst36=((1.0)*new_r01*x725);
IkReal gconst37=((-1.0)*new_r11*x725);
IkReal x727=new_r01*new_r01;
IkReal x728=new_r11*new_r11;
IkReal x729=((1.0)*x727);
CheckValue<IkReal> x735=IKPowWithIntegerCheck((x727+x728),-1);
if(!x735.valid){
continue;
}
IkReal x730=x735.value;
CheckValue<IkReal> x736=IKPowWithIntegerCheck(((((-1.0)*x729))+(((-1.0)*x728))),-1);
if(!x736.valid){
continue;
}
IkReal x731=x736.value;
IkReal x732=((1.0)*x731);
IkReal x733=(new_r11*x732);
IkReal x734=(new_r01*x732);
j3eval[0]=((IKabs((((x727*x728*x730))+((x730*(x728*x728)))+(((-1.0)*x729*x730)))))+(IKabs(((((-1.0)*x733*(new_r01*new_r01*new_r01)))+(((-1.0)*new_r01*x733*(new_r11*new_r11)))+(((-1.0)*new_r01*x733))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
CheckValue<IkReal> x738 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x738.valid){
continue;
}
IkReal x737=((1.0)*(x738.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x737)));
new_r11=0;
new_r00=0;
IkReal gconst35=((3.14159265358979)+(((-1.0)*x737)));
IkReal x739 = new_r01*new_r01;
if(IKabs(x739)==0){
continue;
}
IkReal gconst36=((1.0)*new_r01*(pow(x739,-0.5)));
IkReal gconst37=0;
j3eval[0]=new_r01;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x741 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x741.valid){
continue;
}
IkReal x740=((1.0)*(x741.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x740)));
new_r11=0;
new_r00=0;
IkReal gconst35=((3.14159265358979)+(((-1.0)*x740)));
IkReal x742 = new_r01*new_r01;
if(IKabs(x742)==0){
continue;
}
IkReal gconst36=((1.0)*new_r01*(pow(x742,-0.5)));
IkReal gconst37=0;
j3eval[0]=new_r10;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x743=IKPowWithIntegerCheck(gconst36,-1);
if(!x743.valid){
continue;
}
cj3array[0]=((-1.0)*new_r01*(x743.value));
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x744=IKsin(j3);
IkReal x745=IKcos(j3);
evalcond[0]=(new_r10*x744);
evalcond[1]=(gconst36*x744);
evalcond[2]=((-1.0)*new_r01*x744);
evalcond[3]=(gconst36+((new_r01*x745)));
evalcond[4]=(gconst36+((new_r10*x745)));
evalcond[5]=(new_r10+((gconst36*x745)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x746=IKPowWithIntegerCheck(new_r10,-1);
if(!x746.valid){
continue;
}
cj3array[0]=((-1.0)*gconst36*(x746.value));
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x747=IKsin(j3);
IkReal x748=IKcos(j3);
IkReal x749=(gconst36*x748);
evalcond[0]=(new_r10*x747);
evalcond[1]=(gconst36*x747);
evalcond[2]=((-1.0)*new_r01*x747);
evalcond[3]=(gconst36+((new_r01*x748)));
evalcond[4]=(x749+new_r01);
evalcond[5]=(x749+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x750=IKPowWithIntegerCheck(new_r01,-1);
if(!x750.valid){
continue;
}
cj3array[0]=((-1.0)*gconst36*(x750.value));
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x751=IKsin(j3);
IkReal x752=IKcos(j3);
IkReal x753=(gconst36*x752);
evalcond[0]=(new_r10*x751);
evalcond[1]=(gconst36*x751);
evalcond[2]=((-1.0)*new_r01*x751);
evalcond[3]=(gconst36+((new_r10*x752)));
evalcond[4]=(x753+new_r01);
evalcond[5]=(x753+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst36;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[4];
CheckValue<IkReal> x755 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x755.valid){
continue;
}
IkReal x754=((1.0)*(x755.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x754)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst35=((3.14159265358979)+(((-1.0)*x754)));
IkReal gconst36=((1.0)*new_r01);
IkReal gconst37=((-1.0)*new_r11);
j3eval[0]=1.0;
j3eval[1]=1.0;
j3eval[2]=new_r01;
j3eval[3]=1.0;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  || IKabs(j3eval[3]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
CheckValue<IkReal> x757 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x757.valid){
continue;
}
IkReal x756=((1.0)*(x757.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x756)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst35=((3.14159265358979)+(((-1.0)*x756)));
IkReal gconst36=((1.0)*new_r01);
IkReal gconst37=((-1.0)*new_r11);
j3eval[0]=-1.0;
j3eval[1]=-1.0;
j3eval[2]=((IKabs(((-1.0)+(new_r01*new_r01))))+(IKabs(((1.0)*new_r01*new_r11))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
CheckValue<IkReal> x759 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x759.valid){
continue;
}
IkReal x758=((1.0)*(x759.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x758)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst35=((3.14159265358979)+(((-1.0)*x758)));
IkReal gconst36=((1.0)*new_r01);
IkReal gconst37=((-1.0)*new_r11);
j3eval[0]=1.0;
j3eval[1]=((IKabs(((2.0)*new_r01*new_r11)))+(IKabs(((1.0)+(((-2.0)*(new_r01*new_r01)))))));
j3eval[2]=1.0;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x760=((1.0)*new_r11);
CheckValue<IkReal> x761=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x761.valid){
continue;
}
CheckValue<IkReal> x762 = IKatan2WithCheck(IkReal((((gconst37*new_r01))+(((-1.0)*gconst36*x760)))),IkReal(((((-1.0)*gconst37*x760))+(((-1.0)*gconst36*new_r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x762.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x761.value)))+(x762.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x763=IKsin(j3);
IkReal x764=IKcos(j3);
IkReal x765=(gconst36*x764);
IkReal x766=(gconst36*x763);
IkReal x767=(gconst37*x764);
IkReal x768=((1.0)*x763);
IkReal x769=(gconst37*x768);
evalcond[0]=(((new_r11*x763))+gconst36+((new_r01*x764)));
evalcond[1]=(x766+x767+new_r11);
evalcond[2]=((((-1.0)*x769))+x765);
evalcond[3]=(((new_r11*x764))+gconst37+(((-1.0)*new_r01*x768)));
evalcond[4]=((((-1.0)*x769))+x765+new_r01);
evalcond[5]=((((-1.0)*x766))+(((-1.0)*x767)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x770=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst36*gconst36)))+(((-1.0)*(gconst37*gconst37))))),-1);
if(!x770.valid){
continue;
}
CheckValue<IkReal> x771 = IKatan2WithCheck(IkReal((gconst36*new_r11)),IkReal((gconst37*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x771.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x770.value)))+(x771.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x772=IKsin(j3);
IkReal x773=IKcos(j3);
IkReal x774=(gconst36*x773);
IkReal x775=(gconst36*x772);
IkReal x776=(gconst37*x773);
IkReal x777=((1.0)*x772);
IkReal x778=(gconst37*x777);
evalcond[0]=(gconst36+((new_r11*x772))+((new_r01*x773)));
evalcond[1]=(x776+x775+new_r11);
evalcond[2]=(x774+(((-1.0)*x778)));
evalcond[3]=((((-1.0)*new_r01*x777))+gconst37+((new_r11*x773)));
evalcond[4]=(x774+(((-1.0)*x778))+new_r01);
evalcond[5]=((((-1.0)*x776))+(((-1.0)*x775)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x779 = IKatan2WithCheck(IkReal((gconst36*gconst37)),IkReal(((-1.0)*(gconst36*gconst36))),IKFAST_ATAN2_MAGTHRESH);
if(!x779.valid){
continue;
}
CheckValue<IkReal> x780=IKPowWithIntegerCheck(IKsign((((gconst36*new_r01))+(((-1.0)*gconst37*new_r11)))),-1);
if(!x780.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x779.value)+(((1.5707963267949)*(x780.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x781=IKsin(j3);
IkReal x782=IKcos(j3);
IkReal x783=(gconst36*x782);
IkReal x784=(gconst36*x781);
IkReal x785=(gconst37*x782);
IkReal x786=((1.0)*x781);
IkReal x787=(gconst37*x786);
evalcond[0]=(((new_r11*x781))+gconst36+((new_r01*x782)));
evalcond[1]=(x784+x785+new_r11);
evalcond[2]=((((-1.0)*x787))+x783);
evalcond[3]=((((-1.0)*new_r01*x786))+((new_r11*x782))+gconst37);
evalcond[4]=((((-1.0)*x787))+x783+new_r01);
evalcond[5]=((((-1.0)*x784))+(((-1.0)*x785)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x788=IKPowWithIntegerCheck(gconst37,-1);
if(!x788.valid){
continue;
}
cj3array[0]=(new_r00*(x788.value));
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x789=IKsin(j3);
IkReal x790=IKcos(j3);
IkReal x791=((-1.0)*x789);
evalcond[0]=(new_r11*x789);
evalcond[1]=(new_r00*x791);
evalcond[2]=(gconst37*x791);
evalcond[3]=(((gconst37*x790))+new_r11);
evalcond[4]=(((new_r11*x790))+gconst37);
evalcond[5]=(((new_r00*x790))+(((-1.0)*gconst37)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
CheckValue<IkReal> x793 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x793.valid){
continue;
}
IkReal x792=((1.0)*(x793.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x792)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst35=((3.14159265358979)+(((-1.0)*x792)));
IkReal gconst36=0;
IkReal x794 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x794)==0){
continue;
}
IkReal gconst37=((-1.0)*new_r11*(pow(x794,-0.5)));
j3eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x796 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x796.valid){
continue;
}
IkReal x795=((1.0)*(x796.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x795)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst35=((3.14159265358979)+(((-1.0)*x795)));
IkReal gconst36=0;
IkReal x797 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x797)==0){
continue;
}
IkReal gconst37=((-1.0)*new_r11*(pow(x797,-0.5)));
j3eval[0]=new_r11;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x799 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x799.valid){
continue;
}
IkReal x798=((1.0)*(x799.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x798)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst35=((3.14159265358979)+(((-1.0)*x798)));
IkReal gconst36=0;
IkReal x800 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x800)==0){
continue;
}
IkReal gconst37=((-1.0)*new_r11*(pow(x800,-0.5)));
j3eval[0]=new_r10;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x801=IKPowWithIntegerCheck(new_r10,-1);
if(!x801.valid){
continue;
}
CheckValue<IkReal> x802=IKPowWithIntegerCheck(gconst37,-1);
if(!x802.valid){
continue;
}
if( IKabs((gconst37*(x801.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11*(x802.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst37*(x801.value)))+IKsqr(((-1.0)*new_r11*(x802.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((gconst37*(x801.value)), ((-1.0)*new_r11*(x802.value)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x803=IKsin(j3);
IkReal x804=IKcos(j3);
IkReal x805=(gconst37*x804);
IkReal x806=(gconst37*x803);
evalcond[0]=(new_r11*x803);
evalcond[1]=(new_r10*x804);
evalcond[2]=((-1.0)*x806);
evalcond[3]=((-1.0)*x805);
evalcond[4]=(new_r11+x805);
evalcond[5]=(gconst37+((new_r11*x804)));
evalcond[6]=((((-1.0)*x806))+new_r10);
evalcond[7]=(((new_r10*x803))+(((-1.0)*gconst37)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x807=IKPowWithIntegerCheck(gconst37,-1);
if(!x807.valid){
continue;
}
CheckValue<IkReal> x808=IKPowWithIntegerCheck(new_r11,-1);
if(!x808.valid){
continue;
}
if( IKabs((new_r10*(x807.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst37*(x808.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x807.value)))+IKsqr(((-1.0)*gconst37*(x808.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((new_r10*(x807.value)), ((-1.0)*gconst37*(x808.value)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x809=IKsin(j3);
IkReal x810=IKcos(j3);
IkReal x811=(gconst37*x810);
IkReal x812=(gconst37*x809);
evalcond[0]=(new_r11*x809);
evalcond[1]=(new_r10*x810);
evalcond[2]=((-1.0)*x812);
evalcond[3]=((-1.0)*x811);
evalcond[4]=(new_r11+x811);
evalcond[5]=(((new_r11*x810))+gconst37);
evalcond[6]=((((-1.0)*x812))+new_r10);
evalcond[7]=(((new_r10*x809))+(((-1.0)*gconst37)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x813=IKPowWithIntegerCheck(IKsign(gconst37),-1);
if(!x813.valid){
continue;
}
CheckValue<IkReal> x814 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x814.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x813.value)))+(x814.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x815=IKsin(j3);
IkReal x816=IKcos(j3);
IkReal x817=(gconst37*x816);
IkReal x818=(gconst37*x815);
evalcond[0]=(new_r11*x815);
evalcond[1]=(new_r10*x816);
evalcond[2]=((-1.0)*x818);
evalcond[3]=((-1.0)*x817);
evalcond[4]=(new_r11+x817);
evalcond[5]=(((new_r11*x816))+gconst37);
evalcond[6]=((((-1.0)*x818))+new_r10);
evalcond[7]=(((new_r10*x815))+(((-1.0)*gconst37)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
CheckValue<IkReal> x820 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x820.valid){
continue;
}
IkReal x819=((1.0)*(x820.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x819)));
new_r01=0;
IkReal gconst35=((3.14159265358979)+(((-1.0)*x819)));
IkReal gconst36=0;
IkReal x821 = new_r11*new_r11;
if(IKabs(x821)==0){
continue;
}
IkReal gconst37=((-1.0)*new_r11*(pow(x821,-0.5)));
j3eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x823 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x823.valid){
continue;
}
IkReal x822=((1.0)*(x823.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x822)));
new_r01=0;
IkReal gconst35=((3.14159265358979)+(((-1.0)*x822)));
IkReal gconst36=0;
IkReal x824 = new_r11*new_r11;
if(IKabs(x824)==0){
continue;
}
IkReal gconst37=((-1.0)*new_r11*(pow(x824,-0.5)));
j3eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x826 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x826.valid){
continue;
}
IkReal x825=((1.0)*(x826.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x825)));
new_r01=0;
IkReal gconst35=((3.14159265358979)+(((-1.0)*x825)));
IkReal gconst36=0;
IkReal x827 = new_r11*new_r11;
if(IKabs(x827)==0){
continue;
}
IkReal gconst37=((-1.0)*new_r11*(pow(x827,-0.5)));
j3eval[0]=new_r11;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x828=IKPowWithIntegerCheck(gconst37,-1);
if(!x828.valid){
continue;
}
CheckValue<IkReal> x829=IKPowWithIntegerCheck(new_r11,-1);
if(!x829.valid){
continue;
}
if( IKabs((new_r10*(x828.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst37*(x829.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x828.value)))+IKsqr(((-1.0)*gconst37*(x829.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((new_r10*(x828.value)), ((-1.0)*gconst37*(x829.value)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x830=IKsin(j3);
IkReal x831=IKcos(j3);
IkReal x832=(gconst37*x831);
IkReal x833=(gconst37*x830);
evalcond[0]=(new_r11*x830);
evalcond[1]=((-1.0)*x833);
evalcond[2]=(new_r11+x832);
evalcond[3]=(((new_r11*x831))+gconst37);
evalcond[4]=((((-1.0)*x833))+new_r10);
evalcond[5]=((((-1.0)*x832))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x830))+((new_r10*x831)));
evalcond[7]=(((new_r00*x831))+(((-1.0)*gconst37))+((new_r10*x830)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x834=IKPowWithIntegerCheck(IKsign(gconst37),-1);
if(!x834.valid){
continue;
}
CheckValue<IkReal> x835 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x835.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x834.value)))+(x835.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x836=IKsin(j3);
IkReal x837=IKcos(j3);
IkReal x838=(gconst37*x837);
IkReal x839=(gconst37*x836);
evalcond[0]=(new_r11*x836);
evalcond[1]=((-1.0)*x839);
evalcond[2]=(new_r11+x838);
evalcond[3]=(((new_r11*x837))+gconst37);
evalcond[4]=((((-1.0)*x839))+new_r10);
evalcond[5]=((((-1.0)*x838))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x836))+((new_r10*x837)));
evalcond[7]=(((new_r00*x837))+(((-1.0)*gconst37))+((new_r10*x836)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x840=IKPowWithIntegerCheck(IKsign(gconst37),-1);
if(!x840.valid){
continue;
}
CheckValue<IkReal> x841 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x841.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x840.value)))+(x841.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x842=IKsin(j3);
IkReal x843=IKcos(j3);
IkReal x844=(gconst37*x843);
IkReal x845=(gconst37*x842);
evalcond[0]=(new_r11*x842);
evalcond[1]=((-1.0)*x845);
evalcond[2]=(new_r11+x844);
evalcond[3]=(gconst37+((new_r11*x843)));
evalcond[4]=((((-1.0)*x845))+new_r10);
evalcond[5]=((((-1.0)*x844))+new_r00);
evalcond[6]=(((new_r10*x843))+(((-1.0)*new_r00*x842)));
evalcond[7]=(((new_r10*x842))+((new_r00*x843))+(((-1.0)*gconst37)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x846=((1.0)*new_r11);
CheckValue<IkReal> x847 = IKatan2WithCheck(IkReal((((gconst36*gconst37))+(((-1.0)*new_r01*x846)))),IkReal(((((-1.0)*(gconst36*gconst36)))+(new_r11*new_r11))),IKFAST_ATAN2_MAGTHRESH);
if(!x847.valid){
continue;
}
CheckValue<IkReal> x848=IKPowWithIntegerCheck(IKsign(((((-1.0)*gconst37*x846))+((gconst36*new_r01)))),-1);
if(!x848.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x847.value)+(((1.5707963267949)*(x848.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x849=IKsin(j3);
IkReal x850=IKcos(j3);
IkReal x851=(gconst36*x850);
IkReal x852=(gconst36*x849);
IkReal x853=(gconst37*x850);
IkReal x854=((1.0)*x849);
IkReal x855=(gconst37*x854);
evalcond[0]=(gconst36+((new_r01*x850))+((new_r11*x849)));
evalcond[1]=(new_r11+x852+x853);
evalcond[2]=(gconst36+(((-1.0)*new_r00*x854))+((new_r10*x850)));
evalcond[3]=((((-1.0)*new_r01*x854))+gconst37+((new_r11*x850)));
evalcond[4]=((((-1.0)*x855))+new_r01+x851);
evalcond[5]=((((-1.0)*x855))+new_r10+x851);
evalcond[6]=(((new_r10*x849))+((new_r00*x850))+(((-1.0)*gconst37)));
evalcond[7]=((((-1.0)*x852))+(((-1.0)*x853))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x856=((1.0)*new_r11);
CheckValue<IkReal> x857 = IKatan2WithCheck(IkReal(((((-1.0)*gconst36*x856))+((gconst37*new_r01)))),IkReal(((((-1.0)*gconst36*new_r01))+(((-1.0)*gconst37*x856)))),IKFAST_ATAN2_MAGTHRESH);
if(!x857.valid){
continue;
}
CheckValue<IkReal> x858=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x858.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x857.value)+(((1.5707963267949)*(x858.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x859=IKsin(j3);
IkReal x860=IKcos(j3);
IkReal x861=(gconst36*x860);
IkReal x862=(gconst36*x859);
IkReal x863=(gconst37*x860);
IkReal x864=((1.0)*x859);
IkReal x865=(gconst37*x864);
evalcond[0]=(((new_r01*x860))+gconst36+((new_r11*x859)));
evalcond[1]=(new_r11+x863+x862);
evalcond[2]=((((-1.0)*new_r00*x864))+gconst36+((new_r10*x860)));
evalcond[3]=((((-1.0)*new_r01*x864))+gconst37+((new_r11*x860)));
evalcond[4]=((((-1.0)*x865))+new_r01+x861);
evalcond[5]=((((-1.0)*x865))+new_r10+x861);
evalcond[6]=(((new_r00*x860))+((new_r10*x859))+(((-1.0)*gconst37)));
evalcond[7]=((((-1.0)*x863))+(((-1.0)*x862))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x866=((1.0)*gconst36);
CheckValue<IkReal> x867 = IKatan2WithCheck(IkReal((((gconst36*new_r01))+(((-1.0)*new_r10*x866)))),IkReal(((((-1.0)*new_r00*x866))+(((-1.0)*new_r11*x866)))),IKFAST_ATAN2_MAGTHRESH);
if(!x867.valid){
continue;
}
CheckValue<IkReal> x868=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x868.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x867.value)+(((1.5707963267949)*(x868.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x869=IKsin(j3);
IkReal x870=IKcos(j3);
IkReal x871=(gconst36*x870);
IkReal x872=(gconst36*x869);
IkReal x873=(gconst37*x870);
IkReal x874=((1.0)*x869);
IkReal x875=(gconst37*x874);
evalcond[0]=(((new_r01*x870))+gconst36+((new_r11*x869)));
evalcond[1]=(new_r11+x872+x873);
evalcond[2]=((((-1.0)*new_r00*x874))+gconst36+((new_r10*x870)));
evalcond[3]=(gconst37+(((-1.0)*new_r01*x874))+((new_r11*x870)));
evalcond[4]=(new_r01+x871+(((-1.0)*x875)));
evalcond[5]=(new_r10+x871+(((-1.0)*x875)));
evalcond[6]=(((new_r00*x870))+((new_r10*x869))+(((-1.0)*gconst37)));
evalcond[7]=((((-1.0)*x872))+(((-1.0)*x873))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((new_r01*new_r01)+(new_r11*new_r11));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r01=0;
new_r11=0;
j3eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x877 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x877.valid){
continue;
}
IkReal x876=x877.value;
j3array[0]=((-1.0)*x876);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x876)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r00*(IKsin(j3))))+((new_r10*(IKcos(j3)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x878=IKcos(j3);
IkReal x879=IKsin(j3);
IkReal x880=((1.0)*x879);
evalcond[0]=(new_r11+x878);
evalcond[1]=((((-1.0)*x880))+new_r01);
evalcond[2]=((((-1.0)*x880))+new_r10);
evalcond[3]=((((-1.0)*x878))+new_r00);
evalcond[4]=(((new_r01*x878))+((new_r11*x879)));
evalcond[5]=((-1.0)+((new_r00*x878))+((new_r10*x879)));
evalcond[6]=((((-1.0)*new_r00*x880))+((new_r10*x878)));
evalcond[7]=((1.0)+(((-1.0)*new_r01*x880))+((new_r11*x878)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r01), ((-1.0)*new_r00));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x881=IKsin(j3);
IkReal x882=IKcos(j3);
IkReal x883=((1.0)*x881);
evalcond[0]=(new_r01+x881);
evalcond[1]=(new_r10+x881);
evalcond[2]=(new_r00+x882);
evalcond[3]=((((-1.0)*x882))+new_r11);
evalcond[4]=(((new_r01*x882))+((new_r11*x881)));
evalcond[5]=((1.0)+((new_r10*x881))+((new_r00*x882)));
evalcond[6]=(((new_r10*x882))+(((-1.0)*new_r00*x883)));
evalcond[7]=((-1.0)+((new_r11*x882))+(((-1.0)*new_r01*x883)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r11=0;
new_r00=0;
j3eval[0]=new_r01;
j3eval[1]=((IKabs(cj5))+(IKabs(sj5)));
j3eval[2]=IKsign(new_r01);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r11=0;
new_r00=0;
j3eval[0]=new_r01;
j3eval[1]=new_r10;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x884=IKPowWithIntegerCheck(new_r01,-1);
if(!x884.valid){
continue;
}
CheckValue<IkReal> x885=IKPowWithIntegerCheck(new_r10,-1);
if(!x885.valid){
continue;
}
if( IKabs((cj5*(x884.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*sj5*(x885.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((cj5*(x884.value)))+IKsqr(((-1.0)*sj5*(x885.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((cj5*(x884.value)), ((-1.0)*sj5*(x885.value)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[7];
IkReal x886=IKcos(j3);
IkReal x887=IKsin(j3);
IkReal x888=((1.0)*cj5);
IkReal x889=(sj5*x886);
IkReal x890=(x887*x888);
evalcond[0]=(sj5+((new_r01*x886)));
evalcond[1]=(sj5+((new_r10*x886)));
evalcond[2]=(cj5+(((-1.0)*new_r01*x887)));
evalcond[3]=(((new_r10*x887))+(((-1.0)*x888)));
evalcond[4]=(((sj5*x887))+((cj5*x886)));
evalcond[5]=((((-1.0)*x890))+new_r01+x889);
evalcond[6]=((((-1.0)*x890))+new_r10+x889);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x891=IKPowWithIntegerCheck(IKsign(new_r01),-1);
if(!x891.valid){
continue;
}
CheckValue<IkReal> x892 = IKatan2WithCheck(IkReal(cj5),IkReal(((-1.0)*sj5)),IKFAST_ATAN2_MAGTHRESH);
if(!x892.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x891.value)))+(x892.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[7];
IkReal x893=IKcos(j3);
IkReal x894=IKsin(j3);
IkReal x895=((1.0)*cj5);
IkReal x896=(sj5*x893);
IkReal x897=(x894*x895);
evalcond[0]=(sj5+((new_r01*x893)));
evalcond[1]=(sj5+((new_r10*x893)));
evalcond[2]=(cj5+(((-1.0)*new_r01*x894)));
evalcond[3]=(((new_r10*x894))+(((-1.0)*x895)));
evalcond[4]=(((sj5*x894))+((cj5*x893)));
evalcond[5]=((((-1.0)*x897))+new_r01+x896);
evalcond[6]=((((-1.0)*x897))+new_r10+x896);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r11=0;
new_r01=0;
new_r22=0;
new_r20=0;
j3eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j3]

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x899 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x899.valid){
continue;
}
IkReal x898=x899.value;
j3array[0]=((-1.0)*x898);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x898)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r00*(IKsin(j3))))+((new_r10*(IKcos(j3)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
j3eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j3]

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x901 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x901.valid){
continue;
}
IkReal x900=x901.value;
j3array[0]=((-1.0)*x900);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x900)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
evalcond[0]=(((new_r11*(IKcos(j3))))+(((-1.0)*new_r01*(IKsin(j3)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r01=0;
new_r10=0;
j3eval[0]=new_r11;
j3eval[1]=IKsign(new_r11);
j3eval[2]=((IKabs(cj5))+(IKabs(sj5)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r01=0;
new_r10=0;
j3eval[0]=new_r00;
j3eval[1]=new_r11;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r01=0;
new_r10=0;
j3eval[0]=new_r11;
j3eval[1]=cj5;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=new_r00;
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x902=IKcos(j3);
IkReal x903=IKsin(j3);
evalcond[0]=x902;
evalcond[1]=(new_r00*x902);
evalcond[2]=(new_r11+x903);
evalcond[3]=(new_r11*x902);
evalcond[4]=((1.0)+((new_r11*x903)));
evalcond[5]=((1.0)+(((-1.0)*new_r00*x903)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=new_r11;
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x904=IKcos(j3);
IkReal x905=IKsin(j3);
evalcond[0]=(new_r00*x904);
evalcond[1]=(new_r11*x904);
evalcond[2]=((-1.0)*x904);
evalcond[3]=(new_r00+x905);
evalcond[4]=((-1.0)+((new_r11*x905)));
evalcond[5]=((-1.0)+(((-1.0)*new_r00*x905)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x907=IKPowWithIntegerCheck(new_r11,-1);
if(!x907.valid){
continue;
}
IkReal x906=x907.value;
CheckValue<IkReal> x908=IKPowWithIntegerCheck(cj5,-1);
if(!x908.valid){
continue;
}
CheckValue<IkReal> x909=IKPowWithIntegerCheck(x906,-2);
if(!x909.valid){
continue;
}
if( IKabs(((-1.0)*sj5*x906)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x906*(x908.value)*(((1.0)+(((-1.0)*(x909.value)))+(((-1.0)*(cj5*cj5))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*sj5*x906))+IKsqr((x906*(x908.value)*(((1.0)+(((-1.0)*(x909.value)))+(((-1.0)*(cj5*cj5)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*sj5*x906), (x906*(x908.value)*(((1.0)+(((-1.0)*(x909.value)))+(((-1.0)*(cj5*cj5)))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[7];
IkReal x910=IKsin(j3);
IkReal x911=IKcos(j3);
IkReal x912=((1.0)*cj5);
IkReal x913=(sj5*x910);
evalcond[0]=(sj5+((new_r11*x910)));
evalcond[1]=(cj5+((new_r11*x911)));
evalcond[2]=(sj5+(((-1.0)*new_r00*x910)));
evalcond[3]=((((-1.0)*x912))+((new_r00*x911)));
evalcond[4]=(((cj5*x911))+new_r11+x913);
evalcond[5]=(((sj5*x911))+(((-1.0)*x910*x912)));
evalcond[6]=((((-1.0)*x913))+new_r00+(((-1.0)*x911*x912)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x914=IKPowWithIntegerCheck(new_r00,-1);
if(!x914.valid){
continue;
}
CheckValue<IkReal> x915=IKPowWithIntegerCheck(new_r11,-1);
if(!x915.valid){
continue;
}
if( IKabs((sj5*(x914.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*cj5*(x915.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((sj5*(x914.value)))+IKsqr(((-1.0)*cj5*(x915.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((sj5*(x914.value)), ((-1.0)*cj5*(x915.value)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[7];
IkReal x916=IKsin(j3);
IkReal x917=IKcos(j3);
IkReal x918=((1.0)*cj5);
IkReal x919=(sj5*x916);
evalcond[0]=(sj5+((new_r11*x916)));
evalcond[1]=(cj5+((new_r11*x917)));
evalcond[2]=(sj5+(((-1.0)*new_r00*x916)));
evalcond[3]=((((-1.0)*x918))+((new_r00*x917)));
evalcond[4]=(((cj5*x917))+new_r11+x919);
evalcond[5]=(((sj5*x917))+(((-1.0)*x916*x918)));
evalcond[6]=((((-1.0)*x919))+new_r00+(((-1.0)*x917*x918)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x920 = IKatan2WithCheck(IkReal(((-1.0)*sj5)),IkReal(((-1.0)*cj5)),IKFAST_ATAN2_MAGTHRESH);
if(!x920.valid){
continue;
}
CheckValue<IkReal> x921=IKPowWithIntegerCheck(IKsign(new_r11),-1);
if(!x921.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x920.value)+(((1.5707963267949)*(x921.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[7];
IkReal x922=IKsin(j3);
IkReal x923=IKcos(j3);
IkReal x924=((1.0)*cj5);
IkReal x925=(sj5*x922);
evalcond[0]=(sj5+((new_r11*x922)));
evalcond[1]=(cj5+((new_r11*x923)));
evalcond[2]=(sj5+(((-1.0)*new_r00*x922)));
evalcond[3]=((((-1.0)*x924))+((new_r00*x923)));
evalcond[4]=(new_r11+x925+((cj5*x923)));
evalcond[5]=(((sj5*x923))+(((-1.0)*x922*x924)));
evalcond[6]=((((-1.0)*x925))+new_r00+(((-1.0)*x923*x924)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x926 = IKatan2WithCheck(IkReal(((-1.0)+(new_r01*new_r01)+(cj5*cj5))),IkReal(((((-1.0)*cj5*sj5))+(((-1.0)*new_r01*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x926.valid){
continue;
}
CheckValue<IkReal> x927=IKPowWithIntegerCheck(IKsign((((new_r11*sj5))+((cj5*new_r01)))),-1);
if(!x927.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x926.value)+(((1.5707963267949)*(x927.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x928=IKsin(j3);
IkReal x929=IKcos(j3);
IkReal x930=((1.0)*cj5);
IkReal x931=(sj5*x929);
IkReal x932=(sj5*x928);
IkReal x933=((1.0)*x928);
IkReal x934=(x928*x930);
evalcond[0]=(sj5+((new_r01*x929))+((new_r11*x928)));
evalcond[1]=(new_r11+x932+((cj5*x929)));
evalcond[2]=(sj5+(((-1.0)*new_r00*x933))+((new_r10*x929)));
evalcond[3]=(cj5+(((-1.0)*new_r01*x933))+((new_r11*x929)));
evalcond[4]=(new_r01+x931+(((-1.0)*x934)));
evalcond[5]=(new_r10+x931+(((-1.0)*x934)));
evalcond[6]=(((new_r00*x929))+((new_r10*x928))+(((-1.0)*x930)));
evalcond[7]=((((-1.0)*x932))+(((-1.0)*x929*x930))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x935=((1.0)*sj5);
CheckValue<IkReal> x936 = IKatan2WithCheck(IkReal(((((-1.0)*new_r11*x935))+((cj5*new_r01)))),IkReal(((((-1.0)*new_r01*x935))+(((-1.0)*cj5*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x936.valid){
continue;
}
CheckValue<IkReal> x937=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x937.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x936.value)+(((1.5707963267949)*(x937.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x938=IKsin(j3);
IkReal x939=IKcos(j3);
IkReal x940=((1.0)*cj5);
IkReal x941=(sj5*x939);
IkReal x942=(sj5*x938);
IkReal x943=((1.0)*x938);
IkReal x944=(x938*x940);
evalcond[0]=(sj5+((new_r01*x939))+((new_r11*x938)));
evalcond[1]=(new_r11+x942+((cj5*x939)));
evalcond[2]=(sj5+((new_r10*x939))+(((-1.0)*new_r00*x943)));
evalcond[3]=(cj5+(((-1.0)*new_r01*x943))+((new_r11*x939)));
evalcond[4]=((((-1.0)*x944))+new_r01+x941);
evalcond[5]=((((-1.0)*x944))+new_r10+x941);
evalcond[6]=((((-1.0)*x940))+((new_r00*x939))+((new_r10*x938)));
evalcond[7]=((((-1.0)*x939*x940))+(((-1.0)*x942))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x945=((1.0)*sj5);
CheckValue<IkReal> x946 = IKatan2WithCheck(IkReal((((new_r01*sj5))+(((-1.0)*new_r10*x945)))),IkReal(((((-1.0)*new_r11*x945))+(((-1.0)*new_r00*x945)))),IKFAST_ATAN2_MAGTHRESH);
if(!x946.valid){
continue;
}
CheckValue<IkReal> x947=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x947.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x946.value)+(((1.5707963267949)*(x947.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x948=IKsin(j3);
IkReal x949=IKcos(j3);
IkReal x950=((1.0)*cj5);
IkReal x951=(sj5*x949);
IkReal x952=(sj5*x948);
IkReal x953=((1.0)*x948);
IkReal x954=(x948*x950);
evalcond[0]=(sj5+((new_r01*x949))+((new_r11*x948)));
evalcond[1]=(new_r11+x952+((cj5*x949)));
evalcond[2]=(sj5+(((-1.0)*new_r00*x953))+((new_r10*x949)));
evalcond[3]=(cj5+(((-1.0)*new_r01*x953))+((new_r11*x949)));
evalcond[4]=(new_r01+(((-1.0)*x954))+x951);
evalcond[5]=(new_r10+(((-1.0)*x954))+x951);
evalcond[6]=(((new_r00*x949))+((new_r10*x948))+(((-1.0)*x950)));
evalcond[7]=((((-1.0)*x952))+(((-1.0)*x949*x950))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x955=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj5*x955))+(((-1.0)*new_r11*sj5)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj5*new_r11))+(((-1.0)*sj5*x955)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj5*x955))+(((-1.0)*new_r11*sj5))))+IKsqr((((cj5*new_r11))+(((-1.0)*sj5*x955))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*cj5*x955))+(((-1.0)*new_r11*sj5))), (((cj5*new_r11))+(((-1.0)*sj5*x955))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x956=IKcos(j3);
IkReal x957=IKsin(j3);
IkReal x958=((1.0)*cj5);
IkReal x959=(sj5*x957);
IkReal x960=(sj5*x956);
IkReal x961=((1.0)*x957);
IkReal x962=(x956*x958);
evalcond[0]=(sj5+((new_r01*x956))+((new_r11*x957)));
evalcond[1]=(((cj5*x957))+new_r01+x960);
evalcond[2]=(new_r11+x959+(((-1.0)*x962)));
evalcond[3]=(new_r00+x959+(((-1.0)*x962)));
evalcond[4]=(((new_r10*x957))+((new_r00*x956))+(((-1.0)*x958)));
evalcond[5]=((((-1.0)*x960))+(((-1.0)*x957*x958))+new_r10);
evalcond[6]=(((new_r10*x956))+(((-1.0)*sj5))+(((-1.0)*new_r00*x961)));
evalcond[7]=((((-1.0)*new_r01*x961))+(((-1.0)*x958))+((new_r11*x956)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j3eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j3eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j3eval[0]=((IKabs((new_r10*new_r22)))+(IKabs((new_r00*new_r22))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j3]

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x964 = IKatan2WithCheck(IkReal((new_r10*new_r22)),IkReal(((-1.0)*new_r00*new_r22)),IKFAST_ATAN2_MAGTHRESH);
if(!x964.valid){
continue;
}
IkReal x963=x964.value;
j3array[0]=((-1.0)*x963);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x963)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[5];
IkReal x965=IKsin(j3);
IkReal x966=IKcos(j3);
IkReal x967=(new_r11*x966);
IkReal x968=((1.0)*x965);
evalcond[0]=(((new_r11*x965))+((new_r01*x966)));
evalcond[1]=(((new_r00*x966))+((new_r10*x965)));
evalcond[2]=((((-1.0)*new_r00*x968))+((new_r10*x966)));
evalcond[3]=((((-1.0)*new_r01*x968))+x967);
evalcond[4]=((((-1.0)*new_r01*new_r22*x968))+((new_r22*x967)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x970 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x970.valid){
continue;
}
IkReal x969=x970.value;
j3array[0]=((-1.0)*x969);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x969)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[5];
IkReal x971=IKcos(j3);
IkReal x972=IKsin(j3);
IkReal x973=(new_r11*x971);
IkReal x974=(new_r10*x971);
IkReal x975=((1.0)*x972);
evalcond[0]=(((new_r01*x971))+((new_r11*x972)));
evalcond[1]=((((-1.0)*new_r00*x975))+x974);
evalcond[2]=((((-1.0)*new_r01*x975))+x973);
evalcond[3]=((((-1.0)*new_r00*new_r22*x975))+((new_r22*x974)));
evalcond[4]=((((-1.0)*new_r01*new_r22*x975))+((new_r22*x973)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x977 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x977.valid){
continue;
}
IkReal x976=x977.value;
j3array[0]=((-1.0)*x976);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x976)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[5];
IkReal x978=IKcos(j3);
IkReal x979=IKsin(j3);
IkReal x980=(new_r11*x978);
IkReal x981=(new_r10*x978);
IkReal x982=((1.0)*x979);
evalcond[0]=(((new_r10*x979))+((new_r00*x978)));
evalcond[1]=((((-1.0)*new_r00*x982))+x981);
evalcond[2]=((((-1.0)*new_r01*x982))+x980);
evalcond[3]=(((new_r22*x981))+(((-1.0)*new_r00*new_r22*x982)));
evalcond[4]=((((-1.0)*new_r01*new_r22*x982))+((new_r22*x980)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x984=IKPowWithIntegerCheck(cj4,-1);
if(!x984.valid){
continue;
}
IkReal x983=x984.value;
CheckValue<IkReal> x985=IKPowWithIntegerCheck(new_r11,-1);
if(!x985.valid){
continue;
}
if( IKabs((x983*(x985.value)*(((((-1.0)*cj4*sj5))+((new_r01*new_r12)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r12*x983)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x983*(x985.value)*(((((-1.0)*cj4*sj5))+((new_r01*new_r12))))))+IKsqr(((-1.0)*new_r12*x983))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((x983*(x985.value)*(((((-1.0)*cj4*sj5))+((new_r01*new_r12))))), ((-1.0)*new_r12*x983));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[18];
IkReal x986=IKsin(j3);
IkReal x987=IKcos(j3);
IkReal x988=((1.0)*cj5);
IkReal x989=(cj5*sj4);
IkReal x990=((1.0)*sj5);
IkReal x991=(sj4*x986);
IkReal x992=(sj5*x987);
IkReal x993=(new_r11*x987);
IkReal x994=(new_r12*x987);
IkReal x995=(new_r10*x987);
IkReal x996=((1.0)*x986);
IkReal x997=((1.0)*sj4*x987);
IkReal x998=(new_r00*x996);
IkReal x999=(cj4*x996);
evalcond[0]=(((cj4*x987))+new_r12);
evalcond[1]=((((-1.0)*x999))+new_r02);
evalcond[2]=(((new_r02*x987))+((new_r12*x986)));
evalcond[3]=(sj5+((new_r11*x986))+((new_r01*x987)));
evalcond[4]=(cj4+(((-1.0)*new_r02*x996))+x994);
evalcond[5]=(((sj5*x986))+new_r11+((x987*x989)));
evalcond[6]=(((new_r00*x987))+(((-1.0)*x988))+((new_r10*x986)));
evalcond[7]=(new_r01+x992+(((-1.0)*x988*x991)));
evalcond[8]=(((sj4*x992))+(((-1.0)*x986*x988))+new_r10);
evalcond[9]=(((sj4*sj5))+(((-1.0)*x998))+x995);
evalcond[10]=((((-1.0)*new_r01*x996))+x993+x989);
evalcond[11]=((((-1.0)*x990*x991))+(((-1.0)*x987*x988))+new_r00);
evalcond[12]=((((-1.0)*cj4*x998))+((new_r20*sj4))+((cj4*x995)));
evalcond[13]=(((cj4*x993))+(((-1.0)*new_r01*x999))+((new_r21*sj4)));
evalcond[14]=(((cj4*new_r22))+((new_r02*x991))+(((-1.0)*sj4*x994)));
evalcond[15]=((1.0)+(((-1.0)*new_r02*x999))+((cj4*x994))+((new_r22*sj4)));
evalcond[16]=(((cj4*new_r20))+(((-1.0)*x990))+(((-1.0)*sj4*x995))+((new_r00*x991)));
evalcond[17]=((((-1.0)*x988))+((cj4*new_r21))+(((-1.0)*sj4*x993))+((new_r01*x991)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x1000=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x1000.valid){
continue;
}
CheckValue<IkReal> x1001 = IKatan2WithCheck(IkReal(new_r02),IkReal(((-1.0)*new_r12)),IKFAST_ATAN2_MAGTHRESH);
if(!x1001.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1000.value)))+(x1001.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[18];
IkReal x1002=IKsin(j3);
IkReal x1003=IKcos(j3);
IkReal x1004=((1.0)*cj5);
IkReal x1005=(cj5*sj4);
IkReal x1006=((1.0)*sj5);
IkReal x1007=(sj4*x1002);
IkReal x1008=(sj5*x1003);
IkReal x1009=(new_r11*x1003);
IkReal x1010=(new_r12*x1003);
IkReal x1011=(new_r10*x1003);
IkReal x1012=((1.0)*x1002);
IkReal x1013=((1.0)*sj4*x1003);
IkReal x1014=(new_r00*x1012);
IkReal x1015=(cj4*x1012);
evalcond[0]=(((cj4*x1003))+new_r12);
evalcond[1]=((((-1.0)*x1015))+new_r02);
evalcond[2]=(((new_r12*x1002))+((new_r02*x1003)));
evalcond[3]=(sj5+((new_r11*x1002))+((new_r01*x1003)));
evalcond[4]=(x1010+cj4+(((-1.0)*new_r02*x1012)));
evalcond[5]=(((sj5*x1002))+new_r11+((x1003*x1005)));
evalcond[6]=((((-1.0)*x1004))+((new_r10*x1002))+((new_r00*x1003)));
evalcond[7]=(x1008+(((-1.0)*x1004*x1007))+new_r01);
evalcond[8]=(((sj4*x1008))+(((-1.0)*x1002*x1004))+new_r10);
evalcond[9]=(x1011+(((-1.0)*x1014))+((sj4*sj5)));
evalcond[10]=(x1009+x1005+(((-1.0)*new_r01*x1012)));
evalcond[11]=((((-1.0)*x1006*x1007))+new_r00+(((-1.0)*x1003*x1004)));
evalcond[12]=(((new_r20*sj4))+(((-1.0)*cj4*x1014))+((cj4*x1011)));
evalcond[13]=(((cj4*x1009))+(((-1.0)*new_r01*x1015))+((new_r21*sj4)));
evalcond[14]=(((cj4*new_r22))+(((-1.0)*sj4*x1010))+((new_r02*x1007)));
evalcond[15]=((1.0)+(((-1.0)*new_r02*x1015))+((new_r22*sj4))+((cj4*x1010)));
evalcond[16]=((((-1.0)*x1006))+((cj4*new_r20))+(((-1.0)*sj4*x1011))+((new_r00*x1007)));
evalcond[17]=((((-1.0)*x1004))+((cj4*new_r21))+(((-1.0)*sj4*x1009))+((new_r01*x1007)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "737060559fd8d4869a0db3892e301c81"; }

IKFAST_API const char* GetIkFastVersion() { return "0x1000004a"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif

// start python bindings
// https://github.com/caelan/ss-pybullet/blob/c5efe7ad32381a7a7a15c2bd147b5a8731d21342/pybullet_tools/ikfast/pr2/left_arm_ik.cpp#L12972
// https://github.com/yijiangh/conrob_pybullet/blob/master/utils/ikfast/kuka_kr6_r900/ikfast0x1000004a.Transform6D.0_1_2_3_4_5.cpp#L9923

static PyObject *get_ik(PyObject *self, PyObject *args)
{
    IkSolutionList<IkReal> solutions;

    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9], eetrans[3];

    // First list if 3x3 rotation matrix, easier to compute in Python.
    // Next list is [x, y, z] translation matrix.
    // Last list is free joints.
    PyObject *rotList; // 3x3 rotation matrix
    PyObject *transList; // [x,y,z]
    PyObject *freeList; // can be empty

    // format 'O!': pass C object pointer with the pointer's address.
    if(!PyArg_ParseTuple(args, "O!O!O!", &PyList_Type, &rotList, &PyList_Type, &transList, &PyList_Type, &freeList))
    {
        fprintf(stderr,"Failed to parse input to python objects\n");
        return NULL;
    }

    for(std::size_t i = 0; i < 3; ++i)
    {
        eetrans[i] = PyFloat_AsDouble(PyList_GetItem(transList, i));

        PyObject* rowList = PyList_GetItem(rotList, i);
        for( std::size_t j = 0; j < 3; ++j)
        {
            eerot[3*i + j] = PyFloat_AsDouble(PyList_GetItem(rowList, j));
        }
    }

    for(int i = 0; i < GetNumFreeParameters(); ++i)
    {
        vfree[i] = PyFloat_AsDouble(PyList_GetItem(freeList, i));
    }

    // call ikfast routine
    bool bSuccess = ComputeIk(eetrans, eerot, &vfree[0], solutions);

    if (!bSuccess)
    {
        //fprintf(stderr,"Failed to get ik solution\n");
        return Py_BuildValue(""); // Equivalent to returning None in python
    }

    std::vector<IkReal> solvalues(GetNumJoints());
    PyObject *solutionList = PyList_New(solutions.GetNumSolutions());

    // convert all ikfast solutions into a python list
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i)
    {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);

        PyObject *individualSolution = PyList_New(GetNumJoints());
        for( std::size_t j = 0; j < solvalues.size(); ++j)
        {
            // I think IkReal is just a wrapper for double. So this should work.
            PyList_SetItem(individualSolution, j, PyFloat_FromDouble(solvalues[j]));
        }
        PyList_SetItem(solutionList, i, individualSolution);
    }

    return solutionList;
}

static PyObject *get_fk(PyObject *self, PyObject *args)
{
    std::vector<IkReal> joints(GetNumJoints());
    // eerot is a flattened 3x3 rotation matrix
    IkReal eerot[9], eetrans[3];

    PyObject *jointList;
    if(!PyArg_ParseTuple(args, "O!", &PyList_Type, &jointList))
    {
        return NULL;
    }

    for(std::size_t i = 0; i < GetNumJoints(); ++i)
    {
        joints[i] = PyFloat_AsDouble(PyList_GetItem(jointList, i));
    }

    // call ikfast routine
    ComputeFk(&joints[0], eetrans, eerot);

    // convert computed EE pose to a python object
    PyObject *pose = PyList_New(2);
    PyObject *pos = PyList_New(3);
    PyObject *rot = PyList_New(3);

    for(std::size_t i = 0; i < 3; ++i)
    {
        PyList_SetItem(pos, i, PyFloat_FromDouble(eetrans[i]));

        PyObject *row = PyList_New(3);
        for( std::size_t j = 0; j < 3; ++j)
        {
            PyList_SetItem(row, j, PyFloat_FromDouble(eerot[3*i + j]));
        }
        PyList_SetItem(rot, i, row);
    }

    PyList_SetItem(pose, 0, pos);
    PyList_SetItem(pose, 1, rot);

    return pose;
}

static PyMethodDef ikfast_methods[] =
{
    {"get_ik", get_ik, METH_VARARGS, "Compute ik solutions using ikfast."},
    {"get_fk", get_fk, METH_VARARGS, "Compute fk solutions using ikfast."},
    {NULL, NULL, 0, NULL}
    // Not sure why/if this is needed. It shows up in the examples though(something about Sentinel).
};

#if PY_MAJOR_VERSION >= 3

static struct PyModuleDef ikfast_assistive_human_module = {
    PyModuleDef_HEAD_INIT,
    "ikfast_assistive_human",   /* name of module */
    NULL, /* module documentation, may be NULL */
    -1,       /* size of per-interpreter state of the module,
                 or -1 if the module keeps state in global variables. */
    ikfast_methods
};

#define INITERROR return NULL

PyMODINIT_FUNC
PyInit_ikfast_assistive_human(void)

#else // PY_MAJOR_VERSION < 3
#define INITERROR return

PyMODINIT_FUNC
initikfast_assistive_human(void)
#endif
{
#if PY_MAJOR_VERSION >= 3
    PyObject *module = PyModule_Create(&ikfast_assistive_human_module);
#else
    PyObject *module = Py_InitModule("ikfast_assistive_human", ikfast_methods);
#endif

if (module == NULL)
    INITERROR;

#if PY_MAJOR_VERSION >= 3
    return module;
#endif
}

// end python bindings
