/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004a generated on 2024-12-13 18:38:52.452532
/// Generated using solver transform6d
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp

#include "Python.h"

#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
// #define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
// IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x1000004a);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan std::isnan
#endif
#ifndef isinf
#define isinf std::isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64,x65,x66,x67,x68;
x0=IKcos(j[1]);
x1=IKcos(j[2]);
x2=IKsin(j[3]);
x3=IKcos(j[3]);
x4=IKsin(j[1]);
x5=IKsin(j[2]);
x6=IKsin(j[4]);
x7=IKcos(j[4]);
x8=IKsin(j[5]);
x9=IKcos(j[5]);
x10=IKsin(j[6]);
x11=IKcos(j[6]);
x12=IKsin(j[0]);
x13=IKcos(j[0]);
x14=((0.27900001)*x5);
x15=((0.4)*x8);
x16=((1.0)*x5);
x17=((1.0)*x2);
x18=((0.4)*x9);
x19=((1.0)*x3);
x20=((0.4)*x7);
x21=((1.0)*x4);
x22=((1.0)*x7);
x23=((0.27900001)*x2);
x24=(x13*x4);
x25=(x1*x12);
x26=(x12*x5);
x27=(x0*x6);
x28=(x0*x1);
x29=(x1*x13);
x30=((-1.0)*x7);
x31=(x0*x12);
x32=(x13*x5);
x33=((-1.0)*x2);
x34=((-1.0)*x6);
x35=(x0*x13);
x36=(x17*x4);
x37=(x12*x16);
x38=(x3*x31);
x39=(x3*x35);
x40=(x16*x27);
x41=(x29+(((-1.0)*x37*x4)));
x42=(x32+((x25*x4)));
x43=((((-1.0)*x19*x28))+x36);
x44=((((-1.0)*x21*x29))+x37);
x45=(((x19*x4))+((x17*x28)));
x46=((-1.0)*x45);
x47=((((-1.0)*x21*x25))+(((-1.0)*x13*x16)));
x48=(x41*x7);
x49=((((-1.0)*x25))+(((-1.0)*x16*x24)));
x50=(x41*x6);
x51=(x2*x44);
x52=(x49*x7);
x53=(x49*x6);
x54=(x39+x51);
x55=((((-1.0)*x0*x16*x7))+((x45*x6)));
x56=(((x2*x47))+x38);
x57=((((-1.0)*x17*x31))+(((-1.0)*x19*x42)));
x58=((((-1.0)*x17*x35))+((x19*(((((-1.0)*x1*x24))+x37)))));
x59=((((-1.0)*x17*x44))+(((-1.0)*x19*x35)));
x60=(x54*x7);
x61=(x55*x9);
x62=(x56*x7);
x63=(x58*x8);
x64=(x59*x6);
x65=(x61+((x43*x8)));
x66=(((x6*(((((-1.0)*x17*x47))+(((-1.0)*x19*x31))))))+x48);
x67=(x52+x64);
x68=(((x57*x8))+((x66*x9)));
eerot[0]=(((x11*x65))+((x10*(((((-1.0)*x22*x46))+x40)))));
eerot[1]=(((x9*(((((-1.0)*x36))+((x28*x3))))))+((x55*x8)));
eerot[2]=(((x10*x65))+((x11*(((((-1.0)*x40))+((x46*x7)))))));
eetrans[0]=((((-0.17900000508718)*x28))+((x11*((((x20*x46))+(((-0.4)*x27*x5))))))+(((-1.0)*x14*x27))+((x10*((((x18*x55))+((x15*x43))))))+((x7*(((((-0.27900001)*x3*x4))+(((-1.0)*x23*x28)))))));
eerot[3]=(((x11*x68))+((x10*((((x34*x41))+((x30*x56)))))));
eerot[4]=(((x66*x8))+((x9*((((x3*x42))+((x2*x31)))))));
eerot[5]=(((x11*((x50+x62))))+((x10*x68)));
eetrans[1]=(((x6*(((((-1.0)*x12*x14*x4))+(((0.27900001)*x29))))))+(((-0.17900000508718)*x25*x4))+((x10*((((x15*x57))+((x18*((((x6*(((((-1.0)*x38))+((x33*x47))))))+x48))))))))+((x7*(((((0.27900001)*x38))+((x23*x47))))))+(((-0.17900000508718)*x32))+((x11*((((x20*x56))+(((0.4)*x50))))))+(((-0.07075)*x12)));
eerot[6]=((((-1.0)*x11*(((((1.0)*x9*((((x6*(((((-1.0)*x39))+((x33*x44))))))+x52))))+(((1.0)*x63))))))+((x10*((x53+x60)))));
eerot[7]=(((x8*(((((-1.0)*x22*x49))+(((-1.0)*x64))))))+((x58*x9)));
eerot[8]=(((x11*((((x34*x49))+((x30*x54))))))+((x10*(((((-1.0)*x67*x9))+(((-1.0)*x63)))))));
eetrans[2]=((0.07075)+((x11*(((((-0.4)*x53))+(((-0.4)*x60))))))+(((0.17900000508718)*x1*x24))+(((0.07075)*x13))+((x7*(((((-0.27900001)*x51))+(((-0.27900001)*x39))))))+(((-0.17900000508718)*x26))+((x10*(((((-1.0)*x18*x67))+(((-1.0)*x15*x58))))))+((x6*((((x14*x24))+(((0.27900001)*x25)))))));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {2}; return freeparams; }
IKFAST_API int GetNumJoints() { return 7; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,j2,cj2,sj2,htj2,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6,_ij2[2], _nj2;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1;  _ij2[0] = -1; _ij2[1] = -1; _nj2 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j2=pfree[0]; cj2=cos(pfree[0]); sj2=sin(pfree[0]), htj2=tan(pfree[0]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((-1.0)*r22);
new_r01=((-1.0)*r20);
new_r02=((-1.0)*r21);
new_px=((0.07075)+(((-1.0)*pz))+(((0.4)*r22)));
new_r10=r12;
new_r11=r10;
new_r12=r11;
new_py=((((-0.4)*r12))+py);
new_r20=r02;
new_r21=r00;
new_r22=r01;
new_pz=(px+(((-0.4)*r02)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x69=((1.0)*px);
IkReal x70=((1.0)*pz);
IkReal x71=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x71))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x70)));
rxp0_2=((((-1.0)*r10*x69))+((py*r00)));
rxp1_0=((((-1.0)*r21*x71))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x70)));
rxp1_2=((((-1.0)*r11*x69))+((py*r01)));
rxp2_0=((((-1.0)*r22*x71))+((pz*r12)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x70)));
rxp2_2=((((-1.0)*r12*x69))+((py*r02)));
IkReal op[8+1], zeror[8];
int numroots;
IkReal x72=((0.17900000508718)*cj2);
IkReal x73=((0.27900001)*r20);
IkReal x74=((1.0)*pz);
IkReal x75=((1.0)*pp);
IkReal x76=((0.55800002)*npx);
IkReal x77=((-0.0407944412587896)+(((-1.0)*x75))+x76);
IkReal x78=((-0.0407944412587896)+(((-1.0)*x75))+(((-1.0)*x76)));
IkReal x79=(x73+x72);
IkReal x80=((((-1.0)*x72))+(((-1.0)*x74))+x73);
IkReal x81=((((-1.0)*x74))+x79);
IkReal x82=((((-1.0)*x73))+(((-1.0)*x74))+x72);
IkReal x83=((((-1.0)*x74))+(((-1.0)*x79)));
IkReal gconst0=x80;
IkReal gconst1=x83;
IkReal gconst2=x77;
IkReal gconst3=x78;
IkReal gconst4=x80;
IkReal gconst5=x83;
IkReal gconst6=x77;
IkReal gconst7=x78;
IkReal gconst8=x81;
IkReal gconst9=x82;
IkReal gconst10=x77;
IkReal gconst11=x78;
IkReal gconst12=x81;
IkReal gconst13=x82;
IkReal gconst14=x77;
IkReal gconst15=x78;
IkReal x84=r21*r21;
IkReal x85=cj2*cj2;
IkReal x86=npy*npy;
IkReal x87=(gconst0*gconst11);
IkReal x88=(gconst5*gconst6);
IkReal x89=((1.0)*gconst12);
IkReal x90=(gconst1*gconst6);
IkReal x91=(gconst10*gconst9);
IkReal x92=(gconst13*gconst14);
IkReal x93=(gconst14*gconst5);
IkReal x94=(npy*r21);
IkReal x95=((0.0630910709077053)*cj2);
IkReal x96=((1.0)*gconst2);
IkReal x97=((0.0157727677269263)*cj2);
IkReal x98=(gconst4*gconst9);
IkReal x99=((0.622728044640001)*gconst11);
IkReal x100=(gconst0*gconst3);
IkReal x101=(gconst1*gconst10);
IkReal x102=(gconst11*gconst8);
IkReal x103=(gconst14*gconst9);
IkReal x104=((0.622728044640001)*gconst6);
IkReal x105=((1.0)*gconst13);
IkReal x106=(gconst1*gconst14);
IkReal x107=((0.050657001439672)*cj2);
IkReal x108=(gconst1*gconst7);
IkReal x109=((1.24545608928)*gconst12);
IkReal x110=(gconst12*gconst8);
IkReal x111=(gconst1*gconst12);
IkReal x112=(gconst13*gconst8);
IkReal x113=(gconst12*gconst7);
IkReal x114=(gconst0*gconst4);
IkReal x115=((1.24545608928)*gconst4);
IkReal x116=(gconst3*gconst8);
IkReal x117=(gconst12*gconst9);
IkReal x118=(gconst15*gconst4);
IkReal x119=(gconst1*gconst2);
IkReal x120=(gconst13*gconst6);
IkReal x121=(gconst6*gconst9);
IkReal x122=((0.0315455354538526)*cj2);
IkReal x123=(gconst4*gconst7);
IkReal x124=(gconst1*gconst4);
IkReal x125=(gconst2*gconst9);
IkReal x126=((0.31136402232)*gconst11);
IkReal x127=(gconst12*gconst15);
IkReal x128=(gconst15*gconst2);
IkReal x129=((0.622728044640001)*gconst3);
IkReal x130=(gconst13*x107);
IkReal x131=(gconst14*x84);
IkReal x132=((2.49091217856)*x86);
IkReal x133=((1.0)*x123);
IkReal x134=(gconst5*x107);
IkReal x135=(gconst3*x84);
IkReal x136=((0.00256613179485893)*x85);
IkReal x137=(gconst6*x84);
IkReal x138=(gconst11*x84);
IkReal x139=(gconst1*x86);
IkReal x140=(gconst9*x136);
IkReal x141=(x84*x85);
IkReal x142=(gconst12*x94*x99);
IkReal x143=((0.622728044640001)*x103*x94);
IkReal x144=(x126*x131);
IkReal x145=(gconst9*x109*x86);
IkReal x146=(gconst9*x122*x94);
IkReal x147=(gconst12*x122*x94);
IkReal x148=(x131*x97);
IkReal x149=(x138*x97);
IkReal x150=(gconst4*x94*x99);
IkReal x151=(gconst12*x129*x94);
IkReal x152=((0.622728044640001)*x106*x94);
IkReal x153=(gconst9*x104*x94);
IkReal x154=((1.24545608928)*x86*x98);
IkReal x155=(x109*x139);
IkReal x156=((0.000799001117450518)*x141);
IkReal x157=(x126*x137);
IkReal x158=((0.31136402232)*gconst3*x131);
IkReal x159=(gconst4*x122*x94);
IkReal x160=(gconst1*x122*x94);
IkReal x161=(x137*x97);
IkReal x162=(x135*x97);
IkReal x163=(gconst4*x129*x94);
IkReal x164=((0.622728044640001)*x90*x94);
IkReal x165=((0.31136402232)*gconst6*x135);
IkReal x166=(x115*x139);
IkReal x167=(x146+x147);
IkReal x168=(x144+x145);
IkReal x169=(x166+x165);
IkReal x170=(x163+x164);
IkReal x171=(x148+x149);
IkReal x172=(x162+x161);
IkReal x173=(x142+x143);
IkReal x174=(x160+x159);
IkReal x175=(x153+x152+x151+x150);
IkReal x176=(x157+x156+x155+x154+x158);
op[0]=((((-1.0)*x168))+(((-1.0)*x91*x92))+((x102*x92))+x173+((x127*x91))+(((-1.0)*gconst15*x102*x89)));
op[1]=(((gconst8*x107*x92))+((gconst15*x107*x117))+(((-1.0)*x171))+((x102*x130))+((gconst12*x107*x91))+x167+(((-1.0)*gconst15*x107*x110))+(((-1.0)*gconst9*x107*x92))+(((-1.0)*x130*x91))+(((-1.0)*gconst12*x102*x107)));
op[2]=(((x113*x91))+(((-1.0)*gconst15*x116*x89))+((x112*x136))+((x117*x128))+((x101*x127))+(((-1.0)*gconst9*x92*x96))+((x87*x92))+((x117*x136))+(((1.24545608928)*x103*x94))+(((-1.0)*x176))+(((-1.0)*x91*x93))+(((-1.0)*x102*x118))+(((-1.0)*x110*x136))+((gconst11*x109*x94))+((x102*x93))+((x102*x120))+(((-1.0)*x117*x132))+(((-1.0)*x101*x92))+(((-1.0)*gconst6*x105*x91))+x175+(((-1.0)*gconst7*x102*x89))+((x118*x91))+(((-1.0)*gconst13*x140))+(((-1.0)*gconst15*x87*x89))+((x116*x92))+(((-1.0)*x131*x99)));
op[3]=((((-1.0)*x122*x138))+(((-1.0)*x122*x131))+(((-1.0)*gconst7*x107*x110))+(((-1.0)*x101*x130))+((gconst8*x107*x93))+(((-1.0)*gconst0*x107*x127))+((gconst15*x107*x111))+(((-1.0)*x172))+((x102*x134))+((gconst12*x94*x95))+((gconst3*x107*x112))+x174+((gconst2*x107*x117))+((gconst9*x94*x95))+((gconst12*x101*x107))+(((-1.0)*x125*x130))+(((-1.0)*gconst9*x107*x93))+((x130*x87))+((gconst15*x107*x98))+(((-1.0)*gconst9*x107*x120))+(((-1.0)*gconst1*x107*x92))+(((-1.0)*gconst3*x107*x110))+(((-1.0)*gconst8*x107*x118))+((gconst4*x107*x91))+(((-1.0)*gconst4*x102*x107))+(((-1.0)*x134*x91))+(((-1.0)*gconst12*x107*x87))+((gconst6*x107*x112))+((gconst9*x107*x113))+((gconst0*x107*x92)));
op[4]=(((x111*x136))+(((-1.0)*gconst7*x116*x89))+(((-1.0)*gconst9*x120*x96))+((x87*x93))+(((-1.0)*gconst0*gconst12*x136))+((x111*x128))+((x100*x92))+(((-1.0)*x169))+(((-1.0)*x168))+(((-1.0)*x111*x132))+((x102*x88))+((gconst11*x115*x94))+((x136*x98))+(((-1.0)*gconst15*x100*x89))+((gconst5*gconst8*x136))+(((-1.0)*x101*x93))+(((-1.0)*x116*x118))+((x113*x125))+x170+x173+(((-1.0)*gconst5*x140))+(((-1.0)*gconst1*x92*x96))+((gconst0*gconst13*x136))+(((-1.0)*gconst10*x105*x90))+(((-1.0)*x88*x91))+(((1.24545608928)*x106*x94))+((gconst3*gconst6*x112))+(((-1.0)*x137*x99))+(((-1.0)*x132*x98))+(((1.24545608928)*x121*x94))+(((-1.0)*gconst9*x93*x96))+(((-1.0)*x129*x131))+(((-1.0)*gconst7*x87*x89))+(((-0.00159800223490104)*x141))+((x101*x118))+((x101*x113))+(((-1.0)*gconst1*gconst13*x136))+((x116*x93))+((x128*x98))+((gconst3*x109*x94))+(((-1.0)*gconst4*gconst8*x136))+((x120*x87))+((x123*x91))+(((-1.0)*x102*x133))+(((-1.0)*x118*x87)));
op[5]=(((gconst8*x107*x88))+(((-1.0)*x122*x137))+(((-1.0)*x122*x135))+(((-1.0)*x101*x134))+((gconst4*x101*x107))+(((-1.0)*gconst4*x107*x116))+(((-1.0)*x171))+(((-1.0)*gconst4*x107*x87))+((gconst7*x107*x98))+((gconst0*x107*x120))+((gconst4*x94*x95))+((gconst2*x107*x98))+x167+((gconst2*x107*x111))+(((-1.0)*gconst15*x107*x114))+(((-1.0)*gconst8*x107*x123))+(((-1.0)*x125*x134))+((x116*x134))+(((-1.0)*gconst9*x107*x88))+((gconst1*x94*x95))+(((-1.0)*gconst1*x107*x93))+((gconst12*x107*x108))+(((-1.0)*x130*x90))+((x100*x130))+((x134*x87))+(((-1.0)*x119*x130))+(((-1.0)*gconst12*x100*x107))+((gconst0*x107*x93))+((gconst1*x107*x118))+(((-1.0)*gconst0*x107*x113)));
op[6]=((((1.24545608928)*x90*x94))+((x101*x123))+((gconst0*gconst5*x136))+((x100*x93))+(((-1.0)*x104*x135))+(((-1.0)*x176))+((gconst12*gconst2*x108))+(((-1.0)*gconst9*x88*x96))+(((-1.0)*x101*x88))+(((-1.0)*x116*x133))+(((-1.0)*x124*x132))+x175+(((-1.0)*gconst1*gconst5*x136))+((x124*x136))+(((-1.0)*x133*x87))+(((-1.0)*gconst7*x100*x89))+(((-1.0)*x114*x136))+(((-1.0)*gconst13*x90*x96))+(((-1.0)*x100*x118))+(((-1.0)*gconst1*x93*x96))+((x116*x88))+((gconst3*x115*x94))+((x118*x119))+((gconst2*gconst7*x98))+((x100*x120))+((x87*x88)));
op[7]=((((-1.0)*gconst7*x107*x114))+(((-1.0)*gconst4*x100*x107))+(((-1.0)*x172))+((gconst4*x107*x108))+((gconst4*x107*x119))+x174+(((-1.0)*gconst1*x107*x88))+((x100*x134))+((gconst0*x107*x88))+(((-1.0)*x119*x134)));
op[8]=((((-1.0)*x169))+((x100*x88))+(((-1.0)*gconst1*x88*x96))+x170+((gconst2*gconst4*x108))+(((-1.0)*x100*x133)));
polyroots8(op,zeror,numroots);
IkReal j1array[8], cj1array[8], sj1array[8], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[8]={true,true,true,true,true,true,true,true};
_nj1 = 8;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j6eval[3];
IkReal x177=(npy*r20);
IkReal x178=((100000000.0)*pz);
IkReal x179=((50000000.0)*pp);
IkReal x180=(npx*r21);
IkReal x181=((1266425.0359918)*cj2*sj1);
IkReal x182=((17900000.508718)*cj1*cj2);
j6eval[0]=((((-1.0)*x180))+x177);
j6eval[1]=((IKabs(((((-2039722.06293948)*r21))+((r21*x181))+(((-1.0)*r21*x179))+((npy*x182))+((npy*x178)))))+(IKabs((((r20*x181))+(((-2039722.06293948)*r20))+(((-1.0)*r20*x179))+((npx*x182))+((npx*x178))))));
j6eval[2]=IKsign(((((27900001.0)*x177))+(((-27900001.0)*x180))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r21))+(IKabs(r20)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[2];
IkReal x183=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x183);
rxp1_0=(pz*r11);
rxp1_1=(r01*x183);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x184=r00*r00;
IkReal x185=((0.15568201116)*pp);
IkReal x186=((0.0407944412587896)*r10);
IkReal x187=(px*r01);
IkReal x188=(py*r11);
IkReal x189=(py*x184);
IkReal x190=((0.00394319193173158)*cj2*sj1);
IkReal x191=((1.0)*pp*r10);
IkReal x192=(px*r00*r10);
IkReal x193=((0.025328500719836)*cj2*r10*sj1);
j6eval[0]=0;
j6eval[1]=((((6.42334970205558)*(IKabs(((((-1.0)*py*x190))+(((-0.00635096065931685)*x189))+(((-1.0)*x190*x192))+((x189*x190))+((x185*x192))+(((-1.0)*x185*x189))+(((0.00635096065931685)*py))+(((0.00635096065931685)*x192))+((py*x185)))))))+(IKabs(((((-1.0)*x188*x191))+(((-1.0)*x186*x187))+(((-1.0)*x186*x188))+((x187*x193))+((x188*x193))+(((-1.0)*x187*x191))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
IkReal x194=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x194);
rxp1_0=(pz*r11);
rxp1_1=(r01*x194);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x195=r00*r00;
IkReal x196=((0.00635096065931685)*px);
IkReal x197=(py*r01);
IkReal x198=((1.0)*pp);
IkReal x199=(cj2*sj1);
IkReal x200=((0.00394319193173158)*px);
IkReal x201=(px*r00*r01);
IkReal x202=((0.15568201116)*pp*px);
j6eval[0]=0;
j6eval[1]=((IKabs(((((-0.0407944412587896)*x201))+(((0.025328500719836)*x199*x201))+(((-1.0)*x198*x201))+(((-0.0407944412587896)*r10*x197))+(((-1.0)*r10*x197*x198))+(((0.025328500719836)*r10*x197*x199)))))+(((6.42334970205558)*(IKabs(((((0.00394319193173158)*r11*x197*x199))+((x195*x202))+(((-1.0)*x196))+(((-1.0)*x202))+(((-1.0)*x195*x199*x200))+((x195*x196))+(((-0.00635096065931685)*r11*x197))+(((-0.15568201116)*pp*r11*x197))+((x199*x200))))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
IkReal x203=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x203);
rxp1_0=(pz*r11);
rxp1_1=(r01*x203);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x204=py*py;
IkReal x205=((2.0)*px*py);
j6eval[0]=(pp+(((-1.0)*(pz*pz))));
j6eval[1]=(((r01*r11*x205))+((x204*(r11*r11)))+(px*px)+(((-1.0)*x204*(r00*r00)))+x204+((r00*r10*x205)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
IkReal x206=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x206);
rxp1_0=(pz*r11);
rxp1_1=(r01*x206);
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
px=0;
py=0;
pp=pz*pz;
rxp0_2=0;
rxp1_2=0;
IkReal x207=pz*pz;
IkReal x208=(r00*r11);
IkReal x209=(r01*r10);
IkReal x210=((0.31136402232)*x207);
IkReal x211=((0.00788638386346316)*cj2*sj1);
IkReal x212=((((0.0127019213186337)*x208))+((x208*x210))+((x209*x211)));
IkReal x213=((((0.0127019213186337)*x209))+((x208*x211))+((x209*x210)));
j0eval[0]=((IKabs((x213+(((-1.0)*x212)))))+(((2.0)*(IKabs((x212+(((-1.0)*x213))))))));
if( IKabs(j0eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j0, j6]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j0evalpoly[1];
IkReal x214=pz*pz;
IkReal x215=(r00*r11);
IkReal x216=(r01*r10);
IkReal x217=((0.31136402232)*x214);
IkReal x218=((0.00788638386346316)*cj2*sj1);
IkReal x219=(((x216*x217))+((x215*x218))+(((0.0127019213186337)*x216)));
IkReal x220=(((x216*x218))+((x215*x217))+(((0.0127019213186337)*x215)));
IkReal x221=(x220+(((-1.0)*x219)));
IkReal x222=(x219+(((-1.0)*x220)));
op[0]=x221;
op[1]=0;
op[2]=x221;
op[3]=0;
op[4]=x222;
op[5]=0;
op[6]=x222;
polyroots6(op,zeror,numroots);
IkReal j0array[6], cj0array[6], sj0array[6], tempj0array[1];
int numsolutions = 0;
for(int ij0 = 0; ij0 < numroots; ++ij0)
{
IkReal htj0 = zeror[ij0];
tempj0array[0]=((2.0)*(atan(htj0)));
for(int kj0 = 0; kj0 < 1; ++kj0)
{
j0array[numsolutions] = tempj0array[kj0];
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
numsolutions++;
}
}
bool j0valid[6]={true,true,true,true,true,true};
_nj0 = 6;
for(int ij0 = 0; ij0 < numsolutions; ++ij0)
    {
if( !j0valid[ij0] )
{
    continue;
}
    j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
htj0 = IKtan(j0/2);

IkReal x223=pz*pz;
IkReal x224=(r00*r11);
IkReal x225=(r01*r10);
IkReal x226=((0.0127019213186337)*x225);
IkReal x227=((0.31136402232)*x223);
IkReal x228=((0.00788638386346316)*cj2*sj1);
IkReal x229=(x224*x228);
IkReal x230=(x225*x227);
IkReal x231=(((x224*x227))+((x225*x228))+(((0.0127019213186337)*x224)));
IkReal x232=(x229+x226+x230);
IkReal x233=((((-1.0)*x232))+x231);
j0evalpoly[0]=(((x233*(htj0*htj0*htj0*htj0*htj0*htj0)))+(((-1.0)*x231))+x232+((x233*(htj0*htj0*htj0*htj0)))+(((htj0*htj0)*(((((-1.0)*x231))+x232)))));
if( IKabs(j0evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < numsolutions; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
{
IkReal j6eval[2];
IkReal x234=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x234);
rxp1_0=(pz*r11);
rxp1_1=(r01*x234);
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
px=0;
py=0;
pp=pz*pz;
rxp0_2=0;
rxp1_2=0;
j6eval[0]=r22;
j6eval[1]=IKsign(r22);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
IkReal x235=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x235);
rxp1_0=(pz*r11);
rxp1_1=(r01*x235);
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
px=0;
py=0;
pp=pz*pz;
rxp0_2=0;
rxp1_2=0;
IkReal x236=(cj0*r22);
j6eval[0]=x236;
j6eval[1]=IKsign(x236);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
IkReal x237=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x237);
rxp1_0=(pz*r11);
rxp1_1=(r01*x237);
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
px=0;
py=0;
pp=pz*pz;
rxp0_2=0;
rxp1_2=0;
IkReal x238=(r22*sj0);
j6eval[0]=x238;
j6eval[1]=IKsign(x238);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j0))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
IkReal x239=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x239);
rxp1_0=(pz*r11);
rxp1_1=(r01*x239);
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
px=0;
py=0;
pp=pz*pz;
rxp0_2=0;
rxp1_2=0;
sj0=0;
cj0=1.0;
j0=0;
j6eval[0]=r22;
j6eval[1]=((4.02349648299051)+(((1558.76639228497)*(pz*pz*pz*pz)))+(sj2*sj2)+(((158.388018450417)*(pz*pz))));
j6eval[2]=IKsign(r22);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x240=pz*pz;
IkReal x241=((5.0e+15)*sj2);
IkReal x242=((1.9740607844523e+17)*x240);
CheckValue<IkReal> x243 = IKatan2WithCheck(IkReal(((((1.00293275983369e+16)*r10))+(((-1.0)*r00*x241))+((r10*x242)))),IkReal(((((1.00293275983369e+16)*r11))+(((-1.0)*r01*x241))+((r11*x242)))),IKFAST_ATAN2_MAGTHRESH);
if(!x243.valid){
continue;
}
CheckValue<IkReal> x244=IKPowWithIntegerCheck(IKsign(r22),-1);
if(!x244.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x243.value)+(((1.5707963267949)*(x244.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x245=IKcos(j6);
IkReal x246=IKsin(j6);
IkReal x247=pz*pz;
IkReal x248=(r00*x245);
IkReal x249=(r01*x246);
evalcond[0]=((((-0.27900001)*r11*x246))+(((0.27900001)*r10*x245))+(((-0.17900000508718)*sj2)));
evalcond[1]=((-0.359049938224661)+(((-0.27900001)*x249))+(((-7.06713780918728)*x247))+(((0.27900001)*x248)));
evalcond[2]=((-0.0508055662587896)+(((-1.0)*x247))+(((-0.039478501415)*x249))+(((0.039478501415)*x248)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
IkReal x1014=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1014);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1014);
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
px=0;
py=0;
pp=pz*pz;
rxp0_2=0;
rxp1_2=0;
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
j6eval[0]=r22;
j6eval[1]=IKsign(r22);
j6eval[2]=((4.02349648299051)+(((1558.76639228497)*(pz*pz*pz*pz)))+(sj2*sj2)+(((158.388018450417)*(pz*pz))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1015=pz*pz;
IkReal x1016=((5.0e+15)*sj2);
IkReal x1017=((1.9740607844523e+17)*x1015);
CheckValue<IkReal> x1018 = IKatan2WithCheck(IkReal(((((-1.00293275983369e+16)*r10))+((r00*x1016))+(((-1.0)*r10*x1017)))),IkReal(((((-1.00293275983369e+16)*r11))+(((-1.0)*r11*x1017))+((r01*x1016)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1018.valid){
continue;
}
CheckValue<IkReal> x1019=IKPowWithIntegerCheck(IKsign(r22),-1);
if(!x1019.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1018.value)+(((1.5707963267949)*(x1019.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1020=IKcos(j6);
IkReal x1021=IKsin(j6);
IkReal x1022=pz*pz;
IkReal x1023=(r00*x1020);
IkReal x1024=(r01*x1021);
evalcond[0]=((((0.17900000508718)*sj2))+(((0.27900001)*r10*x1020))+(((-0.27900001)*r11*x1021)));
evalcond[1]=((0.359049938224661)+(((7.06713780918728)*x1022))+(((0.27900001)*x1023))+(((-0.27900001)*x1024)));
evalcond[2]=((-0.0508055662587896)+(((-1.0)*x1022))+(((0.039478501415)*x1024))+(((-0.039478501415)*x1023)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
IkReal x1025=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1025);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1025);
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
px=0;
py=0;
pp=pz*pz;
rxp0_2=0;
rxp1_2=0;
sj0=1.0;
cj0=0;
j0=1.5707963267949;
j6eval[0]=r22;
j6eval[1]=((4.02349648299051)+(((1558.76639228497)*(pz*pz*pz*pz)))+(sj2*sj2)+(((158.388018450417)*(pz*pz))));
j6eval[2]=IKsign(r22);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1026=pz*pz;
IkReal x1027=((5.0e+15)*sj2);
IkReal x1028=((1.9740607844523e+17)*x1026);
CheckValue<IkReal> x1029 = IKatan2WithCheck(IkReal(((((-1.0)*r00*x1028))+(((-1.0)*r10*x1027))+(((-1.00293275983369e+16)*r00)))),IkReal(((((-1.0)*r11*x1027))+(((-1.0)*r01*x1028))+(((-1.00293275983369e+16)*r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1029.valid){
continue;
}
CheckValue<IkReal> x1030=IKPowWithIntegerCheck(IKsign(r22),-1);
if(!x1030.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1029.value)+(((1.5707963267949)*(x1030.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1031=IKcos(j6);
IkReal x1032=IKsin(j6);
IkReal x1033=pz*pz;
IkReal x1034=(r10*x1031);
IkReal x1035=((0.27900001)*x1032);
evalcond[0]=((((0.17900000508718)*sj2))+(((-1.0)*r01*x1035))+(((0.27900001)*r00*x1031)));
evalcond[1]=((-0.359049938224661)+(((-7.06713780918728)*x1033))+(((0.27900001)*x1034))+(((-1.0)*r11*x1035)));
evalcond[2]=((-0.0508055662587896)+(((-1.0)*x1033))+(((0.039478501415)*x1034))+(((-0.039478501415)*r11*x1032)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
IkReal x1036=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1036);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1036);
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
px=0;
py=0;
pp=pz*pz;
rxp0_2=0;
rxp1_2=0;
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
j6eval[0]=r22;
j6eval[1]=((4.02349648299051)+(((1558.76639228497)*(pz*pz*pz*pz)))+(sj2*sj2)+(((158.388018450417)*(pz*pz))));
j6eval[2]=IKsign(r22);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1037=pz*pz;
IkReal x1038=((5.0e+15)*sj2);
IkReal x1039=((1.9740607844523e+17)*x1037);
CheckValue<IkReal> x1040 = IKatan2WithCheck(IkReal((((r10*x1038))+((r00*x1039))+(((1.00293275983369e+16)*r00)))),IkReal(((((1.00293275983369e+16)*r01))+((r11*x1038))+((r01*x1039)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1040.valid){
continue;
}
CheckValue<IkReal> x1041=IKPowWithIntegerCheck(IKsign(r22),-1);
if(!x1041.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1040.value)+(((1.5707963267949)*(x1041.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1042=IKcos(j6);
IkReal x1043=IKsin(j6);
IkReal x1044=pz*pz;
IkReal x1045=(r10*x1042);
IkReal x1046=((0.27900001)*x1043);
evalcond[0]=((((-1.0)*r01*x1046))+(((0.27900001)*r00*x1042))+(((-0.17900000508718)*sj2)));
evalcond[1]=((0.359049938224661)+(((-1.0)*r11*x1046))+(((7.06713780918728)*x1044))+(((0.27900001)*x1045)));
evalcond[2]=((-0.0508055662587896)+(((-0.039478501415)*x1045))+(((0.039478501415)*r11*x1043))+(((-1.0)*x1044)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1047=cj0*cj0;
IkReal x1048=((551375702416494.0)*r01);
IkReal x1049=(cj0*sj0);
IkReal x1050=((551375702416494.0)*r00);
IkReal x1051=((1.39500005e+15)*r00);
IkReal x1052=(cj2*sj1);
IkReal x1053=((1.39500005e+15)*sj2);
IkReal x1054=((1.39500005e+15)*r01);
IkReal x1055=(r11*x1053);
CheckValue<IkReal> x1056 = IKatan2WithCheck(IkReal(((((-1.39500005e+15)*r10*x1049*x1052))+x1050+((sj2*x1049*x1051))+((x1051*x1052))+((r10*x1053))+(((-1.0)*r10*x1047*x1053))+(((-1.0)*x1047*x1051*x1052))+(((-551375702416494.0)*r10*x1049))+(((-1.0)*x1047*x1050)))),IkReal((((r01*x1049*x1053))+x1055+x1048+((x1052*x1054))+(((-1.0)*x1047*x1052*x1054))+(((-1.39500005e+15)*r11*x1049*x1052))+(((-551375702416494.0)*r11*x1049))+(((-1.0)*x1047*x1048))+(((-1.0)*x1047*x1055)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1056.valid){
continue;
}
CheckValue<IkReal> x1057=IKPowWithIntegerCheck(IKsign((r22*sj0)),-1);
if(!x1057.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1056.value)+(((-1.5707963267949)*(x1057.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x1058=IKcos(j6);
IkReal x1059=IKsin(j6);
IkReal x1060=((0.17900000508718)*cj0);
IkReal x1061=(cj2*sj1);
IkReal x1062=((0.039478501415)*cj0);
IkReal x1063=((0.27900001)*r01);
IkReal x1064=((0.17900000508718)*sj0);
IkReal x1065=((0.27900001)*sj0);
IkReal x1066=((0.27900001)*cj0);
IkReal x1067=(sj0*x1059);
IkReal x1068=(r00*x1058);
IkReal x1069=(r11*x1059);
IkReal x1070=(r10*x1058);
evalcond[0]=((((-1.0)*x1060*x1061))+(((0.27900001)*x1068))+(((-0.07075)*cj0))+((sj2*x1064))+(((-1.0)*x1059*x1063)));
evalcond[1]=((((0.27900001)*x1070))+(((-0.07075)*sj0))+(((-0.27900001)*x1069))+(((-1.0)*sj2*x1060))+(((-1.0)*x1061*x1064)));
evalcond[2]=(((x1066*x1070))+(((-1.0)*x1066*x1069))+((x1063*x1067))+(((-1.0)*x1065*x1068))+(((-0.17900000508718)*sj2)));
evalcond[3]=((-0.07075)+(((-1.0)*cj0*x1059*x1063))+((x1066*x1068))+(((-0.17900000508718)*x1061))+(((-1.0)*x1065*x1069))+((x1065*x1070)));
evalcond[4]=((-0.0508055662587896)+(((-1.0)*r01*x1059*x1062))+(((-0.039478501415)*r11*x1067))+(((0.039478501415)*sj0*x1070))+((x1062*x1068))+(((-1.0)*(pz*pz))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1071=cj0*cj0;
IkReal x1072=(cj0*sj0);
IkReal x1073=((1.39500005e+15)*sj2);
IkReal x1074=((1.39500005e+15)*cj2*sj1);
IkReal x1075=(r10*x1071);
IkReal x1076=(r11*x1071);
CheckValue<IkReal> x1077=IKPowWithIntegerCheck(IKsign((cj0*r22)),-1);
if(!x1077.valid){
continue;
}
CheckValue<IkReal> x1078 = IKatan2WithCheck(IkReal(((((-1.0)*x1074*x1075))+(((-551375702416494.0)*x1075))+((r00*x1072*x1074))+((r10*x1072*x1073))+((r00*x1071*x1073))+(((551375702416494.0)*r00*x1072)))),IkReal(((((551375702416494.0)*r01*x1072))+((r01*x1071*x1073))+(((-1.0)*x1074*x1076))+(((-551375702416494.0)*x1076))+((r11*x1072*x1073))+((r01*x1072*x1074)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1078.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((-1.5707963267949)*(x1077.value)))+(x1078.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x1079=IKcos(j6);
IkReal x1080=IKsin(j6);
IkReal x1081=((0.17900000508718)*cj0);
IkReal x1082=(cj2*sj1);
IkReal x1083=((0.039478501415)*cj0);
IkReal x1084=((0.27900001)*r01);
IkReal x1085=((0.17900000508718)*sj0);
IkReal x1086=((0.27900001)*sj0);
IkReal x1087=((0.27900001)*cj0);
IkReal x1088=(sj0*x1080);
IkReal x1089=(r00*x1079);
IkReal x1090=(r11*x1080);
IkReal x1091=(r10*x1079);
evalcond[0]=((((-0.07075)*cj0))+((sj2*x1085))+(((-1.0)*x1081*x1082))+(((-1.0)*x1080*x1084))+(((0.27900001)*x1089)));
evalcond[1]=((((-1.0)*sj2*x1081))+(((-0.07075)*sj0))+(((0.27900001)*x1091))+(((-1.0)*x1082*x1085))+(((-0.27900001)*x1090)));
evalcond[2]=(((x1087*x1091))+(((-1.0)*x1087*x1090))+((x1084*x1088))+(((-0.17900000508718)*sj2))+(((-1.0)*x1086*x1089)));
evalcond[3]=((-0.07075)+(((-1.0)*x1086*x1090))+((x1086*x1091))+(((-1.0)*cj0*x1080*x1084))+((x1087*x1089))+(((-0.17900000508718)*x1082)));
evalcond[4]=((-0.0508055662587896)+(((-1.0)*r01*x1080*x1083))+(((-1.0)*(pz*pz)))+(((0.039478501415)*sj0*x1091))+(((-0.039478501415)*r11*x1088))+((x1083*x1089)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1092=((7075000.0)*sj0);
IkReal x1093=((17900000.508718)*sj2);
IkReal x1094=(cj0*r10);
IkReal x1095=(cj0*r11);
IkReal x1096=((17900000.508718)*cj2*sj1);
CheckValue<IkReal> x1097 = IKatan2WithCheck(IkReal(((((-1.0)*r00*sj0*x1096))+(((-1.0)*r10*sj0*x1093))+(((-1.0)*cj0*r00*x1093))+((x1094*x1096))+(((7075000.0)*x1094))+(((-1.0)*r00*x1092)))),IkReal(((((-1.0)*r11*sj0*x1093))+(((-1.0)*cj0*r01*x1093))+((x1095*x1096))+(((7075000.0)*x1095))+(((-1.0)*r01*sj0*x1096))+(((-1.0)*r01*x1092)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1097.valid){
continue;
}
CheckValue<IkReal> x1098=IKPowWithIntegerCheck(IKsign(r22),-1);
if(!x1098.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1097.value)+(((1.5707963267949)*(x1098.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x1099=IKcos(j6);
IkReal x1100=IKsin(j6);
IkReal x1101=((0.17900000508718)*cj0);
IkReal x1102=(cj2*sj1);
IkReal x1103=((0.039478501415)*cj0);
IkReal x1104=((0.27900001)*r01);
IkReal x1105=((0.17900000508718)*sj0);
IkReal x1106=((0.27900001)*sj0);
IkReal x1107=((0.27900001)*cj0);
IkReal x1108=(sj0*x1100);
IkReal x1109=(r00*x1099);
IkReal x1110=(r11*x1100);
IkReal x1111=(r10*x1099);
evalcond[0]=(((sj2*x1105))+(((-0.07075)*cj0))+(((0.27900001)*x1109))+(((-1.0)*x1100*x1104))+(((-1.0)*x1101*x1102)));
evalcond[1]=((((-0.27900001)*x1110))+(((-0.07075)*sj0))+(((0.27900001)*x1111))+(((-1.0)*sj2*x1101))+(((-1.0)*x1102*x1105)));
evalcond[2]=(((x1104*x1108))+(((-1.0)*x1107*x1110))+(((-1.0)*x1106*x1109))+((x1107*x1111))+(((-0.17900000508718)*sj2)));
evalcond[3]=((-0.07075)+(((-1.0)*cj0*x1100*x1104))+(((-0.17900000508718)*x1102))+(((-1.0)*x1106*x1110))+((x1107*x1109))+((x1106*x1111)));
evalcond[4]=((-0.0508055662587896)+(((-0.039478501415)*r11*x1108))+(((0.039478501415)*sj0*x1111))+(((-1.0)*r01*x1100*x1103))+(((-1.0)*(pz*pz)))+((x1103*x1109)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1112=((0.55800002)*px);
IkReal x1113=((0.55800002)*py);
IkReal x1114=(((r00*x1112))+((r10*x1113)));
IkReal x1115=((((-1.0)*r11*x1113))+(((-1.0)*r01*x1112)));
CheckValue<IkReal> x1118 = IKatan2WithCheck(IkReal(x1114),IkReal(x1115),IKFAST_ATAN2_MAGTHRESH);
if(!x1118.valid){
continue;
}
IkReal x1116=((1.0)*(x1118.value));
if((((x1115*x1115)+(x1114*x1114))) < -0.00001)
continue;
CheckValue<IkReal> x1119=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1115*x1115)+(x1114*x1114)))),-1);
if(!x1119.valid){
continue;
}
if( (((x1119.value)*(((-0.0407944412587896)+(((0.025328500719836)*cj2*sj1))+(((-1.0)*pp)))))) < -1-IKFAST_SINCOS_THRESH || (((x1119.value)*(((-0.0407944412587896)+(((0.025328500719836)*cj2*sj1))+(((-1.0)*pp)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1117=IKasin(((x1119.value)*(((-0.0407944412587896)+(((0.025328500719836)*cj2*sj1))+(((-1.0)*pp))))));
j6array[0]=((((-1.0)*x1117))+(((-1.0)*x1116)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+x1117+(((-1.0)*x1116)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];

{
IkReal j0eval[2];
IkReal x1120=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1120);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1120);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x1121=cj1*cj1;
IkReal x1122=cj2*cj2;
IkReal x1123=(cj2*sj1);
IkReal x1124=(x1121*x1122);
j0eval[0]=((-1.46264339650383)+(((1.26501770379633)*x1124))+(((-1.0)*x1123)));
j0eval[1]=IKsign(((-2.89055914418119e+15)+(((-1.976256927075e+15)*x1123))+(((2.5e+15)*x1124))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
IkReal x1125=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1125);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1125);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x1126=(cj6*r10);
IkReal x1127=(cj2*sj1);
IkReal x1128=(r11*sj6);
IkReal x1129=(px*sj2);
IkReal x1130=(r01*sj2*sj6);
IkReal x1131=(cj6*r00*sj2);
j0eval[0]=((((-2.53003540759265)*x1126*x1127))+x1128+(((9.06822694233112)*x1129))+(((2.53003540759265)*x1127*x1128))+(((2.53003540759265)*x1130))+(((-1.0)*x1126))+(((-2.53003540759265)*x1131))+(((3.584229262214)*py))+(((9.06822694233112)*py*x1127)));
j0eval[1]=IKsign(((((13950000.5)*x1130))+(((-5513757.02416494)*x1126))+(((50000000.0)*x1129))+(((-13950000.5)*x1131))+(((13950000.5)*x1127*x1128))+(((50000000.0)*py*x1127))+(((5513757.02416494)*x1128))+(((19762569.27075)*py))+(((-13950000.5)*x1126*x1127))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
IkReal x1132=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1132);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1132);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x1133=(cj6*r00);
IkReal x1134=((2.53003540759265)*sj6);
IkReal x1135=(cj2*sj1);
j0eval[0]=((((-9.06822694233112)*px*x1135))+x1133+(((-2.53003540759265)*cj6*r10*sj2))+(((-1.0)*r01*sj6))+(((-1.0)*r01*x1134*x1135))+((r11*sj2*x1134))+(((-3.584229262214)*px))+(((2.53003540759265)*x1133*x1135))+(((9.06822694233112)*py*sj2)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1136=cj6*cj6;
IkReal x1137=r01*r01;
IkReal x1138=(r01*sj6);
IkReal x1139=(cj6*r10);
IkReal x1140=(cj2*sj1);
IkReal x1141=((3.8966480736148e+15)*sj2);
IkReal x1142=(r11*sj6);
IkReal x1143=((77932961.472296)*py);
IkReal x1144=((4.35379660656096e+16)*px);
IkReal x1145=(cj6*r00);
IkReal x1146=(py*sj2);
IkReal x1147=((13950000.5)*sj2);
IkReal x1148=((77932961.472296)*px);
IkReal x1149=((6.07354648384237e+15)*x1137);
IkReal x1150=((21743297.0301002)*r01*r11);
CheckValue<IkReal> x1151=IKPowWithIntegerCheck(((((13950000.5)*x1140*x1145))+(((50000000.0)*x1146))+(((-13950000.5)*x1138*x1140))+(((-5513757.02416494)*x1138))+((x1142*x1147))+(((-50000000.0)*px*x1140))+(((-19762569.27075)*px))+(((5513757.02416494)*x1145))+(((-1.0)*x1139*x1147))),-1);
if(!x1151.valid){
continue;
}
CheckValue<IkReal> x1152=IKPowWithIntegerCheck(((((1.54015554957094e+15)*x1145))+((x1141*x1142))+(((-3.8966480736148e+15)*x1138*x1140))+(((-1.54015554957094e+15)*x1138))+(((1.396648005e+16)*x1146))+(((3.8966480736148e+15)*x1140*x1145))+(((-1.0)*x1139*x1141))+(((-1.396648005e+16)*px*x1140))+(((-5.52027058913346e+15)*px))),-1);
if(!x1152.valid){
continue;
}
if( IKabs(((x1151.value)*((x1150+(((-21743297.0301002)*x1142*x1145))+(((-1.0)*x1143*x1145))+((x1142*x1148))+(((-3537500.0)*sj2))+(((-21743297.0301002)*x1138*x1139))+(((279329601.0)*px*py))+(((21743297.0301002)*r00*r10*x1136))+(((-8950000.25435901)*sj2*x1140))+(((-1.0)*x1139*x1148))+(((-1.0)*x1136*x1150))+((x1138*x1143)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1152.value)*(((-2.5e+15)+(((-1.0)*x1136*x1149))+x1149+(((6.07354648384237e+15)*x1136*(r00*r00)))+(((-1.21470929676847e+16)*x1138*x1145))+(((7.80250259948192e+16)*(px*px)))+(((2.5e+15)*(cj2*cj2)))+(((-1.0)*x1144*x1145))+((x1138*x1144)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1151.value)*((x1150+(((-21743297.0301002)*x1142*x1145))+(((-1.0)*x1143*x1145))+((x1142*x1148))+(((-3537500.0)*sj2))+(((-21743297.0301002)*x1138*x1139))+(((279329601.0)*px*py))+(((21743297.0301002)*r00*r10*x1136))+(((-8950000.25435901)*sj2*x1140))+(((-1.0)*x1139*x1148))+(((-1.0)*x1136*x1150))+((x1138*x1143))))))+IKsqr(((x1152.value)*(((-2.5e+15)+(((-1.0)*x1136*x1149))+x1149+(((6.07354648384237e+15)*x1136*(r00*r00)))+(((-1.21470929676847e+16)*x1138*x1145))+(((7.80250259948192e+16)*(px*px)))+(((2.5e+15)*(cj2*cj2)))+(((-1.0)*x1144*x1145))+((x1138*x1144))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((x1151.value)*((x1150+(((-21743297.0301002)*x1142*x1145))+(((-1.0)*x1143*x1145))+((x1142*x1148))+(((-3537500.0)*sj2))+(((-21743297.0301002)*x1138*x1139))+(((279329601.0)*px*py))+(((21743297.0301002)*r00*r10*x1136))+(((-8950000.25435901)*sj2*x1140))+(((-1.0)*x1139*x1148))+(((-1.0)*x1136*x1150))+((x1138*x1143))))), ((x1152.value)*(((-2.5e+15)+(((-1.0)*x1136*x1149))+x1149+(((6.07354648384237e+15)*x1136*(r00*r00)))+(((-1.21470929676847e+16)*x1138*x1145))+(((7.80250259948192e+16)*(px*px)))+(((2.5e+15)*(cj2*cj2)))+(((-1.0)*x1144*x1145))+((x1138*x1144))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1153=IKcos(j0);
IkReal x1154=IKsin(j0);
IkReal x1155=((1.0)*px);
IkReal x1156=((1.0)*py);
IkReal x1157=(r01*sj6);
IkReal x1158=((0.55800002)*cj6);
IkReal x1159=(r11*sj6);
IkReal x1160=((0.17900000508718)*sj2);
IkReal x1161=((0.27900001)*cj6);
IkReal x1162=((0.039478501415)*x1153);
IkReal x1163=((0.27900001)*x1153);
IkReal x1164=((0.27900001)*x1154);
IkReal x1165=((0.039478501415)*x1154);
IkReal x1166=((0.17900000508718)*cj2*sj1);
evalcond[0]=((((-1.0)*x1155))+((r00*x1161))+((x1154*x1160))+(((-1.0)*x1153*x1166))+(((-0.27900001)*x1157))+(((-0.07075)*x1153)));
evalcond[1]=((((-1.0)*x1156))+((r10*x1161))+(((-1.0)*x1153*x1160))+(((-0.27900001)*x1159))+(((-0.07075)*x1154))+(((-1.0)*x1154*x1166)));
evalcond[2]=((((-1.0)*x1159*x1163))+((r10*x1153*x1161))+((x1157*x1164))+(((-1.0)*x1153*x1156))+(((-1.0)*x1160))+((px*x1154))+(((-1.0)*r00*x1154*x1161)));
evalcond[3]=((-0.07075)+(((-1.0)*x1154*x1156))+((r10*x1154*x1161))+(((-1.0)*x1159*x1164))+((r00*x1153*x1161))+(((-1.0)*x1153*x1155))+(((-1.0)*x1166))+(((-1.0)*x1157*x1163)));
evalcond[4]=((-0.0508055662587896)+(((-0.55800002)*px*x1157))+(((-1.0)*x1159*x1165))+((cj6*r10*x1165))+((px*r00*x1158))+((cj6*r00*x1162))+(((-1.0)*pp))+((py*r10*x1158))+(((-0.1415)*py*x1154))+(((-0.1415)*px*x1153))+(((-1.0)*x1157*x1162))+(((-0.55800002)*py*x1159)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1167=cj6*cj6;
IkReal x1168=r01*r01;
IkReal x1169=cj2*cj2;
IkReal x1170=(r01*sj6);
IkReal x1171=((13950000.5)*sj2);
IkReal x1172=(cj6*r00);
IkReal x1173=((155865922.944592)*px);
IkReal x1174=(cj6*r10);
IkReal x1175=(cj2*sj1);
IkReal x1176=((77932961.472296)*py);
IkReal x1177=(r01*r11);
IkReal x1178=(r11*sj6);
IkReal x1179=((77932961.472296)*px);
IkReal x1180=((21743297.0301002)*x1167);
IkReal x1181=((8950000.25435901)*x1169);
CheckValue<IkReal> x1182 = IKatan2WithCheck(IkReal(((-1398201.77590556)+(((21743297.0301002)*x1168))+(((-7075000.0)*x1175))+(((-1.0)*x1172*x1173))+(((-43486594.0602004)*x1170*x1172))+((x1181*(cj1*cj1)))+(((-1.0)*x1181))+((x1180*(r00*r00)))+((x1170*x1173))+(((-1.0)*x1168*x1180))+(((279329601.0)*(px*px))))),IkReal(((((-8950000.25435901)*sj2*x1175))+((x1174*x1179))+(((21743297.0301002)*x1172*x1178))+(((-279329601.0)*px*py))+((x1177*x1180))+(((-1.0)*x1178*x1179))+(((-3537500.0)*sj2))+(((21743297.0301002)*x1170*x1174))+((x1172*x1176))+(((-1.0)*r00*r10*x1180))+(((-1.0)*x1170*x1176))+(((-21743297.0301002)*x1177)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1182.valid){
continue;
}
CheckValue<IkReal> x1183=IKPowWithIntegerCheck(IKsign(((((-13950000.5)*x1174*x1175))+(((50000000.0)*px*sj2))+(((5513757.02416494)*x1178))+(((-1.0)*x1171*x1172))+(((-5513757.02416494)*x1174))+(((50000000.0)*py*x1175))+(((13950000.5)*x1175*x1178))+(((19762569.27075)*py))+((x1170*x1171)))),-1);
if(!x1183.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1182.value)+(((1.5707963267949)*(x1183.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1184=IKcos(j0);
IkReal x1185=IKsin(j0);
IkReal x1186=((1.0)*px);
IkReal x1187=((1.0)*py);
IkReal x1188=(r01*sj6);
IkReal x1189=((0.55800002)*cj6);
IkReal x1190=(r11*sj6);
IkReal x1191=((0.17900000508718)*sj2);
IkReal x1192=((0.27900001)*cj6);
IkReal x1193=((0.039478501415)*x1184);
IkReal x1194=((0.27900001)*x1184);
IkReal x1195=((0.27900001)*x1185);
IkReal x1196=((0.039478501415)*x1185);
IkReal x1197=((0.17900000508718)*cj2*sj1);
evalcond[0]=(((r00*x1192))+((x1185*x1191))+(((-1.0)*x1184*x1197))+(((-0.27900001)*x1188))+(((-1.0)*x1186))+(((-0.07075)*x1184)));
evalcond[1]=(((r10*x1192))+(((-0.27900001)*x1190))+(((-1.0)*x1184*x1191))+(((-1.0)*x1187))+(((-0.07075)*x1185))+(((-1.0)*x1185*x1197)));
evalcond[2]=((((-1.0)*x1190*x1194))+((x1188*x1195))+(((-1.0)*r00*x1185*x1192))+(((-1.0)*x1191))+(((-1.0)*x1184*x1187))+((px*x1185))+((r10*x1184*x1192)));
evalcond[3]=((-0.07075)+(((-1.0)*x1190*x1195))+((r00*x1184*x1192))+((r10*x1185*x1192))+(((-1.0)*x1188*x1194))+(((-1.0)*x1197))+(((-1.0)*x1184*x1186))+(((-1.0)*x1185*x1187)));
evalcond[4]=((-0.0508055662587896)+(((-1.0)*x1190*x1196))+(((-0.1415)*px*x1184))+(((-1.0)*x1188*x1193))+(((-0.1415)*py*x1185))+(((-1.0)*pp))+((cj6*r10*x1196))+(((-0.55800002)*px*x1188))+(((-0.55800002)*py*x1190))+((cj6*r00*x1193))+((px*r00*x1189))+((py*r10*x1189)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1198=(r11*sj6);
IkReal x1199=(cj6*r10);
IkReal x1200=((1.396648005e+16)*sj2);
IkReal x1201=(r01*sj6);
IkReal x1202=(cj6*r00);
IkReal x1203=((3.8966480736148e+15)*sj2);
IkReal x1204=((3.8966480736148e+15)*cj2*sj1);
IkReal x1205=(cj6*x1203);
IkReal x1206=((1.396648005e+16)*cj2*sj1);
CheckValue<IkReal> x1207 = IKatan2WithCheck(IkReal(((((-1.0)*x1199*x1204))+(((-1.54015554957094e+15)*x1199))+((x1202*x1203))+((py*x1206))+(((-1.0)*px*x1200))+(((-1.0)*x1201*x1203))+(((1.54015554957094e+15)*x1198))+(((5.52027058913346e+15)*py))+((x1198*x1204)))),IkReal(((((-1.0)*x1199*x1203))+((px*x1206))+(((-1.54015554957094e+15)*x1202))+(((1.54015554957094e+15)*x1201))+(((-1.0)*x1202*x1204))+((py*x1200))+((x1201*x1204))+(((5.52027058913346e+15)*px))+((x1198*x1203)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1207.valid){
continue;
}
CheckValue<IkReal> x1208=IKPowWithIntegerCheck(IKsign(((-2.89055914418119e+15)+(((2.5e+15)*(cj1*cj1)*(cj2*cj2)))+(((-1.976256927075e+15)*cj2*sj1)))),-1);
if(!x1208.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1207.value)+(((1.5707963267949)*(x1208.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1209=IKcos(j0);
IkReal x1210=IKsin(j0);
IkReal x1211=((1.0)*px);
IkReal x1212=((1.0)*py);
IkReal x1213=(r01*sj6);
IkReal x1214=((0.55800002)*cj6);
IkReal x1215=(r11*sj6);
IkReal x1216=((0.17900000508718)*sj2);
IkReal x1217=((0.27900001)*cj6);
IkReal x1218=((0.039478501415)*x1209);
IkReal x1219=((0.27900001)*x1209);
IkReal x1220=((0.27900001)*x1210);
IkReal x1221=((0.039478501415)*x1210);
IkReal x1222=((0.17900000508718)*cj2*sj1);
evalcond[0]=(((x1210*x1216))+(((-0.27900001)*x1213))+((r00*x1217))+(((-1.0)*x1209*x1222))+(((-0.07075)*x1209))+(((-1.0)*x1211)));
evalcond[1]=((((-1.0)*x1210*x1222))+(((-1.0)*x1209*x1216))+(((-0.27900001)*x1215))+((r10*x1217))+(((-0.07075)*x1210))+(((-1.0)*x1212)));
evalcond[2]=((((-1.0)*x1215*x1219))+(((-1.0)*x1209*x1212))+((px*x1210))+((r10*x1209*x1217))+(((-1.0)*r00*x1210*x1217))+((x1213*x1220))+(((-1.0)*x1216)));
evalcond[3]=((-0.07075)+(((-1.0)*x1209*x1211))+(((-1.0)*x1222))+((r00*x1209*x1217))+(((-1.0)*x1215*x1220))+((r10*x1210*x1217))+(((-1.0)*x1213*x1219))+(((-1.0)*x1210*x1212)));
evalcond[4]=((-0.0508055662587896)+(((-0.55800002)*px*x1213))+((px*r00*x1214))+(((-0.55800002)*py*x1215))+(((-1.0)*pp))+(((-1.0)*x1215*x1221))+(((-1.0)*x1213*x1218))+(((-0.1415)*px*x1209))+((py*r10*x1214))+((cj6*r10*x1221))+(((-0.1415)*py*x1210))+((cj6*r00*x1218)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1223=((0.15568201116)*px);
IkReal x1224=((0.55800002)*px);
IkReal x1225=(py*r11);
IkReal x1226=((0.15568201116)*r01);
IkReal x1227=(cj2*sj1);
IkReal x1228=(py*r10);
IkReal x1229=((-0.0407944412587896)+(((-1.0)*pp))+(((0.025328500719836)*x1227)));
IkReal x1230=(((r01*x1224))+(((0.55800002)*x1225)));
IkReal x1231=(((r00*x1224))+(((0.55800002)*x1228)));
IkReal x1232=((((-0.27900001)*pp*r01))+(((-0.0113816495191467)*r01))+(((0.00706665195411925)*r01*x1227)));
IkReal x1233=(((x1226*x1228))+((r00*r01*x1223)));
IkReal x1234=(((x1223*(r01*r01)))+((x1225*x1226)));
CheckValue<IkReal> x1235=IKPowWithIntegerCheck(IKsign((((x1230*x1233))+(((-1.0)*x1231*x1234)))),-1);
if(!x1235.valid){
continue;
}
CheckValue<IkReal> x1236 = IKatan2WithCheck(IkReal(((((-1.0)*x1231*x1232))+((x1229*x1233)))),IkReal(((((-1.0)*x1230*x1232))+((x1229*x1234)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1236.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1235.value)))+(x1236.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x1237=IKcos(j6);
IkReal x1238=IKsin(j6);
IkReal x1239=((0.15568201116)*py);
IkReal x1240=((0.55800002)*py);
IkReal x1241=(cj2*sj1);
IkReal x1242=((0.15568201116)*px);
IkReal x1243=((0.55800002)*px);
IkReal x1244=(r00*r11);
IkReal x1245=(r00*r10);
IkReal x1246=(r01*r10);
IkReal x1247=(r01*r11);
IkReal x1248=((0.27900001)*pp);
IkReal x1249=(r10*r11*x1239);
IkReal x1250=(r00*r01*x1242);
evalcond[0]=((-0.0407944412587896)+(((0.025328500719836)*x1241))+((x1237*((((r00*x1243))+((r10*x1240))))))+(((-1.0)*pp))+((x1238*(((((-1.0)*r11*x1240))+(((-1.0)*r01*x1243)))))));
evalcond[1]=(((x1238*((x1249+((x1242*x1246))))))+((x1237*(((((-1.0)*x1239*(r10*r10)))+(((-1.0)*x1242*x1245))))))+(((-0.00706665195411925)*r10*x1241))+(((0.0113816495191467)*r10))+((r10*x1248)));
evalcond[2]=(((x1238*(((((-1.0)*x1242*x1247))+(((-1.0)*x1239*(r11*r11)))))))+(((-0.0113816495191467)*r11))+(((0.00706665195411925)*r11*x1241))+(((-1.0)*r11*x1248))+((x1237*((x1249+((x1242*x1244)))))));
evalcond[3]=(((x1238*((x1250+((x1239*x1244))))))+((r00*x1248))+((x1237*(((((-1.0)*x1239*x1245))+(((-1.0)*x1242*(r00*r00)))))))+(((0.0113816495191467)*r00))+(((-0.00706665195411925)*r00*x1241)));
evalcond[4]=(((x1238*(((((-1.0)*x1239*x1247))+(((-1.0)*x1242*(r01*r01)))))))+(((-0.0113816495191467)*r01))+((x1237*((x1250+((x1239*x1246))))))+(((0.00706665195411925)*r01*x1241))+(((-1.0)*r01*x1248)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0eval[2];
IkReal x1251=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1251);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1251);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x1252=cj1*cj1;
IkReal x1253=cj2*cj2;
IkReal x1254=(cj2*sj1);
IkReal x1255=(x1252*x1253);
j0eval[0]=((-1.46264339650383)+(((1.26501770379633)*x1255))+(((-1.0)*x1254)));
j0eval[1]=IKsign(((-2.89055914418119e+15)+(((2.5e+15)*x1255))+(((-1.976256927075e+15)*x1254))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
IkReal x1256=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1256);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1256);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x1257=(cj6*r10);
IkReal x1258=(cj2*sj1);
IkReal x1259=(r11*sj6);
IkReal x1260=(px*sj2);
IkReal x1261=(r01*sj2*sj6);
IkReal x1262=(cj6*r00*sj2);
j0eval[0]=(x1259+(((2.53003540759265)*x1258*x1259))+(((9.06822694233112)*py*x1258))+(((-2.53003540759265)*x1262))+(((-2.53003540759265)*x1257*x1258))+(((9.06822694233112)*x1260))+(((-1.0)*x1257))+(((2.53003540759265)*x1261))+(((3.584229262214)*py)));
j0eval[1]=IKsign(((((-5513757.02416494)*x1257))+(((-13950000.5)*x1257*x1258))+(((13950000.5)*x1261))+(((5513757.02416494)*x1259))+(((13950000.5)*x1258*x1259))+(((19762569.27075)*py))+(((50000000.0)*x1260))+(((-13950000.5)*x1262))+(((50000000.0)*py*x1258))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
IkReal x1263=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1263);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1263);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x1264=(cj6*r00);
IkReal x1265=((2.53003540759265)*sj6);
IkReal x1266=(cj2*sj1);
j0eval[0]=((((-2.53003540759265)*cj6*r10*sj2))+x1264+(((-1.0)*r01*sj6))+(((-3.584229262214)*px))+(((2.53003540759265)*x1264*x1266))+(((9.06822694233112)*py*sj2))+((r11*sj2*x1265))+(((-1.0)*r01*x1265*x1266))+(((-9.06822694233112)*px*x1266)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1267=cj6*cj6;
IkReal x1268=r01*r01;
IkReal x1269=(r01*sj6);
IkReal x1270=(cj6*r10);
IkReal x1271=(cj2*sj1);
IkReal x1272=((3.8966480736148e+15)*sj2);
IkReal x1273=(r11*sj6);
IkReal x1274=((77932961.472296)*py);
IkReal x1275=((4.35379660656096e+16)*px);
IkReal x1276=(cj6*r00);
IkReal x1277=(py*sj2);
IkReal x1278=((13950000.5)*sj2);
IkReal x1279=((77932961.472296)*px);
IkReal x1280=((6.07354648384237e+15)*x1268);
IkReal x1281=((21743297.0301002)*r01*r11);
CheckValue<IkReal> x1282=IKPowWithIntegerCheck(((((-1.0)*x1270*x1278))+(((-5513757.02416494)*x1269))+(((13950000.5)*x1271*x1276))+((x1273*x1278))+(((5513757.02416494)*x1276))+(((-19762569.27075)*px))+(((50000000.0)*x1277))+(((-50000000.0)*px*x1271))+(((-13950000.5)*x1269*x1271))),-1);
if(!x1282.valid){
continue;
}
CheckValue<IkReal> x1283=IKPowWithIntegerCheck(((((1.396648005e+16)*x1277))+(((-3.8966480736148e+15)*x1269*x1271))+(((-1.54015554957094e+15)*x1269))+(((3.8966480736148e+15)*x1271*x1276))+(((-1.0)*x1270*x1272))+((x1272*x1273))+(((1.54015554957094e+15)*x1276))+(((-1.396648005e+16)*px*x1271))+(((-5.52027058913346e+15)*px))),-1);
if(!x1283.valid){
continue;
}
if( IKabs(((x1282.value)*((((x1269*x1274))+x1281+(((-1.0)*x1270*x1279))+(((-1.0)*x1267*x1281))+((x1273*x1279))+(((21743297.0301002)*r00*r10*x1267))+(((-3537500.0)*sj2))+(((-8950000.25435901)*sj2*x1271))+(((-1.0)*x1274*x1276))+(((279329601.0)*px*py))+(((-21743297.0301002)*x1273*x1276))+(((-21743297.0301002)*x1269*x1270)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1283.value)*(((-2.5e+15)+((x1269*x1275))+x1280+(((-1.0)*x1267*x1280))+(((6.07354648384237e+15)*x1267*(r00*r00)))+(((-1.0)*x1275*x1276))+(((7.80250259948192e+16)*(px*px)))+(((-1.21470929676847e+16)*x1269*x1276))+(((2.5e+15)*(cj2*cj2))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1282.value)*((((x1269*x1274))+x1281+(((-1.0)*x1270*x1279))+(((-1.0)*x1267*x1281))+((x1273*x1279))+(((21743297.0301002)*r00*r10*x1267))+(((-3537500.0)*sj2))+(((-8950000.25435901)*sj2*x1271))+(((-1.0)*x1274*x1276))+(((279329601.0)*px*py))+(((-21743297.0301002)*x1273*x1276))+(((-21743297.0301002)*x1269*x1270))))))+IKsqr(((x1283.value)*(((-2.5e+15)+((x1269*x1275))+x1280+(((-1.0)*x1267*x1280))+(((6.07354648384237e+15)*x1267*(r00*r00)))+(((-1.0)*x1275*x1276))+(((7.80250259948192e+16)*(px*px)))+(((-1.21470929676847e+16)*x1269*x1276))+(((2.5e+15)*(cj2*cj2)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((x1282.value)*((((x1269*x1274))+x1281+(((-1.0)*x1270*x1279))+(((-1.0)*x1267*x1281))+((x1273*x1279))+(((21743297.0301002)*r00*r10*x1267))+(((-3537500.0)*sj2))+(((-8950000.25435901)*sj2*x1271))+(((-1.0)*x1274*x1276))+(((279329601.0)*px*py))+(((-21743297.0301002)*x1273*x1276))+(((-21743297.0301002)*x1269*x1270))))), ((x1283.value)*(((-2.5e+15)+((x1269*x1275))+x1280+(((-1.0)*x1267*x1280))+(((6.07354648384237e+15)*x1267*(r00*r00)))+(((-1.0)*x1275*x1276))+(((7.80250259948192e+16)*(px*px)))+(((-1.21470929676847e+16)*x1269*x1276))+(((2.5e+15)*(cj2*cj2)))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1284=IKcos(j0);
IkReal x1285=IKsin(j0);
IkReal x1286=((1.0)*px);
IkReal x1287=((1.0)*py);
IkReal x1288=(r01*sj6);
IkReal x1289=((0.55800002)*cj6);
IkReal x1290=(r11*sj6);
IkReal x1291=((0.17900000508718)*sj2);
IkReal x1292=((0.27900001)*cj6);
IkReal x1293=((0.039478501415)*x1284);
IkReal x1294=((0.27900001)*x1284);
IkReal x1295=((0.27900001)*x1285);
IkReal x1296=((0.039478501415)*x1285);
IkReal x1297=((0.17900000508718)*cj2*sj1);
evalcond[0]=((((-1.0)*x1284*x1297))+(((-0.27900001)*x1288))+(((-0.07075)*x1284))+((x1285*x1291))+(((-1.0)*x1286))+((r00*x1292)));
evalcond[1]=((((-1.0)*x1284*x1291))+(((-0.07075)*x1285))+(((-0.27900001)*x1290))+(((-1.0)*x1287))+(((-1.0)*x1285*x1297))+((r10*x1292)));
evalcond[2]=(((r10*x1284*x1292))+(((-1.0)*r00*x1285*x1292))+(((-1.0)*x1291))+(((-1.0)*x1284*x1287))+((px*x1285))+((x1288*x1295))+(((-1.0)*x1290*x1294)));
evalcond[3]=((-0.07075)+((r10*x1285*x1292))+(((-1.0)*x1297))+(((-1.0)*x1285*x1287))+(((-1.0)*x1288*x1294))+((r00*x1284*x1292))+(((-1.0)*x1284*x1286))+(((-1.0)*x1290*x1295)));
evalcond[4]=((-0.0508055662587896)+(((-1.0)*x1288*x1293))+(((-0.55800002)*px*x1288))+((px*r00*x1289))+((cj6*r10*x1296))+(((-1.0)*pp))+((cj6*r00*x1293))+(((-1.0)*x1290*x1296))+(((-0.1415)*px*x1284))+((py*r10*x1289))+(((-0.55800002)*py*x1290))+(((-0.1415)*py*x1285)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1298=cj6*cj6;
IkReal x1299=r01*r01;
IkReal x1300=cj2*cj2;
IkReal x1301=(r01*sj6);
IkReal x1302=((13950000.5)*sj2);
IkReal x1303=(cj6*r00);
IkReal x1304=((155865922.944592)*px);
IkReal x1305=(cj6*r10);
IkReal x1306=(cj2*sj1);
IkReal x1307=((77932961.472296)*py);
IkReal x1308=(r01*r11);
IkReal x1309=(r11*sj6);
IkReal x1310=((77932961.472296)*px);
IkReal x1311=((21743297.0301002)*x1298);
IkReal x1312=((8950000.25435901)*x1300);
CheckValue<IkReal> x1313=IKPowWithIntegerCheck(IKsign(((((13950000.5)*x1306*x1309))+(((-13950000.5)*x1305*x1306))+(((50000000.0)*py*x1306))+(((50000000.0)*px*sj2))+(((-5513757.02416494)*x1305))+(((5513757.02416494)*x1309))+(((19762569.27075)*py))+(((-1.0)*x1302*x1303))+((x1301*x1302)))),-1);
if(!x1313.valid){
continue;
}
CheckValue<IkReal> x1314 = IKatan2WithCheck(IkReal(((-1398201.77590556)+((x1311*(r00*r00)))+((x1312*(cj1*cj1)))+(((21743297.0301002)*x1299))+(((-1.0)*x1312))+(((-1.0)*x1299*x1311))+(((-1.0)*x1303*x1304))+(((-7075000.0)*x1306))+((x1301*x1304))+(((279329601.0)*(px*px)))+(((-43486594.0602004)*x1301*x1303)))),IkReal(((((-21743297.0301002)*x1308))+((x1308*x1311))+((x1305*x1310))+(((21743297.0301002)*x1301*x1305))+(((21743297.0301002)*x1303*x1309))+(((-1.0)*r00*r10*x1311))+(((-279329601.0)*px*py))+(((-3537500.0)*sj2))+((x1303*x1307))+(((-8950000.25435901)*sj2*x1306))+(((-1.0)*x1301*x1307))+(((-1.0)*x1309*x1310)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1314.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1313.value)))+(x1314.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1315=IKcos(j0);
IkReal x1316=IKsin(j0);
IkReal x1317=((1.0)*px);
IkReal x1318=((1.0)*py);
IkReal x1319=(r01*sj6);
IkReal x1320=((0.55800002)*cj6);
IkReal x1321=(r11*sj6);
IkReal x1322=((0.17900000508718)*sj2);
IkReal x1323=((0.27900001)*cj6);
IkReal x1324=((0.039478501415)*x1315);
IkReal x1325=((0.27900001)*x1315);
IkReal x1326=((0.27900001)*x1316);
IkReal x1327=((0.039478501415)*x1316);
IkReal x1328=((0.17900000508718)*cj2*sj1);
evalcond[0]=(((x1316*x1322))+((r00*x1323))+(((-1.0)*x1315*x1328))+(((-0.27900001)*x1319))+(((-0.07075)*x1315))+(((-1.0)*x1317)));
evalcond[1]=((((-0.27900001)*x1321))+(((-1.0)*x1315*x1322))+(((-0.07075)*x1316))+(((-1.0)*x1318))+((r10*x1323))+(((-1.0)*x1316*x1328)));
evalcond[2]=((((-1.0)*x1315*x1318))+((px*x1316))+(((-1.0)*x1322))+((x1319*x1326))+((r10*x1315*x1323))+(((-1.0)*x1321*x1325))+(((-1.0)*r00*x1316*x1323)));
evalcond[3]=((-0.07075)+(((-1.0)*x1315*x1317))+(((-1.0)*x1319*x1325))+(((-1.0)*x1328))+((r00*x1315*x1323))+((r10*x1316*x1323))+(((-1.0)*x1321*x1326))+(((-1.0)*x1316*x1318)));
evalcond[4]=((-0.0508055662587896)+(((-1.0)*x1319*x1324))+(((-0.1415)*px*x1315))+((px*r00*x1320))+((cj6*r00*x1324))+((py*r10*x1320))+(((-0.55800002)*py*x1321))+(((-0.55800002)*px*x1319))+(((-1.0)*pp))+(((-1.0)*x1321*x1327))+(((-0.1415)*py*x1316))+((cj6*r10*x1327)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1329=(r11*sj6);
IkReal x1330=(cj6*r10);
IkReal x1331=((1.396648005e+16)*sj2);
IkReal x1332=(r01*sj6);
IkReal x1333=(cj6*r00);
IkReal x1334=((3.8966480736148e+15)*sj2);
IkReal x1335=((3.8966480736148e+15)*cj2*sj1);
IkReal x1336=(cj6*x1334);
IkReal x1337=((1.396648005e+16)*cj2*sj1);
CheckValue<IkReal> x1338 = IKatan2WithCheck(IkReal((((x1329*x1335))+(((-1.0)*px*x1331))+((py*x1337))+(((-1.0)*x1330*x1335))+(((1.54015554957094e+15)*x1329))+(((-1.54015554957094e+15)*x1330))+(((-1.0)*x1332*x1334))+((x1333*x1334))+(((5.52027058913346e+15)*py)))),IkReal((((px*x1337))+((x1329*x1334))+((py*x1331))+(((-1.0)*x1330*x1334))+(((1.54015554957094e+15)*x1332))+(((-1.0)*x1333*x1335))+(((-1.54015554957094e+15)*x1333))+(((5.52027058913346e+15)*px))+((x1332*x1335)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1338.valid){
continue;
}
CheckValue<IkReal> x1339=IKPowWithIntegerCheck(IKsign(((-2.89055914418119e+15)+(((2.5e+15)*(cj1*cj1)*(cj2*cj2)))+(((-1.976256927075e+15)*cj2*sj1)))),-1);
if(!x1339.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1338.value)+(((1.5707963267949)*(x1339.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1340=IKcos(j0);
IkReal x1341=IKsin(j0);
IkReal x1342=((1.0)*px);
IkReal x1343=((1.0)*py);
IkReal x1344=(r01*sj6);
IkReal x1345=((0.55800002)*cj6);
IkReal x1346=(r11*sj6);
IkReal x1347=((0.17900000508718)*sj2);
IkReal x1348=((0.27900001)*cj6);
IkReal x1349=((0.039478501415)*x1340);
IkReal x1350=((0.27900001)*x1340);
IkReal x1351=((0.27900001)*x1341);
IkReal x1352=((0.039478501415)*x1341);
IkReal x1353=((0.17900000508718)*cj2*sj1);
evalcond[0]=((((-1.0)*x1342))+(((-0.07075)*x1340))+((x1341*x1347))+(((-0.27900001)*x1344))+((r00*x1348))+(((-1.0)*x1340*x1353)));
evalcond[1]=((((-1.0)*x1341*x1353))+(((-1.0)*x1340*x1347))+(((-1.0)*x1343))+(((-0.07075)*x1341))+(((-0.27900001)*x1346))+((r10*x1348)));
evalcond[2]=((((-1.0)*x1340*x1343))+(((-1.0)*x1347))+(((-1.0)*x1346*x1350))+((x1344*x1351))+((px*x1341))+((r10*x1340*x1348))+(((-1.0)*r00*x1341*x1348)));
evalcond[3]=((-0.07075)+(((-1.0)*x1353))+(((-1.0)*x1340*x1342))+(((-1.0)*x1341*x1343))+(((-1.0)*x1346*x1351))+((r00*x1340*x1348))+((r10*x1341*x1348))+(((-1.0)*x1344*x1350)));
evalcond[4]=((-0.0508055662587896)+(((-0.1415)*px*x1340))+((px*r00*x1345))+((cj6*r00*x1349))+((py*r10*x1345))+(((-1.0)*x1346*x1352))+(((-1.0)*pp))+(((-0.55800002)*px*x1344))+(((-0.55800002)*py*x1346))+((cj6*r10*x1352))+(((-0.1415)*py*x1341))+(((-1.0)*x1344*x1349)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1354=(cj2*sj1);
IkReal x1355=((0.15568201116)*r10);
IkReal x1356=(px*r01);
IkReal x1357=(px*r00);
IkReal x1358=(py*r11);
IkReal x1359=((-0.0407944412587896)+(((0.025328500719836)*x1354))+(((-1.0)*pp)));
IkReal x1360=((((0.55800002)*py*r10))+(((0.55800002)*x1357)));
IkReal x1361=((((-0.55800002)*x1356))+(((-0.55800002)*x1358)));
IkReal x1362=(((x1355*x1357))+((py*r10*x1355)));
IkReal x1363=(((x1355*x1358))+((x1355*x1356)));
IkReal x1364=((((-0.00706665195411925)*r10*x1354))+(((0.27900001)*pp*r10))+(((0.0113816495191467)*r10)));
CheckValue<IkReal> x1365=IKPowWithIntegerCheck(IKsign((((x1361*x1362))+((x1360*x1363)))),-1);
if(!x1365.valid){
continue;
}
CheckValue<IkReal> x1366 = IKatan2WithCheck(IkReal(((((-1.0)*x1359*x1362))+(((-1.0)*x1360*x1364)))),IkReal((((x1361*x1364))+(((-1.0)*x1359*x1363)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1366.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1365.value)))+(x1366.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x1367=IKcos(j6);
IkReal x1368=IKsin(j6);
IkReal x1369=((0.15568201116)*py);
IkReal x1370=((0.55800002)*py);
IkReal x1371=(cj2*sj1);
IkReal x1372=((0.15568201116)*px);
IkReal x1373=((0.55800002)*px);
IkReal x1374=(r00*r11);
IkReal x1375=(r00*r10);
IkReal x1376=(r01*r10);
IkReal x1377=(r01*r11);
IkReal x1378=((0.27900001)*pp);
IkReal x1379=(r10*r11*x1369);
IkReal x1380=(r00*r01*x1372);
evalcond[0]=((-0.0407944412587896)+(((-1.0)*pp))+((x1367*((((r10*x1370))+((r00*x1373))))))+((x1368*(((((-1.0)*r01*x1373))+(((-1.0)*r11*x1370))))))+(((0.025328500719836)*x1371)));
evalcond[1]=((((-0.00706665195411925)*r10*x1371))+((r10*x1378))+((x1368*((x1379+((x1372*x1376))))))+(((0.0113816495191467)*r10))+((x1367*(((((-1.0)*x1372*x1375))+(((-1.0)*x1369*(r10*r10))))))));
evalcond[2]=(((x1367*((x1379+((x1372*x1374))))))+(((0.00706665195411925)*r11*x1371))+(((-0.0113816495191467)*r11))+(((-1.0)*r11*x1378))+((x1368*(((((-1.0)*x1372*x1377))+(((-1.0)*x1369*(r11*r11))))))));
evalcond[3]=(((x1368*((x1380+((x1369*x1374))))))+((x1367*(((((-1.0)*x1372*(r00*r00)))+(((-1.0)*x1369*x1375))))))+(((0.0113816495191467)*r00))+(((-0.00706665195411925)*r00*x1371))+((r00*x1378)));
evalcond[4]=(((x1367*((x1380+((x1369*x1376))))))+(((-1.0)*r01*x1378))+(((-0.0113816495191467)*r01))+(((0.00706665195411925)*r01*x1371))+((x1368*(((((-1.0)*x1372*(r01*r01)))+(((-1.0)*x1369*x1377)))))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0eval[2];
IkReal x1381=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1381);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1381);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x1382=cj1*cj1;
IkReal x1383=cj2*cj2;
IkReal x1384=(cj2*sj1);
IkReal x1385=(x1382*x1383);
j0eval[0]=((-1.46264339650383)+(((-1.0)*x1384))+(((1.26501770379633)*x1385)));
j0eval[1]=IKsign(((-2.89055914418119e+15)+(((-1.976256927075e+15)*x1384))+(((2.5e+15)*x1385))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
IkReal x1386=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1386);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1386);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x1387=(cj6*r10);
IkReal x1388=(cj2*sj1);
IkReal x1389=(r11*sj6);
IkReal x1390=(px*sj2);
IkReal x1391=(r01*sj2*sj6);
IkReal x1392=(cj6*r00*sj2);
j0eval[0]=(x1389+(((2.53003540759265)*x1388*x1389))+(((9.06822694233112)*py*x1388))+(((-2.53003540759265)*x1387*x1388))+(((-2.53003540759265)*x1392))+(((2.53003540759265)*x1391))+(((-1.0)*x1387))+(((9.06822694233112)*x1390))+(((3.584229262214)*py)));
j0eval[1]=IKsign(((((-5513757.02416494)*x1387))+(((5513757.02416494)*x1389))+(((13950000.5)*x1391))+(((13950000.5)*x1388*x1389))+(((-13950000.5)*x1387*x1388))+(((50000000.0)*py*x1388))+(((50000000.0)*x1390))+(((19762569.27075)*py))+(((-13950000.5)*x1392))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
IkReal x1393=((-1.0)*pz);
r20=0;
r21=0;
r02=0;
r12=0;
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1393);
rxp1_0=(pz*r11);
rxp1_1=(r01*x1393);
rxp2_0=((-1.0)*py*r22);
rxp2_1=(px*r22);
rxp2_2=0;
IkReal x1394=(cj6*r00);
IkReal x1395=((2.53003540759265)*sj6);
IkReal x1396=(cj2*sj1);
j0eval[0]=(x1394+(((-2.53003540759265)*cj6*r10*sj2))+(((-1.0)*r01*sj6))+(((-9.06822694233112)*px*x1396))+(((-1.0)*r01*x1395*x1396))+(((2.53003540759265)*x1394*x1396))+(((-3.584229262214)*px))+(((9.06822694233112)*py*sj2))+((r11*sj2*x1395)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1397=cj6*cj6;
IkReal x1398=r01*r01;
IkReal x1399=(r01*sj6);
IkReal x1400=(cj6*r10);
IkReal x1401=(cj2*sj1);
IkReal x1402=((3.8966480736148e+15)*sj2);
IkReal x1403=(r11*sj6);
IkReal x1404=((77932961.472296)*py);
IkReal x1405=((4.35379660656096e+16)*px);
IkReal x1406=(cj6*r00);
IkReal x1407=(py*sj2);
IkReal x1408=((13950000.5)*sj2);
IkReal x1409=((77932961.472296)*px);
IkReal x1410=((6.07354648384237e+15)*x1398);
IkReal x1411=((21743297.0301002)*r01*r11);
CheckValue<IkReal> x1412=IKPowWithIntegerCheck(((((-5513757.02416494)*x1399))+(((13950000.5)*x1401*x1406))+(((5513757.02416494)*x1406))+(((-19762569.27075)*px))+((x1403*x1408))+(((-1.0)*x1400*x1408))+(((50000000.0)*x1407))+(((-13950000.5)*x1399*x1401))+(((-50000000.0)*px*x1401))),-1);
if(!x1412.valid){
continue;
}
CheckValue<IkReal> x1413=IKPowWithIntegerCheck(((((-1.54015554957094e+15)*x1399))+(((-1.396648005e+16)*px*x1401))+(((-3.8966480736148e+15)*x1399*x1401))+(((3.8966480736148e+15)*x1401*x1406))+(((1.396648005e+16)*x1407))+(((-1.0)*x1400*x1402))+((x1402*x1403))+(((-5.52027058913346e+15)*px))+(((1.54015554957094e+15)*x1406))),-1);
if(!x1413.valid){
continue;
}
if( IKabs(((x1412.value)*(((((-8950000.25435901)*sj2*x1401))+(((-3537500.0)*sj2))+(((-1.0)*x1404*x1406))+((x1403*x1409))+(((-21743297.0301002)*x1399*x1400))+(((279329601.0)*px*py))+((x1399*x1404))+x1411+(((-1.0)*x1400*x1409))+(((-1.0)*x1397*x1411))+(((21743297.0301002)*r00*r10*x1397))+(((-21743297.0301002)*x1403*x1406)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1413.value)*(((-2.5e+15)+(((-1.21470929676847e+16)*x1399*x1406))+(((6.07354648384237e+15)*x1397*(r00*r00)))+(((-1.0)*x1405*x1406))+(((7.80250259948192e+16)*(px*px)))+((x1399*x1405))+x1410+(((2.5e+15)*(cj2*cj2)))+(((-1.0)*x1397*x1410)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1412.value)*(((((-8950000.25435901)*sj2*x1401))+(((-3537500.0)*sj2))+(((-1.0)*x1404*x1406))+((x1403*x1409))+(((-21743297.0301002)*x1399*x1400))+(((279329601.0)*px*py))+((x1399*x1404))+x1411+(((-1.0)*x1400*x1409))+(((-1.0)*x1397*x1411))+(((21743297.0301002)*r00*r10*x1397))+(((-21743297.0301002)*x1403*x1406))))))+IKsqr(((x1413.value)*(((-2.5e+15)+(((-1.21470929676847e+16)*x1399*x1406))+(((6.07354648384237e+15)*x1397*(r00*r00)))+(((-1.0)*x1405*x1406))+(((7.80250259948192e+16)*(px*px)))+((x1399*x1405))+x1410+(((2.5e+15)*(cj2*cj2)))+(((-1.0)*x1397*x1410))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((x1412.value)*(((((-8950000.25435901)*sj2*x1401))+(((-3537500.0)*sj2))+(((-1.0)*x1404*x1406))+((x1403*x1409))+(((-21743297.0301002)*x1399*x1400))+(((279329601.0)*px*py))+((x1399*x1404))+x1411+(((-1.0)*x1400*x1409))+(((-1.0)*x1397*x1411))+(((21743297.0301002)*r00*r10*x1397))+(((-21743297.0301002)*x1403*x1406))))), ((x1413.value)*(((-2.5e+15)+(((-1.21470929676847e+16)*x1399*x1406))+(((6.07354648384237e+15)*x1397*(r00*r00)))+(((-1.0)*x1405*x1406))+(((7.80250259948192e+16)*(px*px)))+((x1399*x1405))+x1410+(((2.5e+15)*(cj2*cj2)))+(((-1.0)*x1397*x1410))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1414=IKcos(j0);
IkReal x1415=IKsin(j0);
IkReal x1416=((1.0)*px);
IkReal x1417=((1.0)*py);
IkReal x1418=(r01*sj6);
IkReal x1419=((0.55800002)*cj6);
IkReal x1420=(r11*sj6);
IkReal x1421=((0.17900000508718)*sj2);
IkReal x1422=((0.27900001)*cj6);
IkReal x1423=((0.039478501415)*x1414);
IkReal x1424=((0.27900001)*x1414);
IkReal x1425=((0.27900001)*x1415);
IkReal x1426=((0.039478501415)*x1415);
IkReal x1427=((0.17900000508718)*cj2*sj1);
evalcond[0]=(((r00*x1422))+((x1415*x1421))+(((-1.0)*x1416))+(((-0.27900001)*x1418))+(((-1.0)*x1414*x1427))+(((-0.07075)*x1414)));
evalcond[1]=((((-1.0)*x1415*x1427))+(((-0.27900001)*x1420))+(((-1.0)*x1417))+((r10*x1422))+(((-1.0)*x1414*x1421))+(((-0.07075)*x1415)));
evalcond[2]=((((-1.0)*x1414*x1417))+(((-1.0)*r00*x1415*x1422))+(((-1.0)*x1420*x1424))+((px*x1415))+((x1418*x1425))+((r10*x1414*x1422))+(((-1.0)*x1421)));
evalcond[3]=((-0.07075)+(((-1.0)*x1415*x1417))+(((-1.0)*x1414*x1416))+(((-1.0)*x1420*x1425))+(((-1.0)*x1418*x1424))+((r10*x1415*x1422))+((r00*x1414*x1422))+(((-1.0)*x1427)));
evalcond[4]=((-0.0508055662587896)+(((-0.1415)*py*x1415))+((cj6*r00*x1423))+(((-0.1415)*px*x1414))+((px*r00*x1419))+(((-1.0)*x1420*x1426))+(((-1.0)*x1418*x1423))+(((-1.0)*pp))+(((-0.55800002)*px*x1418))+((cj6*r10*x1426))+(((-0.55800002)*py*x1420))+((py*r10*x1419)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1428=cj6*cj6;
IkReal x1429=r01*r01;
IkReal x1430=cj2*cj2;
IkReal x1431=(r01*sj6);
IkReal x1432=((13950000.5)*sj2);
IkReal x1433=(cj6*r00);
IkReal x1434=((155865922.944592)*px);
IkReal x1435=(cj6*r10);
IkReal x1436=(cj2*sj1);
IkReal x1437=((77932961.472296)*py);
IkReal x1438=(r01*r11);
IkReal x1439=(r11*sj6);
IkReal x1440=((77932961.472296)*px);
IkReal x1441=((21743297.0301002)*x1428);
IkReal x1442=((8950000.25435901)*x1430);
CheckValue<IkReal> x1443=IKPowWithIntegerCheck(IKsign(((((13950000.5)*x1436*x1439))+(((50000000.0)*px*sj2))+(((50000000.0)*py*x1436))+(((-13950000.5)*x1435*x1436))+(((5513757.02416494)*x1439))+(((-5513757.02416494)*x1435))+(((-1.0)*x1432*x1433))+(((19762569.27075)*py))+((x1431*x1432)))),-1);
if(!x1443.valid){
continue;
}
CheckValue<IkReal> x1444 = IKatan2WithCheck(IkReal(((-1398201.77590556)+(((-43486594.0602004)*x1431*x1433))+((x1441*(r00*r00)))+(((21743297.0301002)*x1429))+((x1442*(cj1*cj1)))+(((-1.0)*x1429*x1441))+(((-7075000.0)*x1436))+(((-1.0)*x1442))+(((-1.0)*x1433*x1434))+(((279329601.0)*(px*px)))+((x1431*x1434)))),IkReal((((x1438*x1441))+((x1435*x1440))+(((-8950000.25435901)*sj2*x1436))+((x1433*x1437))+(((-1.0)*r00*r10*x1441))+(((-1.0)*x1439*x1440))+(((-279329601.0)*px*py))+(((-1.0)*x1431*x1437))+(((-3537500.0)*sj2))+(((21743297.0301002)*x1433*x1439))+(((-21743297.0301002)*x1438))+(((21743297.0301002)*x1431*x1435)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1444.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1443.value)))+(x1444.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1445=IKcos(j0);
IkReal x1446=IKsin(j0);
IkReal x1447=((1.0)*px);
IkReal x1448=((1.0)*py);
IkReal x1449=(r01*sj6);
IkReal x1450=((0.55800002)*cj6);
IkReal x1451=(r11*sj6);
IkReal x1452=((0.17900000508718)*sj2);
IkReal x1453=((0.27900001)*cj6);
IkReal x1454=((0.039478501415)*x1445);
IkReal x1455=((0.27900001)*x1445);
IkReal x1456=((0.27900001)*x1446);
IkReal x1457=((0.039478501415)*x1446);
IkReal x1458=((0.17900000508718)*cj2*sj1);
evalcond[0]=(((x1446*x1452))+(((-0.07075)*x1445))+(((-0.27900001)*x1449))+(((-1.0)*x1445*x1458))+((r00*x1453))+(((-1.0)*x1447)));
evalcond[1]=(((r10*x1453))+(((-0.07075)*x1446))+(((-1.0)*x1445*x1452))+(((-0.27900001)*x1451))+(((-1.0)*x1446*x1458))+(((-1.0)*x1448)));
evalcond[2]=((((-1.0)*r00*x1446*x1453))+(((-1.0)*x1445*x1448))+(((-1.0)*x1452))+((r10*x1445*x1453))+((px*x1446))+(((-1.0)*x1451*x1455))+((x1449*x1456)));
evalcond[3]=((-0.07075)+(((-1.0)*x1446*x1448))+(((-1.0)*x1445*x1447))+(((-1.0)*x1458))+((r00*x1445*x1453))+((r10*x1446*x1453))+(((-1.0)*x1451*x1456))+(((-1.0)*x1449*x1455)));
evalcond[4]=((-0.0508055662587896)+((py*r10*x1450))+((cj6*r10*x1457))+(((-0.55800002)*py*x1451))+((px*r00*x1450))+(((-0.1415)*py*x1446))+(((-0.1415)*px*x1445))+(((-1.0)*pp))+((cj6*r00*x1454))+(((-0.55800002)*px*x1449))+(((-1.0)*x1451*x1457))+(((-1.0)*x1449*x1454)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1459=(r11*sj6);
IkReal x1460=(cj6*r10);
IkReal x1461=((1.396648005e+16)*sj2);
IkReal x1462=(r01*sj6);
IkReal x1463=(cj6*r00);
IkReal x1464=((3.8966480736148e+15)*sj2);
IkReal x1465=((3.8966480736148e+15)*cj2*sj1);
IkReal x1466=(cj6*x1464);
IkReal x1467=((1.396648005e+16)*cj2*sj1);
CheckValue<IkReal> x1468 = IKatan2WithCheck(IkReal(((((-1.54015554957094e+15)*x1460))+((py*x1467))+((x1463*x1464))+((x1459*x1465))+(((-1.0)*x1462*x1464))+(((-1.0)*x1460*x1465))+(((1.54015554957094e+15)*x1459))+(((-1.0)*px*x1461))+(((5.52027058913346e+15)*py)))),IkReal(((((1.54015554957094e+15)*x1462))+(((-1.54015554957094e+15)*x1463))+((py*x1461))+((x1459*x1464))+(((-1.0)*x1463*x1465))+((px*x1467))+(((-1.0)*x1460*x1464))+((x1462*x1465))+(((5.52027058913346e+15)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1468.valid){
continue;
}
CheckValue<IkReal> x1469=IKPowWithIntegerCheck(IKsign(((-2.89055914418119e+15)+(((2.5e+15)*(cj1*cj1)*(cj2*cj2)))+(((-1.976256927075e+15)*cj2*sj1)))),-1);
if(!x1469.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1468.value)+(((1.5707963267949)*(x1469.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1470=IKcos(j0);
IkReal x1471=IKsin(j0);
IkReal x1472=((1.0)*px);
IkReal x1473=((1.0)*py);
IkReal x1474=(r01*sj6);
IkReal x1475=((0.55800002)*cj6);
IkReal x1476=(r11*sj6);
IkReal x1477=((0.17900000508718)*sj2);
IkReal x1478=((0.27900001)*cj6);
IkReal x1479=((0.039478501415)*x1470);
IkReal x1480=((0.27900001)*x1470);
IkReal x1481=((0.27900001)*x1471);
IkReal x1482=((0.039478501415)*x1471);
IkReal x1483=((0.17900000508718)*cj2*sj1);
evalcond[0]=(((x1471*x1477))+(((-0.07075)*x1470))+(((-1.0)*x1470*x1483))+(((-0.27900001)*x1474))+(((-1.0)*x1472))+((r00*x1478)));
evalcond[1]=((((-0.07075)*x1471))+(((-1.0)*x1470*x1477))+((r10*x1478))+(((-0.27900001)*x1476))+(((-1.0)*x1473))+(((-1.0)*x1471*x1483)));
evalcond[2]=(((r10*x1470*x1478))+(((-1.0)*x1470*x1473))+(((-1.0)*r00*x1471*x1478))+((x1474*x1481))+(((-1.0)*x1477))+((px*x1471))+(((-1.0)*x1476*x1480)));
evalcond[3]=((-0.07075)+((r00*x1470*x1478))+(((-1.0)*x1471*x1473))+(((-1.0)*x1470*x1472))+(((-1.0)*x1483))+(((-1.0)*x1474*x1480))+((r10*x1471*x1478))+(((-1.0)*x1476*x1481)));
evalcond[4]=((-0.0508055662587896)+(((-0.1415)*py*x1471))+(((-1.0)*x1474*x1479))+((py*r10*x1475))+((cj6*r10*x1482))+(((-1.0)*pp))+(((-0.1415)*px*x1470))+(((-0.55800002)*py*x1476))+(((-0.55800002)*px*x1474))+(((-1.0)*x1476*x1482))+((cj6*r00*x1479))+((px*r00*x1475)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1484=((50000000.0)*pp);
IkReal x1485=((100000000.0)*pz);
IkReal x1486=((1266425.0359918)*cj2*sj1);
IkReal x1487=((17900000.508718)*cj1*cj2);
CheckValue<IkReal> x1488 = IKatan2WithCheck(IkReal((((r20*x1486))+((npx*x1485))+((npx*x1487))+(((-1.0)*r20*x1484))+(((-2039722.06293948)*r20)))),IkReal(((((-1.0)*r21*x1484))+((r21*x1486))+((npy*x1485))+((npy*x1487))+(((-2039722.06293948)*r21)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1488.valid){
continue;
}
CheckValue<IkReal> x1489=IKPowWithIntegerCheck(IKsign(((((-27900001.0)*npx*r21))+(((27900001.0)*npy*r20)))),-1);
if(!x1489.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1488.value)+(((1.5707963267949)*(x1489.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
IkReal x1490=IKcos(j6);
IkReal x1491=IKsin(j6);
evalcond[0]=((((0.27900001)*r20*x1490))+(((-0.17900000508718)*cj1*cj2))+(((-1.0)*pz))+(((-0.27900001)*r21*x1491)));
evalcond[1]=((-0.0407944412587896)+(((-0.55800002)*npy*x1491))+(((0.025328500719836)*cj2*sj1))+(((-1.0)*pp))+(((0.55800002)*npx*x1490)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0eval[2];
IkReal x1492=cj1*cj1;
IkReal x1493=cj2*cj2;
IkReal x1494=(cj2*sj1);
IkReal x1495=(x1492*x1493);
j0eval[0]=((-1.46264339650383)+(((1.26501770379633)*x1495))+(((-1.0)*x1494)));
j0eval[1]=IKsign(((-2.89055914418119e+15)+(((2.5e+15)*x1495))+(((-1.976256927075e+15)*x1494))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
IkReal x1496=(cj6*r10);
IkReal x1497=(cj2*sj1);
IkReal x1498=(r11*sj6);
IkReal x1499=(px*sj2);
IkReal x1500=(r01*sj2*sj6);
IkReal x1501=(cj6*r00*sj2);
j0eval[0]=((((9.06822694233112)*py*x1497))+(((-2.53003540759265)*x1496*x1497))+(((-1.0)*x1496))+(((9.06822694233112)*x1499))+(((-2.53003540759265)*x1501))+(((2.53003540759265)*x1500))+x1498+(((2.53003540759265)*x1497*x1498))+(((3.584229262214)*py)));
j0eval[1]=IKsign(((((50000000.0)*py*x1497))+(((13950000.5)*x1500))+(((5513757.02416494)*x1498))+(((-13950000.5)*x1501))+(((-5513757.02416494)*x1496))+(((-13950000.5)*x1496*x1497))+(((50000000.0)*x1499))+(((13950000.5)*x1497*x1498))+(((19762569.27075)*py))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
IkReal x1502=(cj6*r00);
IkReal x1503=((2.53003540759265)*sj6);
IkReal x1504=(cj2*sj1);
j0eval[0]=((((-2.53003540759265)*cj6*r10*sj2))+(((-1.0)*r01*sj6))+(((2.53003540759265)*x1502*x1504))+x1502+(((-3.584229262214)*px))+((r11*sj2*x1503))+(((-9.06822694233112)*px*x1504))+(((9.06822694233112)*py*sj2))+(((-1.0)*r01*x1503*x1504)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1505=cj6*cj6;
IkReal x1506=r01*r01;
IkReal x1507=(r01*sj6);
IkReal x1508=(cj6*r10);
IkReal x1509=(cj2*sj1);
IkReal x1510=((3.8966480736148e+15)*sj2);
IkReal x1511=(r11*sj6);
IkReal x1512=((77932961.472296)*py);
IkReal x1513=((4.35379660656096e+16)*px);
IkReal x1514=(cj6*r00);
IkReal x1515=(py*sj2);
IkReal x1516=((13950000.5)*sj2);
IkReal x1517=((77932961.472296)*px);
IkReal x1518=((6.07354648384237e+15)*x1506);
IkReal x1519=((21743297.0301002)*r01*r11);
CheckValue<IkReal> x1520=IKPowWithIntegerCheck(((((50000000.0)*x1515))+(((5513757.02416494)*x1514))+(((13950000.5)*x1509*x1514))+(((-19762569.27075)*px))+(((-50000000.0)*px*x1509))+(((-13950000.5)*x1507*x1509))+(((-1.0)*x1508*x1516))+((x1511*x1516))+(((-5513757.02416494)*x1507))),-1);
if(!x1520.valid){
continue;
}
CheckValue<IkReal> x1521=IKPowWithIntegerCheck((((x1510*x1511))+(((-3.8966480736148e+15)*x1507*x1509))+(((1.54015554957094e+15)*x1514))+(((3.8966480736148e+15)*x1509*x1514))+(((-1.54015554957094e+15)*x1507))+(((1.396648005e+16)*x1515))+(((-5.52027058913346e+15)*px))+(((-1.0)*x1508*x1510))+(((-1.396648005e+16)*px*x1509))),-1);
if(!x1521.valid){
continue;
}
if( IKabs(((x1520.value)*(((((-21743297.0301002)*x1507*x1508))+(((-21743297.0301002)*x1511*x1514))+((x1507*x1512))+(((-3537500.0)*sj2))+x1519+(((21743297.0301002)*r00*r10*x1505))+(((279329601.0)*px*py))+(((-1.0)*x1512*x1514))+(((-8950000.25435901)*sj2*x1509))+(((-1.0)*x1508*x1517))+(((-1.0)*x1505*x1519))+((x1511*x1517)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1521.value)*(((-2.5e+15)+(((-1.0)*x1513*x1514))+(((-1.21470929676847e+16)*x1507*x1514))+((x1507*x1513))+(((7.80250259948192e+16)*(px*px)))+x1518+(((2.5e+15)*(cj2*cj2)))+(((6.07354648384237e+15)*x1505*(r00*r00)))+(((-1.0)*x1505*x1518)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1520.value)*(((((-21743297.0301002)*x1507*x1508))+(((-21743297.0301002)*x1511*x1514))+((x1507*x1512))+(((-3537500.0)*sj2))+x1519+(((21743297.0301002)*r00*r10*x1505))+(((279329601.0)*px*py))+(((-1.0)*x1512*x1514))+(((-8950000.25435901)*sj2*x1509))+(((-1.0)*x1508*x1517))+(((-1.0)*x1505*x1519))+((x1511*x1517))))))+IKsqr(((x1521.value)*(((-2.5e+15)+(((-1.0)*x1513*x1514))+(((-1.21470929676847e+16)*x1507*x1514))+((x1507*x1513))+(((7.80250259948192e+16)*(px*px)))+x1518+(((2.5e+15)*(cj2*cj2)))+(((6.07354648384237e+15)*x1505*(r00*r00)))+(((-1.0)*x1505*x1518))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((x1520.value)*(((((-21743297.0301002)*x1507*x1508))+(((-21743297.0301002)*x1511*x1514))+((x1507*x1512))+(((-3537500.0)*sj2))+x1519+(((21743297.0301002)*r00*r10*x1505))+(((279329601.0)*px*py))+(((-1.0)*x1512*x1514))+(((-8950000.25435901)*sj2*x1509))+(((-1.0)*x1508*x1517))+(((-1.0)*x1505*x1519))+((x1511*x1517))))), ((x1521.value)*(((-2.5e+15)+(((-1.0)*x1513*x1514))+(((-1.21470929676847e+16)*x1507*x1514))+((x1507*x1513))+(((7.80250259948192e+16)*(px*px)))+x1518+(((2.5e+15)*(cj2*cj2)))+(((6.07354648384237e+15)*x1505*(r00*r00)))+(((-1.0)*x1505*x1518))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1522=IKcos(j0);
IkReal x1523=IKsin(j0);
IkReal x1524=((1.0)*px);
IkReal x1525=((1.0)*py);
IkReal x1526=(r01*sj6);
IkReal x1527=((0.17900000508718)*sj2);
IkReal x1528=((0.27900001)*cj6);
IkReal x1529=(r11*sj6);
IkReal x1530=((0.039478501415)*x1522);
IkReal x1531=((0.27900001)*x1522);
IkReal x1532=(r10*x1523);
IkReal x1533=((0.17900000508718)*cj2*sj1);
IkReal x1534=(x1523*x1529);
evalcond[0]=((((-0.27900001)*x1526))+((r00*x1528))+(((-1.0)*x1524))+((x1523*x1527))+(((-1.0)*x1522*x1533))+(((-0.07075)*x1522)));
evalcond[1]=((((-0.27900001)*x1529))+((r10*x1528))+(((-1.0)*x1525))+(((-1.0)*x1522*x1527))+(((-1.0)*x1523*x1533))+(((-0.07075)*x1523)));
evalcond[2]=((((-1.0)*r00*x1523*x1528))+(((-1.0)*x1529*x1531))+((r10*x1522*x1528))+(((-1.0)*x1527))+(((0.27900001)*x1523*x1526))+((px*x1523))+(((-1.0)*x1522*x1525)));
evalcond[3]=((-0.07075)+((x1528*x1532))+(((-1.0)*x1533))+(((-1.0)*x1522*x1524))+(((-1.0)*x1523*x1525))+(((-1.0)*x1526*x1531))+((r00*x1522*x1528))+(((-0.27900001)*x1534)));
evalcond[4]=((-0.0508055662587896)+(((0.039478501415)*cj6*x1532))+((cj6*r00*x1530))+(((0.55800002)*cj6*npx))+(((-1.0)*pp))+(((-0.1415)*px*x1522))+(((-0.039478501415)*x1534))+(((-0.1415)*py*x1523))+(((-0.55800002)*npy*sj6))+(((-1.0)*x1526*x1530)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1535=cj6*cj6;
IkReal x1536=r01*r01;
IkReal x1537=cj2*cj2;
IkReal x1538=(r01*sj6);
IkReal x1539=((13950000.5)*sj2);
IkReal x1540=(cj6*r00);
IkReal x1541=((155865922.944592)*px);
IkReal x1542=(cj6*r10);
IkReal x1543=(cj2*sj1);
IkReal x1544=((77932961.472296)*py);
IkReal x1545=(r01*r11);
IkReal x1546=(r11*sj6);
IkReal x1547=((77932961.472296)*px);
IkReal x1548=((21743297.0301002)*x1535);
IkReal x1549=((8950000.25435901)*x1537);
CheckValue<IkReal> x1550 = IKatan2WithCheck(IkReal(((-1398201.77590556)+(((-7075000.0)*x1543))+((x1538*x1541))+((x1548*(r00*r00)))+(((-1.0)*x1540*x1541))+(((-1.0)*x1536*x1548))+(((-43486594.0602004)*x1538*x1540))+((x1549*(cj1*cj1)))+(((-1.0)*x1549))+(((21743297.0301002)*x1536))+(((279329601.0)*(px*px))))),IkReal(((((-1.0)*x1546*x1547))+(((21743297.0301002)*x1540*x1546))+(((-8950000.25435901)*sj2*x1543))+(((21743297.0301002)*x1538*x1542))+(((-279329601.0)*px*py))+(((-1.0)*r00*r10*x1548))+(((-3537500.0)*sj2))+((x1540*x1544))+(((-21743297.0301002)*x1545))+((x1542*x1547))+((x1545*x1548))+(((-1.0)*x1538*x1544)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1550.valid){
continue;
}
CheckValue<IkReal> x1551=IKPowWithIntegerCheck(IKsign(((((50000000.0)*py*x1543))+((x1538*x1539))+(((-13950000.5)*x1542*x1543))+(((50000000.0)*px*sj2))+(((5513757.02416494)*x1546))+(((13950000.5)*x1543*x1546))+(((-5513757.02416494)*x1542))+(((-1.0)*x1539*x1540))+(((19762569.27075)*py)))),-1);
if(!x1551.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1550.value)+(((1.5707963267949)*(x1551.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1552=IKcos(j0);
IkReal x1553=IKsin(j0);
IkReal x1554=((1.0)*px);
IkReal x1555=((1.0)*py);
IkReal x1556=(r01*sj6);
IkReal x1557=((0.17900000508718)*sj2);
IkReal x1558=((0.27900001)*cj6);
IkReal x1559=(r11*sj6);
IkReal x1560=((0.039478501415)*x1552);
IkReal x1561=((0.27900001)*x1552);
IkReal x1562=(r10*x1553);
IkReal x1563=((0.17900000508718)*cj2*sj1);
IkReal x1564=(x1553*x1559);
evalcond[0]=(((r00*x1558))+((x1553*x1557))+(((-1.0)*x1552*x1563))+(((-0.27900001)*x1556))+(((-0.07075)*x1552))+(((-1.0)*x1554)));
evalcond[1]=((((-0.27900001)*x1559))+(((-0.07075)*x1553))+(((-1.0)*x1552*x1557))+(((-1.0)*x1553*x1563))+(((-1.0)*x1555))+((r10*x1558)));
evalcond[2]=((((-1.0)*x1559*x1561))+((r10*x1552*x1558))+(((-1.0)*x1552*x1555))+(((0.27900001)*x1553*x1556))+(((-1.0)*r00*x1553*x1558))+(((-1.0)*x1557))+((px*x1553)));
evalcond[3]=((-0.07075)+(((-1.0)*x1552*x1554))+((r00*x1552*x1558))+(((-0.27900001)*x1564))+(((-1.0)*x1553*x1555))+(((-1.0)*x1556*x1561))+(((-1.0)*x1563))+((x1558*x1562)));
evalcond[4]=((-0.0508055662587896)+(((-0.1415)*px*x1552))+(((0.039478501415)*cj6*x1562))+(((0.55800002)*cj6*npx))+(((-1.0)*x1556*x1560))+(((-1.0)*pp))+(((-0.55800002)*npy*sj6))+((cj6*r00*x1560))+(((-0.1415)*py*x1553))+(((-0.039478501415)*x1564)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1565=(r11*sj6);
IkReal x1566=(cj6*r10);
IkReal x1567=((1.396648005e+16)*sj2);
IkReal x1568=(r01*sj6);
IkReal x1569=(cj6*r00);
IkReal x1570=((3.8966480736148e+15)*sj2);
IkReal x1571=((3.8966480736148e+15)*cj2*sj1);
IkReal x1572=(cj6*x1570);
IkReal x1573=((1.396648005e+16)*cj2*sj1);
CheckValue<IkReal> x1574 = IKatan2WithCheck(IkReal(((((-1.54015554957094e+15)*x1566))+((x1569*x1570))+(((-1.0)*x1566*x1571))+(((-1.0)*x1568*x1570))+(((-1.0)*px*x1567))+((py*x1573))+((x1565*x1571))+(((5.52027058913346e+15)*py))+(((1.54015554957094e+15)*x1565)))),IkReal(((((-1.54015554957094e+15)*x1569))+(((-1.0)*x1566*x1570))+((x1568*x1571))+(((-1.0)*x1569*x1571))+((px*x1573))+((py*x1567))+((x1565*x1570))+(((5.52027058913346e+15)*px))+(((1.54015554957094e+15)*x1568)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1574.valid){
continue;
}
CheckValue<IkReal> x1575=IKPowWithIntegerCheck(IKsign(((-2.89055914418119e+15)+(((2.5e+15)*(cj1*cj1)*(cj2*cj2)))+(((-1.976256927075e+15)*cj2*sj1)))),-1);
if(!x1575.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1574.value)+(((1.5707963267949)*(x1575.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1576=IKcos(j0);
IkReal x1577=IKsin(j0);
IkReal x1578=((1.0)*px);
IkReal x1579=((1.0)*py);
IkReal x1580=(r01*sj6);
IkReal x1581=((0.17900000508718)*sj2);
IkReal x1582=((0.27900001)*cj6);
IkReal x1583=(r11*sj6);
IkReal x1584=((0.039478501415)*x1576);
IkReal x1585=((0.27900001)*x1576);
IkReal x1586=(r10*x1577);
IkReal x1587=((0.17900000508718)*cj2*sj1);
IkReal x1588=(x1577*x1583);
evalcond[0]=((((-0.07075)*x1576))+(((-0.27900001)*x1580))+((x1577*x1581))+(((-1.0)*x1578))+(((-1.0)*x1576*x1587))+((r00*x1582)));
evalcond[1]=((((-0.07075)*x1577))+(((-0.27900001)*x1583))+(((-1.0)*x1577*x1587))+(((-1.0)*x1579))+((r10*x1582))+(((-1.0)*x1576*x1581)));
evalcond[2]=((((-1.0)*x1581))+(((-1.0)*x1576*x1579))+((r10*x1576*x1582))+(((0.27900001)*x1577*x1580))+(((-1.0)*r00*x1577*x1582))+((px*x1577))+(((-1.0)*x1583*x1585)));
evalcond[3]=((-0.07075)+(((-1.0)*x1587))+(((-1.0)*x1576*x1578))+(((-1.0)*x1580*x1585))+(((-0.27900001)*x1588))+((x1582*x1586))+(((-1.0)*x1577*x1579))+((r00*x1576*x1582)));
evalcond[4]=((-0.0508055662587896)+(((-0.1415)*px*x1576))+(((-1.0)*x1580*x1584))+((cj6*r00*x1584))+(((0.55800002)*cj6*npx))+(((0.039478501415)*cj6*x1586))+(((-1.0)*pp))+(((-0.1415)*py*x1577))+(((-0.55800002)*npy*sj6))+(((-0.039478501415)*x1588)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
    }
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x250=(cj1*sj2);
IkReal x251=(cj2*sj1);
IkReal x252=((1.0)*cj6);
IkReal x253=((1.0)*r20);
IkReal x254=(cj1*sj0);
IkReal x255=(cj0*cj1);
IkReal x256=((1.0)*sj0);
IkReal x257=((1.0)*sj1);
IkReal x258=(cj0*sj2);
IkReal x259=(cj1*cj2);
IkReal x260=((((-1.0)*sj2*x256))+((cj0*x251)));
IkReal x261=(((sj0*x251))+x258);
IkReal x262=((((-1.0)*sj1*sj2*x256))+((cj0*cj2)));
IkReal x263=(r11*x262);
IkReal x264=(r10*x262);
IkReal x265=((((-1.0)*x257*x258))+(((-1.0)*cj2*x256)));
IkReal x266=(((r11*x254))+((r01*x255))+(((-1.0)*r21*x257)));
IkReal x267=(((r00*x255))+((r10*x254))+(((-1.0)*sj1*x253)));
IkReal x268=(r01*x265);
IkReal x269=(r00*x265);
IkReal x270=(x264+x269);
IkReal x271=(x263+x268);
IkReal x272=(((r21*x259))+((r11*x261))+((r01*x260)));
IkReal x273=(((r20*x259))+((r00*x260))+((r10*x261)));
new_r00=(((r02*x260))+((r12*x261))+((r22*x259)));
new_r01=(((sj6*x273))+((cj6*x272)));
new_r02=(((sj6*x272))+(((-1.0)*x252*x273)));
new_r10=((((-1.0)*r22*x257))+((r12*x254))+((r02*x255)));
new_r11=(((sj6*x267))+((cj6*x266)));
new_r12=(((sj6*x266))+(((-1.0)*x252*x267)));
new_r20=((((-1.0)*r22*x250))+((r02*x265))+((r12*x262)));
new_r21=(((cj6*(((((-1.0)*r21*x250))+x271))))+((sj6*(((((-1.0)*x250*x253))+x270)))));
new_r22=((((-1.0)*x252*((x270+(((-1.0)*r20*x250))))))+((sj6*(((((-1.0)*r21*x250))+x271)))));
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
sj4array[0]=((-1.0)*new_r22);
if( sj4array[0] >= -1-IKFAST_SINCOS_THRESH && sj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKasin(sj4array[0]);
    cj4array[0] = IKcos(j4array[0]);
    sj4array[1] = sj4array[0];
    j4array[1] = j4array[0] > 0 ? (IKPI-j4array[0]) : (-IKPI-j4array[0]);
    cj4array[1] = -cj4array[0];
}
else if( isnan(sj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IkReal j5eval[3];
j5eval[0]=cj4;
j5eval[1]=IKsign(cj4);
j5eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
j3eval[0]=cj4;
j3eval[1]=IKsign(cj4);
j3eval[2]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
j3eval[0]=cj4;
j3eval[1]=new_r02;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j5mul = 1;
j5=0;
j3mul=1.0;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3=IKatan2(new_r01, ((-1.0)*new_r11));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].fmul = j3mul;
vinfos[3].freeind = 0;
vinfos[3].maxsolutions = 0;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].fmul = j5mul;
vinfos[5].freeind = 0;
vinfos[5].maxsolutions = 0;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(1);
vfree[0] = 5;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j5mul = 1;
j5=0;
j3mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3=IKatan2(((-1.0)*new_r01), new_r11);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].fmul = j3mul;
vinfos[3].freeind = 0;
vinfos[3].maxsolutions = 0;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].fmul = j5mul;
vinfos[5].freeind = 0;
vinfos[5].maxsolutions = 0;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(1);
vfree[0] = 5;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
IkReal x274=new_r22*new_r22;
IkReal x275=((16.0)*new_r10);
IkReal x276=((16.0)*new_r01);
IkReal x277=((16.0)*new_r00);
IkReal x278=(new_r11*new_r22);
IkReal x279=((8.0)*new_r00);
IkReal x280=(x274*x275);
IkReal x281=(x274*x276);
j3eval[0]=((IKabs((((new_r22*x279))+(((-8.0)*new_r11)))))+(IKabs((x280+(((-1.0)*x275)))))+(IKabs((x276+(((-1.0)*x281)))))+(IKabs((((new_r22*x277))+(((-32.0)*new_r11*x274))+(((16.0)*new_r11)))))+(IKabs(((((32.0)*new_r00))+(((-1.0)*x274*x277))+(((-16.0)*x278)))))+(IKabs((x275+(((-1.0)*x280)))))+(IKabs((x281+(((-1.0)*x276)))))+(IKabs((((x274*x279))+(((-8.0)*x278))))));
if( IKabs(j3eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j3, j5]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j3evalpoly[1];
IkReal x282=new_r22*new_r22;
IkReal x283=((16.0)*new_r01);
IkReal x284=(new_r00*new_r22);
IkReal x285=(x282*x283);
IkReal x286=((((8.0)*x284))+(((-8.0)*new_r11)));
op[0]=x286;
op[1]=(x285+(((-1.0)*x283)));
op[2]=((((-32.0)*new_r11*x282))+(((16.0)*x284))+(((16.0)*new_r11)));
op[3]=(x283+(((-1.0)*x285)));
op[4]=x286;
polyroots4(op,zeror,numroots);
IkReal j3array[4], cj3array[4], sj3array[4], tempj3array[1];
int numsolutions = 0;
for(int ij3 = 0; ij3 < numroots; ++ij3)
{
IkReal htj3 = zeror[ij3];
tempj3array[0]=((2.0)*(atan(htj3)));
for(int kj3 = 0; kj3 < 1; ++kj3)
{
j3array[numsolutions] = tempj3array[kj3];
if( j3array[numsolutions] > IKPI )
{
    j3array[numsolutions]-=IK2PI;
}
else if( j3array[numsolutions] < -IKPI )
{
    j3array[numsolutions]+=IK2PI;
}
sj3array[numsolutions] = IKsin(j3array[numsolutions]);
cj3array[numsolutions] = IKcos(j3array[numsolutions]);
numsolutions++;
}
}
bool j3valid[4]={true,true,true,true};
_nj3 = 4;
for(int ij3 = 0; ij3 < numsolutions; ++ij3)
    {
if( !j3valid[ij3] )
{
    continue;
}
    j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
htj3 = IKtan(j3/2);

IkReal x287=new_r22*new_r22;
IkReal x288=((16.0)*new_r10);
IkReal x289=(new_r11*new_r22);
IkReal x290=((8.0)*x289);
IkReal x291=(new_r00*x287);
IkReal x292=(x287*x288);
IkReal x293=((8.0)*x291);
j3evalpoly[0]=((((-1.0)*x290))+((htj3*((x292+(((-1.0)*x288))))))+x293+(((htj3*htj3)*(((((32.0)*new_r00))+(((-16.0)*x291))+(((-16.0)*x289))))))+(((htj3*htj3*htj3*htj3)*(((((-1.0)*x290))+x293))))+(((htj3*htj3*htj3)*(((((-1.0)*x292))+x288)))));
if( IKabs(j3evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < numsolutions; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
{
IkReal j5eval[3];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
IkReal x294=cj3*cj3;
IkReal x295=new_r22*new_r22;
IkReal x296=(new_r22*sj3);
IkReal x297=((((-1.0)*x294))+(((-1.0)*x295))+((x294*x295)));
j5eval[0]=x297;
j5eval[1]=IKsign(x297);
j5eval[2]=((IKabs((((new_r00*x296))+((cj3*new_r01)))))+(IKabs(((((-1.0)*cj3*new_r00))+((new_r01*x296))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j5eval[0]=new_r22;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j5eval[0]=cj3;
j5eval[1]=new_r22;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x298=IKsin(j5);
IkReal x299=IKcos(j5);
IkReal x300=((1.0)*new_r22);
IkReal x301=((1.0)*x299);
evalcond[0]=(x298+new_r11);
evalcond[1]=(new_r10+(((-1.0)*x301)));
evalcond[2]=((((-1.0)*x298*x300))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x299*x300))+(((-1.0)*new_r01)));
evalcond[4]=((((-1.0)*x298))+(((-1.0)*new_r00*x300)));
evalcond[5]=((((-1.0)*new_r01*x300))+(((-1.0)*x301)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x302=IKsin(j5);
IkReal x303=IKcos(j5);
IkReal x304=((1.0)*x303);
IkReal x305=((1.0)*x302);
evalcond[0]=(x302+(((-1.0)*new_r11)));
evalcond[1]=((((-1.0)*new_r22*x305))+new_r00);
evalcond[2]=((((-1.0)*new_r22*x304))+new_r01);
evalcond[3]=((((-1.0)*new_r10))+(((-1.0)*x304)));
evalcond[4]=(((new_r00*new_r22))+(((-1.0)*x305)));
evalcond[5]=(((new_r01*new_r22))+(((-1.0)*x304)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x306=new_r22*new_r22;
CheckValue<IkReal> x307=IKPowWithIntegerCheck(((-1.0)+x306),-1);
if(!x307.valid){
continue;
}
if(((x306*(x307.value))) < -0.00001)
continue;
IkReal gconst38=IKsqrt((x306*(x307.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj3+(((-1.0)*gconst38)))))+(IKabs(((-1.0)+(IKsign(sj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if((((1.0)+(((-1.0)*(gconst38*gconst38))))) < -0.00001)
continue;
IkReal x308=IKsqrt(((1.0)+(((-1.0)*(gconst38*gconst38)))));
if( IKabs(((((-1.0)*gconst38*new_r01))+(((-1.0)*new_r11*x308)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r10*x308))+((gconst38*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*gconst38*new_r01))+(((-1.0)*new_r11*x308))))+IKsqr((((new_r10*x308))+((gconst38*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*gconst38*new_r01))+(((-1.0)*new_r11*x308))), (((new_r10*x308))+((gconst38*new_r00))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[10];
IkReal x309=IKcos(j5);
IkReal x310=IKsin(j5);
IkReal x311=(gconst38*new_r22);
IkReal x312=((1.0)*x309);
IkReal x313=(new_r22*x309);
IkReal x314=((1.0)*x310);
IkReal x315=x308;
IkReal x316=((1.0)*x315);
IkReal x317=(x310*x315);
evalcond[0]=(x310+((new_r11*x315))+((gconst38*new_r01)));
evalcond[1]=((((-1.0)*x312))+((new_r10*x315))+((gconst38*new_r00)));
evalcond[2]=(((gconst38*x310))+new_r01+((x313*x315)));
evalcond[3]=(x317+new_r11+(((-1.0)*x311*x312)));
evalcond[4]=((((-1.0)*new_r00*x316))+(((-1.0)*new_r22*x314))+((gconst38*new_r10)));
evalcond[5]=((((-1.0)*new_r22*x312))+((gconst38*new_r11))+(((-1.0)*new_r01*x316)));
evalcond[6]=(new_r00+(((-1.0)*gconst38*x312))+((new_r22*x317)));
evalcond[7]=((((-1.0)*x312*x315))+new_r10+(((-1.0)*x311*x314)));
evalcond[8]=((((-1.0)*new_r00*new_r22*x316))+(((-1.0)*x314))+((new_r10*x311)));
evalcond[9]=((((-1.0)*new_r01*new_r22*x316))+(((-1.0)*x312))+((new_r11*x311)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x318=new_r22*new_r22;
CheckValue<IkReal> x319=IKPowWithIntegerCheck(((-1.0)+x318),-1);
if(!x319.valid){
continue;
}
if(((x318*(x319.value))) < -0.00001)
continue;
IkReal gconst38=IKsqrt((x318*(x319.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj3+(((-1.0)*gconst38)))))+(IKabs(((1.0)+(IKsign(sj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if((((1.0)+(((-1.0)*(gconst38*gconst38))))) < -0.00001)
continue;
IkReal x320=IKsqrt(((1.0)+(((-1.0)*(gconst38*gconst38)))));
if( IKabs(((((-1.0)*gconst38*new_r01))+((new_r11*x320)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r10*x320))+((gconst38*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*gconst38*new_r01))+((new_r11*x320))))+IKsqr(((((-1.0)*new_r10*x320))+((gconst38*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*gconst38*new_r01))+((new_r11*x320))), ((((-1.0)*new_r10*x320))+((gconst38*new_r00))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[10];
IkReal x321=IKsin(j5);
IkReal x322=IKcos(j5);
IkReal x323=(gconst38*new_r22);
IkReal x324=((1.0)*x322);
IkReal x325=((1.0)*x321);
IkReal x326=(new_r22*x322);
IkReal x327=x320;
IkReal x328=((1.0)*x327);
IkReal x329=(new_r00*x327);
IkReal x330=(new_r01*x327);
evalcond[0]=(x321+((gconst38*new_r01))+(((-1.0)*new_r11*x328)));
evalcond[1]=((((-1.0)*x324))+((gconst38*new_r00))+(((-1.0)*new_r10*x328)));
evalcond[2]=((((-1.0)*new_r22*x325))+x329+((gconst38*new_r10)));
evalcond[3]=((((-1.0)*new_r22*x324))+x330+((gconst38*new_r11)));
evalcond[4]=(((gconst38*x321))+new_r01+(((-1.0)*new_r22*x324*x327)));
evalcond[5]=(((x322*x327))+(((-1.0)*x323*x325))+new_r10);
evalcond[6]=(((new_r22*x329))+(((-1.0)*x325))+((new_r10*x323)));
evalcond[7]=(((new_r22*x330))+(((-1.0)*x324))+((new_r11*x323)));
evalcond[8]=((((-1.0)*x325*x327))+(((-1.0)*x323*x324))+new_r11);
evalcond[9]=((((-1.0)*gconst38*x324))+(((-1.0)*new_r22*x325*x327))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x331=new_r22*new_r22;
CheckValue<IkReal> x332=IKPowWithIntegerCheck(((-1.0)+x331),-1);
if(!x332.valid){
continue;
}
if(((x331*(x332.value))) < -0.00001)
continue;
IkReal gconst39=((-1.0)*(IKsqrt((x331*(x332.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.0)+(IKsign(sj3)))))+(IKabs((cj3+(((-1.0)*gconst39)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if((((1.0)+(((-1.0)*(gconst39*gconst39))))) < -0.00001)
continue;
IkReal x333=IKsqrt(((1.0)+(((-1.0)*(gconst39*gconst39)))));
if( IKabs(((((-1.0)*gconst39*new_r01))+(((-1.0)*new_r11*x333)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r10*x333))+((gconst39*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*gconst39*new_r01))+(((-1.0)*new_r11*x333))))+IKsqr((((new_r10*x333))+((gconst39*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*gconst39*new_r01))+(((-1.0)*new_r11*x333))), (((new_r10*x333))+((gconst39*new_r00))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[10];
IkReal x334=IKsin(j5);
IkReal x335=IKcos(j5);
IkReal x336=(gconst39*new_r22);
IkReal x337=((1.0)*new_r01);
IkReal x338=((1.0)*x335);
IkReal x339=((1.0)*x334);
IkReal x340=x333;
IkReal x341=(new_r22*x340);
IkReal x342=((1.0)*new_r00*x340);
IkReal x343=(x334*x340);
evalcond[0]=(((new_r11*x340))+((gconst39*new_r01))+x334);
evalcond[1]=(((new_r10*x340))+((gconst39*new_r00))+(((-1.0)*x338)));
evalcond[2]=(((x335*x341))+((gconst39*x334))+new_r01);
evalcond[3]=(x343+new_r11+(((-1.0)*x336*x338)));
evalcond[4]=((((-1.0)*new_r22*x339))+((gconst39*new_r10))+(((-1.0)*x342)));
evalcond[5]=((((-1.0)*new_r22*x338))+(((-1.0)*x337*x340))+((gconst39*new_r11)));
evalcond[6]=((((-1.0)*gconst39*x338))+new_r00+((x334*x341)));
evalcond[7]=(new_r10+(((-1.0)*x338*x340))+(((-1.0)*x336*x339)));
evalcond[8]=((((-1.0)*new_r00*x341))+((new_r10*x336))+(((-1.0)*x339)));
evalcond[9]=((((-1.0)*x337*x341))+((new_r11*x336))+(((-1.0)*x338)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x344=new_r22*new_r22;
CheckValue<IkReal> x345=IKPowWithIntegerCheck(((-1.0)+x344),-1);
if(!x345.valid){
continue;
}
if(((x344*(x345.value))) < -0.00001)
continue;
IkReal gconst39=((-1.0)*(IKsqrt((x344*(x345.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj3+(((-1.0)*gconst39)))))+(IKabs(((1.0)+(IKsign(sj3)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if((((1.0)+(((-1.0)*(gconst39*gconst39))))) < -0.00001)
continue;
IkReal x346=IKsqrt(((1.0)+(((-1.0)*(gconst39*gconst39)))));
if( IKabs((((new_r11*x346))+(((-1.0)*gconst39*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r10*x346))+((gconst39*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r11*x346))+(((-1.0)*gconst39*new_r01))))+IKsqr(((((-1.0)*new_r10*x346))+((gconst39*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((new_r11*x346))+(((-1.0)*gconst39*new_r01))), ((((-1.0)*new_r10*x346))+((gconst39*new_r00))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[10];
IkReal x347=IKsin(j5);
IkReal x348=IKcos(j5);
IkReal x349=((1.0)*new_r22);
IkReal x350=(gconst39*new_r10);
IkReal x351=(gconst39*new_r11);
IkReal x352=((1.0)*x348);
IkReal x353=(gconst39*x348);
IkReal x354=(gconst39*x347);
IkReal x355=x346;
IkReal x356=((1.0)*x355);
IkReal x357=(new_r22*x355);
IkReal x358=(x347*x355);
IkReal x359=(x348*x355);
evalcond[0]=(((gconst39*new_r01))+x347+(((-1.0)*new_r11*x356)));
evalcond[1]=((((-1.0)*x352))+((gconst39*new_r00))+(((-1.0)*new_r10*x356)));
evalcond[2]=(x350+(((-1.0)*x347*x349))+((new_r00*x355)));
evalcond[3]=(((new_r01*x355))+(((-1.0)*x348*x349))+x351);
evalcond[4]=((((-1.0)*x349*x359))+x354+new_r01);
evalcond[5]=((((-1.0)*x349*x354))+x359+new_r10);
evalcond[6]=(((new_r22*x350))+(((-1.0)*x347))+((new_r00*x357)));
evalcond[7]=(((new_r01*x357))+((new_r22*x351))+(((-1.0)*x352)));
evalcond[8]=((((-1.0)*x349*x353))+(((-1.0)*x347*x356))+new_r11);
evalcond[9]=((((-1.0)*x349*x358))+(((-1.0)*gconst39*x352))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x360=((1.0)*cj3*new_r01);
CheckValue<IkReal> x361=IKPowWithIntegerCheck(cj3,-1);
if(!x361.valid){
continue;
}
CheckValue<IkReal> x362=IKPowWithIntegerCheck(new_r22,-1);
if(!x362.valid){
continue;
}
if( IKabs(((((-1.0)*x360))+(((-1.0)*new_r11*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x361.value)*(x362.value)*(((((-1.0)*sj3*x360))+((new_r11*(cj3*cj3))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x360))+(((-1.0)*new_r11*sj3))))+IKsqr(((x361.value)*(x362.value)*(((((-1.0)*sj3*x360))+((new_r11*(cj3*cj3)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*x360))+(((-1.0)*new_r11*sj3))), ((x361.value)*(x362.value)*(((((-1.0)*sj3*x360))+((new_r11*(cj3*cj3)))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[10];
IkReal x363=IKsin(j5);
IkReal x364=IKcos(j5);
IkReal x365=((1.0)*cj3);
IkReal x366=((1.0)*sj3);
IkReal x367=(cj3*new_r10);
IkReal x368=(cj3*new_r11);
IkReal x369=((1.0)*x364);
IkReal x370=(new_r22*x364);
IkReal x371=(sj3*x363);
IkReal x372=(new_r22*x363);
evalcond[0]=(((new_r11*sj3))+x363+((cj3*new_r01)));
evalcond[1]=(((new_r10*sj3))+(((-1.0)*x369))+((cj3*new_r00)));
evalcond[2]=(((sj3*x370))+new_r01+((cj3*x363)));
evalcond[3]=(x371+new_r11+(((-1.0)*x365*x370)));
evalcond[4]=((((-1.0)*x372))+(((-1.0)*new_r00*x366))+x367);
evalcond[5]=((((-1.0)*new_r22*x369))+x368+(((-1.0)*new_r01*x366)));
evalcond[6]=((((-1.0)*x364*x365))+new_r00+((new_r22*x371)));
evalcond[7]=((((-1.0)*x364*x366))+new_r10+(((-1.0)*x365*x372)));
evalcond[8]=(((new_r22*x367))+(((-1.0)*x363))+(((-1.0)*new_r00*new_r22*x366)));
evalcond[9]=(((new_r22*x368))+(((-1.0)*x369))+(((-1.0)*new_r01*new_r22*x366)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x373=((1.0)*new_r01);
CheckValue<IkReal> x374=IKPowWithIntegerCheck(new_r22,-1);
if(!x374.valid){
continue;
}
if( IKabs(((((-1.0)*cj3*x373))+(((-1.0)*new_r11*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x374.value)*(((((-1.0)*sj3*x373))+((cj3*new_r11)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj3*x373))+(((-1.0)*new_r11*sj3))))+IKsqr(((x374.value)*(((((-1.0)*sj3*x373))+((cj3*new_r11))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*cj3*x373))+(((-1.0)*new_r11*sj3))), ((x374.value)*(((((-1.0)*sj3*x373))+((cj3*new_r11))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[10];
IkReal x375=IKsin(j5);
IkReal x376=IKcos(j5);
IkReal x377=((1.0)*cj3);
IkReal x378=((1.0)*sj3);
IkReal x379=(cj3*new_r10);
IkReal x380=(cj3*new_r11);
IkReal x381=((1.0)*x376);
IkReal x382=(new_r22*x376);
IkReal x383=(sj3*x375);
IkReal x384=(new_r22*x375);
evalcond[0]=(((new_r11*sj3))+x375+((cj3*new_r01)));
evalcond[1]=(((new_r10*sj3))+(((-1.0)*x381))+((cj3*new_r00)));
evalcond[2]=(new_r01+((cj3*x375))+((sj3*x382)));
evalcond[3]=(x383+new_r11+(((-1.0)*x377*x382)));
evalcond[4]=((((-1.0)*new_r00*x378))+x379+(((-1.0)*x384)));
evalcond[5]=(x380+(((-1.0)*new_r22*x381))+(((-1.0)*new_r01*x378)));
evalcond[6]=(((new_r22*x383))+(((-1.0)*x376*x377))+new_r00);
evalcond[7]=((((-1.0)*x376*x378))+new_r10+(((-1.0)*x377*x384)));
evalcond[8]=((((-1.0)*x375))+(((-1.0)*new_r00*new_r22*x378))+((new_r22*x379)));
evalcond[9]=(((new_r22*x380))+(((-1.0)*x381))+(((-1.0)*new_r01*new_r22*x378)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x385=cj3*cj3;
IkReal x386=new_r22*new_r22;
IkReal x387=(new_r22*sj3);
CheckValue<IkReal> x388=IKPowWithIntegerCheck(IKsign(((((-1.0)*x385))+(((-1.0)*x386))+((x385*x386)))),-1);
if(!x388.valid){
continue;
}
CheckValue<IkReal> x389 = IKatan2WithCheck(IkReal((((new_r00*x387))+((cj3*new_r01)))),IkReal((((new_r01*x387))+(((-1.0)*cj3*new_r00)))),IKFAST_ATAN2_MAGTHRESH);
if(!x389.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x388.value)))+(x389.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[10];
IkReal x390=IKsin(j5);
IkReal x391=IKcos(j5);
IkReal x392=((1.0)*cj3);
IkReal x393=((1.0)*sj3);
IkReal x394=(cj3*new_r10);
IkReal x395=(cj3*new_r11);
IkReal x396=((1.0)*x391);
IkReal x397=(new_r22*x391);
IkReal x398=(sj3*x390);
IkReal x399=(new_r22*x390);
evalcond[0]=(((new_r11*sj3))+x390+((cj3*new_r01)));
evalcond[1]=((((-1.0)*x396))+((new_r10*sj3))+((cj3*new_r00)));
evalcond[2]=(((sj3*x397))+((cj3*x390))+new_r01);
evalcond[3]=(x398+new_r11+(((-1.0)*x392*x397)));
evalcond[4]=((((-1.0)*x399))+x394+(((-1.0)*new_r00*x393)));
evalcond[5]=((((-1.0)*new_r01*x393))+(((-1.0)*new_r22*x396))+x395);
evalcond[6]=((((-1.0)*x391*x392))+new_r00+((new_r22*x398)));
evalcond[7]=((((-1.0)*x391*x393))+new_r10+(((-1.0)*x392*x399)));
evalcond[8]=((((-1.0)*x390))+(((-1.0)*new_r00*new_r22*x393))+((new_r22*x394)));
evalcond[9]=((((-1.0)*x396))+(((-1.0)*new_r01*new_r22*x393))+((new_r22*x395)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x401=IKPowWithIntegerCheck(cj4,-1);
if(!x401.valid){
continue;
}
IkReal x400=x401.value;
CheckValue<IkReal> x402=IKPowWithIntegerCheck(new_r02,-1);
if(!x402.valid){
continue;
}
CheckValue<IkReal> x403=IKPowWithIntegerCheck(x400,-2);
if(!x403.valid){
continue;
}
if( IKabs((x400*(x402.value)*(((x403.value)+(((-1.0)*(new_r12*new_r12))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r12*x400)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x400*(x402.value)*(((x403.value)+(((-1.0)*(new_r12*new_r12)))))))+IKsqr(((-1.0)*new_r12*x400))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((x400*(x402.value)*(((x403.value)+(((-1.0)*(new_r12*new_r12)))))), ((-1.0)*new_r12*x400));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x404=IKsin(j3);
IkReal x405=IKcos(j3);
IkReal x406=(cj4*x405);
IkReal x407=(new_r12*x405);
IkReal x408=(new_r02*x404);
IkReal x409=((1.0)*cj4*x404);
evalcond[0]=(x406+new_r12);
evalcond[1]=(new_r02+(((-1.0)*x409)));
evalcond[2]=(((new_r12*x404))+((new_r02*x405)));
evalcond[3]=(cj4+x407+(((-1.0)*x408)));
evalcond[4]=(((new_r20*sj4))+((new_r10*x406))+(((-1.0)*new_r00*x409)));
evalcond[5]=(((new_r11*x406))+((new_r21*sj4))+(((-1.0)*new_r01*x409)));
evalcond[6]=(((cj4*new_r22))+(((-1.0)*sj4*x407))+((sj4*x408)));
evalcond[7]=((1.0)+((new_r22*sj4))+((new_r12*x406))+(((-1.0)*cj4*x408)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5eval[3];
j5eval[0]=cj4;
j5eval[1]=IKsign(cj4);
j5eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
j5eval[0]=cj4;
j5eval[1]=sj3;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[3];
j5eval[0]=cj4;
j5eval[1]=sj3;
j5eval[2]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x410=((1.0)*cj3);
if( IKabs(((((-1.0)*new_r11*sj3))+(((-1.0)*new_r01*x410)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj3))+(((-1.0)*new_r11*x410)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*sj3))+(((-1.0)*new_r01*x410))))+IKsqr((((new_r01*sj3))+(((-1.0)*new_r11*x410))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*new_r11*sj3))+(((-1.0)*new_r01*x410))), (((new_r01*sj3))+(((-1.0)*new_r11*x410))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x411=IKsin(j5);
IkReal x412=IKcos(j5);
IkReal x413=((1.0)*sj3);
IkReal x414=(cj3*x411);
IkReal x415=((1.0)*x412);
IkReal x416=(x412*x413);
evalcond[0]=(((new_r11*sj3))+x411+((cj3*new_r01)));
evalcond[1]=(x411+((cj3*new_r10))+(((-1.0)*new_r00*x413)));
evalcond[2]=(x412+((cj3*new_r11))+(((-1.0)*new_r01*x413)));
evalcond[3]=(((new_r10*sj3))+((cj3*new_r00))+(((-1.0)*x415)));
evalcond[4]=(((sj3*x411))+new_r11+((cj3*x412)));
evalcond[5]=(x414+new_r01+(((-1.0)*x416)));
evalcond[6]=(x414+new_r10+(((-1.0)*x416)));
evalcond[7]=((((-1.0)*cj3*x415))+(((-1.0)*x411*x413))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x417=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj3*x417))+(((-1.0)*new_r11*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj3*new_r11))+(((-1.0)*sj3*x417)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj3*x417))+(((-1.0)*new_r11*sj3))))+IKsqr((((cj3*new_r11))+(((-1.0)*sj3*x417))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*cj3*x417))+(((-1.0)*new_r11*sj3))), (((cj3*new_r11))+(((-1.0)*sj3*x417))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x418=IKsin(j5);
IkReal x419=IKcos(j5);
IkReal x420=((1.0)*sj3);
IkReal x421=((1.0)*x419);
IkReal x422=(sj3*x418);
IkReal x423=((1.0)*x418);
IkReal x424=(cj3*x421);
evalcond[0]=(((new_r11*sj3))+x418+((cj3*new_r01)));
evalcond[1]=(((new_r10*sj3))+(((-1.0)*x421))+((cj3*new_r00)));
evalcond[2]=(((sj3*x419))+new_r01+((cj3*x418)));
evalcond[3]=((((-1.0)*x424))+x422+new_r11);
evalcond[4]=((((-1.0)*new_r00*x420))+(((-1.0)*x423))+((cj3*new_r10)));
evalcond[5]=((((-1.0)*x421))+((cj3*new_r11))+(((-1.0)*new_r01*x420)));
evalcond[6]=((((-1.0)*x424))+x422+new_r00);
evalcond[7]=((((-1.0)*cj3*x423))+(((-1.0)*x419*x420))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-1.0)*new_r01), new_r00);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x425=IKcos(j5);
IkReal x426=IKsin(j5);
IkReal x427=((1.0)*cj4);
IkReal x428=((1.0)*sj4);
IkReal x429=((1.0)*x425);
evalcond[0]=(x426+new_r01);
evalcond[1]=((((-1.0)*x429))+new_r00);
evalcond[2]=(((sj4*x425))+new_r11);
evalcond[3]=(((sj4*x426))+new_r10);
evalcond[4]=((((-1.0)*x426*x427))+new_r20);
evalcond[5]=((((-1.0)*x425*x427))+new_r21);
evalcond[6]=((((-1.0)*x426))+((cj4*new_r20))+(((-1.0)*new_r10*x428)));
evalcond[7]=((((-1.0)*x429))+((cj4*new_r21))+(((-1.0)*new_r11*x428)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(new_r01, ((-1.0)*new_r00));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x430=IKsin(j5);
IkReal x431=IKcos(j5);
IkReal x432=((1.0)*cj4);
IkReal x433=((1.0)*x431);
evalcond[0]=(x430+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*x430*x432))+new_r20);
evalcond[2]=((((-1.0)*x431*x432))+new_r21);
evalcond[3]=(new_r11+(((-1.0)*sj4*x433)));
evalcond[4]=((((-1.0)*x433))+(((-1.0)*new_r00)));
evalcond[5]=(((sj4*x430))+(((-1.0)*new_r10)));
evalcond[6]=((((-1.0)*x430))+((new_r10*sj4))+((cj4*new_r20)));
evalcond[7]=((((-1.0)*x433))+((new_r11*sj4))+((cj4*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(new_r20, new_r21);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x434=IKsin(j5);
IkReal x435=IKcos(j5);
IkReal x436=((1.0)*x435);
IkReal x437=((1.0)*x434);
evalcond[0]=((((-1.0)*x437))+new_r20);
evalcond[1]=((((-1.0)*x436))+new_r21);
evalcond[2]=(((sj3*x434))+new_r11);
evalcond[3]=((((-1.0)*new_r12*x437))+new_r01);
evalcond[4]=((((-1.0)*sj3*x436))+new_r10);
evalcond[5]=((((-1.0)*cj3*x436))+new_r00);
evalcond[6]=(((new_r11*sj3))+x434+((cj3*new_r01)));
evalcond[7]=((((-1.0)*x436))+((new_r10*sj3))+((cj3*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20))+IKsqr(((-1.0)*new_r21))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-1.0)*new_r20), ((-1.0)*new_r21));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x438=IKsin(j5);
IkReal x439=IKcos(j5);
IkReal x440=((1.0)*x439);
evalcond[0]=(x438+new_r20);
evalcond[1]=(x439+new_r21);
evalcond[2]=(((sj3*x438))+new_r11);
evalcond[3]=(((new_r12*x438))+new_r01);
evalcond[4]=((((-1.0)*sj3*x440))+new_r10);
evalcond[5]=((((-1.0)*cj3*x440))+new_r00);
evalcond[6]=(((new_r11*sj3))+x438+((cj3*new_r01)));
evalcond[7]=((((-1.0)*x440))+((new_r10*sj3))+((cj3*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j5eval[0]=1.0;
if( IKabs(j5eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j5]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=1.0;
op[1]=0;
op[2]=-1.0;
polyroots2(op,zeror,numroots);
IkReal j5array[2], cj5array[2], sj5array[2], tempj5array[1];
int numsolutions = 0;
for(int ij5 = 0; ij5 < numroots; ++ij5)
{
IkReal htj5 = zeror[ij5];
tempj5array[0]=((2.0)*(atan(htj5)));
for(int kj5 = 0; kj5 < 1; ++kj5)
{
j5array[numsolutions] = tempj5array[kj5];
if( j5array[numsolutions] > IKPI )
{
    j5array[numsolutions]-=IK2PI;
}
else if( j5array[numsolutions] < -IKPI )
{
    j5array[numsolutions]+=IK2PI;
}
sj5array[numsolutions] = IKsin(j5array[numsolutions]);
cj5array[numsolutions] = IKcos(j5array[numsolutions]);
numsolutions++;
}
}
bool j5valid[2]={true,true};
_nj5 = 2;
for(int ij5 = 0; ij5 < numsolutions; ++ij5)
    {
if( !j5valid[ij5] )
{
    continue;
}
    j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
htj5 = IKtan(j5/2);

_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < numsolutions; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x442=IKPowWithIntegerCheck(cj4,-1);
if(!x442.valid){
continue;
}
IkReal x441=x442.value;
CheckValue<IkReal> x443=IKPowWithIntegerCheck(sj3,-1);
if(!x443.valid){
continue;
}
CheckValue<IkReal> x444=IKPowWithIntegerCheck(sj4,-1);
if(!x444.valid){
continue;
}
if( IKabs((new_r20*x441)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x441*(x443.value)*(x444.value)*((((cj4*new_r01))+((cj3*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r20*x441))+IKsqr((x441*(x443.value)*(x444.value)*((((cj4*new_r01))+((cj3*new_r20))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((new_r20*x441), (x441*(x443.value)*(x444.value)*((((cj4*new_r01))+((cj3*new_r20))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x445=IKsin(j5);
IkReal x446=IKcos(j5);
IkReal x447=(cj3*sj4);
IkReal x448=(sj3*sj4);
IkReal x449=((1.0)*sj3);
IkReal x450=((1.0)*x446);
IkReal x451=((1.0)*x445);
evalcond[0]=((((-1.0)*cj4*x451))+new_r20);
evalcond[1]=((((-1.0)*cj4*x450))+new_r21);
evalcond[2]=(((new_r11*sj3))+x445+((cj3*new_r01)));
evalcond[3]=(((new_r10*sj3))+(((-1.0)*x450))+((cj3*new_r00)));
evalcond[4]=(((x446*x447))+((sj3*x445))+new_r11);
evalcond[5]=(((sj4*x445))+(((-1.0)*new_r00*x449))+((cj3*new_r10)));
evalcond[6]=(((sj4*x446))+(((-1.0)*new_r01*x449))+((cj3*new_r11)));
evalcond[7]=(((cj3*x445))+new_r01+(((-1.0)*x448*x450)));
evalcond[8]=(((x445*x447))+new_r10+(((-1.0)*x446*x449)));
evalcond[9]=(new_r00+(((-1.0)*cj3*x450))+(((-1.0)*x448*x451)));
evalcond[10]=(((new_r00*x448))+((cj4*new_r20))+(((-1.0)*new_r10*x447))+(((-1.0)*x451)));
evalcond[11]=(((new_r01*x448))+((cj4*new_r21))+(((-1.0)*new_r11*x447))+(((-1.0)*x450)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x453=IKPowWithIntegerCheck(cj4,-1);
if(!x453.valid){
continue;
}
IkReal x452=x453.value;
CheckValue<IkReal> x454=IKPowWithIntegerCheck(sj3,-1);
if(!x454.valid){
continue;
}
if( IKabs((x452*(x454.value)*(((((-1.0)*cj4*new_r11))+(((-1.0)*cj3*new_r21*sj4)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r21*x452)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x452*(x454.value)*(((((-1.0)*cj4*new_r11))+(((-1.0)*cj3*new_r21*sj4))))))+IKsqr((new_r21*x452))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((x452*(x454.value)*(((((-1.0)*cj4*new_r11))+(((-1.0)*cj3*new_r21*sj4))))), (new_r21*x452));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x455=IKsin(j5);
IkReal x456=IKcos(j5);
IkReal x457=(cj3*sj4);
IkReal x458=(sj3*sj4);
IkReal x459=((1.0)*sj3);
IkReal x460=((1.0)*x456);
IkReal x461=((1.0)*x455);
evalcond[0]=((((-1.0)*cj4*x461))+new_r20);
evalcond[1]=((((-1.0)*cj4*x460))+new_r21);
evalcond[2]=(((new_r11*sj3))+x455+((cj3*new_r01)));
evalcond[3]=(((new_r10*sj3))+(((-1.0)*x460))+((cj3*new_r00)));
evalcond[4]=(((sj3*x455))+new_r11+((x456*x457)));
evalcond[5]=(((sj4*x455))+(((-1.0)*new_r00*x459))+((cj3*new_r10)));
evalcond[6]=((((-1.0)*new_r01*x459))+((sj4*x456))+((cj3*new_r11)));
evalcond[7]=(((cj3*x455))+(((-1.0)*x458*x460))+new_r01);
evalcond[8]=(((x455*x457))+(((-1.0)*x456*x459))+new_r10);
evalcond[9]=((((-1.0)*x458*x461))+new_r00+(((-1.0)*cj3*x460)));
evalcond[10]=(((new_r00*x458))+(((-1.0)*new_r10*x457))+((cj4*new_r20))+(((-1.0)*x461)));
evalcond[11]=(((new_r01*x458))+((cj4*new_r21))+(((-1.0)*new_r11*x457))+(((-1.0)*x460)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x462=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x462.valid){
continue;
}
CheckValue<IkReal> x463 = IKatan2WithCheck(IkReal(new_r20),IkReal(new_r21),IKFAST_ATAN2_MAGTHRESH);
if(!x463.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x462.value)))+(x463.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x464=IKsin(j5);
IkReal x465=IKcos(j5);
IkReal x466=(cj3*sj4);
IkReal x467=(sj3*sj4);
IkReal x468=((1.0)*sj3);
IkReal x469=((1.0)*x465);
IkReal x470=((1.0)*x464);
evalcond[0]=((((-1.0)*cj4*x470))+new_r20);
evalcond[1]=((((-1.0)*cj4*x469))+new_r21);
evalcond[2]=(((new_r11*sj3))+x464+((cj3*new_r01)));
evalcond[3]=(((new_r10*sj3))+(((-1.0)*x469))+((cj3*new_r00)));
evalcond[4]=(((sj3*x464))+((x465*x466))+new_r11);
evalcond[5]=((((-1.0)*new_r00*x468))+((sj4*x464))+((cj3*new_r10)));
evalcond[6]=((((-1.0)*new_r01*x468))+((sj4*x465))+((cj3*new_r11)));
evalcond[7]=(((cj3*x464))+new_r01+(((-1.0)*x467*x469)));
evalcond[8]=((((-1.0)*x465*x468))+new_r10+((x464*x466)));
evalcond[9]=((((-1.0)*x467*x470))+new_r00+(((-1.0)*cj3*x469)));
evalcond[10]=(((new_r00*x467))+((cj4*new_r20))+(((-1.0)*new_r10*x466))+(((-1.0)*x470)));
evalcond[11]=((((-1.0)*new_r11*x466))+((new_r01*x467))+((cj4*new_r21))+(((-1.0)*x469)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x471=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x471.valid){
continue;
}
CheckValue<IkReal> x472 = IKatan2WithCheck(IkReal(new_r02),IkReal(((-1.0)*new_r12)),IKFAST_ATAN2_MAGTHRESH);
if(!x472.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x471.value)))+(x472.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x473=IKsin(j3);
IkReal x474=IKcos(j3);
IkReal x475=(cj4*x474);
IkReal x476=(new_r12*x474);
IkReal x477=(new_r02*x473);
IkReal x478=((1.0)*cj4*x473);
evalcond[0]=(x475+new_r12);
evalcond[1]=((((-1.0)*x478))+new_r02);
evalcond[2]=(((new_r12*x473))+((new_r02*x474)));
evalcond[3]=(cj4+(((-1.0)*x477))+x476);
evalcond[4]=(((new_r20*sj4))+((new_r10*x475))+(((-1.0)*new_r00*x478)));
evalcond[5]=(((new_r11*x475))+(((-1.0)*new_r01*x478))+((new_r21*sj4)));
evalcond[6]=(((sj4*x477))+((cj4*new_r22))+(((-1.0)*sj4*x476)));
evalcond[7]=((1.0)+((new_r12*x475))+(((-1.0)*cj4*x477))+((new_r22*sj4)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5eval[3];
j5eval[0]=cj4;
j5eval[1]=IKsign(cj4);
j5eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
j5eval[0]=cj4;
j5eval[1]=sj3;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[3];
j5eval[0]=cj4;
j5eval[1]=sj3;
j5eval[2]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x479=((1.0)*cj3);
if( IKabs(((((-1.0)*new_r01*x479))+(((-1.0)*new_r11*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj3))+(((-1.0)*new_r11*x479)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r01*x479))+(((-1.0)*new_r11*sj3))))+IKsqr((((new_r01*sj3))+(((-1.0)*new_r11*x479))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*new_r01*x479))+(((-1.0)*new_r11*sj3))), (((new_r01*sj3))+(((-1.0)*new_r11*x479))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x480=IKsin(j5);
IkReal x481=IKcos(j5);
IkReal x482=((1.0)*sj3);
IkReal x483=(cj3*x480);
IkReal x484=((1.0)*x481);
IkReal x485=(x481*x482);
evalcond[0]=(((new_r11*sj3))+x480+((cj3*new_r01)));
evalcond[1]=((((-1.0)*new_r00*x482))+x480+((cj3*new_r10)));
evalcond[2]=((((-1.0)*new_r01*x482))+x481+((cj3*new_r11)));
evalcond[3]=(((new_r10*sj3))+(((-1.0)*x484))+((cj3*new_r00)));
evalcond[4]=(((cj3*x481))+new_r11+((sj3*x480)));
evalcond[5]=((((-1.0)*x485))+x483+new_r01);
evalcond[6]=((((-1.0)*x485))+x483+new_r10);
evalcond[7]=((((-1.0)*cj3*x484))+(((-1.0)*x480*x482))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x486=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj3*x486))+(((-1.0)*new_r11*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj3*x486))+((cj3*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj3*x486))+(((-1.0)*new_r11*sj3))))+IKsqr(((((-1.0)*sj3*x486))+((cj3*new_r11))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*cj3*x486))+(((-1.0)*new_r11*sj3))), ((((-1.0)*sj3*x486))+((cj3*new_r11))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x487=IKsin(j5);
IkReal x488=IKcos(j5);
IkReal x489=((1.0)*sj3);
IkReal x490=((1.0)*x488);
IkReal x491=(sj3*x487);
IkReal x492=((1.0)*x487);
IkReal x493=(cj3*x490);
evalcond[0]=(((new_r11*sj3))+x487+((cj3*new_r01)));
evalcond[1]=((((-1.0)*x490))+((new_r10*sj3))+((cj3*new_r00)));
evalcond[2]=(((cj3*x487))+new_r01+((sj3*x488)));
evalcond[3]=((((-1.0)*x493))+x491+new_r11);
evalcond[4]=((((-1.0)*x492))+(((-1.0)*new_r00*x489))+((cj3*new_r10)));
evalcond[5]=((((-1.0)*new_r01*x489))+(((-1.0)*x490))+((cj3*new_r11)));
evalcond[6]=((((-1.0)*x493))+x491+new_r00);
evalcond[7]=((((-1.0)*cj3*x492))+(((-1.0)*x488*x489))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-1.0)*new_r01), new_r00);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x494=IKcos(j5);
IkReal x495=IKsin(j5);
IkReal x496=((1.0)*cj4);
IkReal x497=((1.0)*sj4);
IkReal x498=((1.0)*x494);
evalcond[0]=(x495+new_r01);
evalcond[1]=((((-1.0)*x498))+new_r00);
evalcond[2]=(((sj4*x494))+new_r11);
evalcond[3]=(((sj4*x495))+new_r10);
evalcond[4]=((((-1.0)*x495*x496))+new_r20);
evalcond[5]=((((-1.0)*x494*x496))+new_r21);
evalcond[6]=((((-1.0)*new_r10*x497))+((cj4*new_r20))+(((-1.0)*x495)));
evalcond[7]=((((-1.0)*x498))+((cj4*new_r21))+(((-1.0)*new_r11*x497)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(new_r01, ((-1.0)*new_r00));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x499=IKsin(j5);
IkReal x500=IKcos(j5);
IkReal x501=((1.0)*cj4);
IkReal x502=((1.0)*x500);
evalcond[0]=(x499+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*x499*x501))+new_r20);
evalcond[2]=(new_r21+(((-1.0)*x500*x501)));
evalcond[3]=((((-1.0)*sj4*x502))+new_r11);
evalcond[4]=((((-1.0)*x502))+(((-1.0)*new_r00)));
evalcond[5]=(((sj4*x499))+(((-1.0)*new_r10)));
evalcond[6]=(((new_r10*sj4))+((cj4*new_r20))+(((-1.0)*x499)));
evalcond[7]=((((-1.0)*x502))+((new_r11*sj4))+((cj4*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(new_r20, new_r21);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x503=IKsin(j5);
IkReal x504=IKcos(j5);
IkReal x505=((1.0)*x504);
IkReal x506=((1.0)*x503);
evalcond[0]=((((-1.0)*x506))+new_r20);
evalcond[1]=((((-1.0)*x505))+new_r21);
evalcond[2]=(((sj3*x503))+new_r11);
evalcond[3]=(new_r01+(((-1.0)*new_r12*x506)));
evalcond[4]=((((-1.0)*sj3*x505))+new_r10);
evalcond[5]=((((-1.0)*cj3*x505))+new_r00);
evalcond[6]=(((new_r11*sj3))+x503+((cj3*new_r01)));
evalcond[7]=(((new_r10*sj3))+(((-1.0)*x505))+((cj3*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20))+IKsqr(((-1.0)*new_r21))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-1.0)*new_r20), ((-1.0)*new_r21));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x507=IKsin(j5);
IkReal x508=IKcos(j5);
IkReal x509=((1.0)*x508);
evalcond[0]=(x507+new_r20);
evalcond[1]=(x508+new_r21);
evalcond[2]=(((sj3*x507))+new_r11);
evalcond[3]=(((new_r12*x507))+new_r01);
evalcond[4]=((((-1.0)*sj3*x509))+new_r10);
evalcond[5]=((((-1.0)*cj3*x509))+new_r00);
evalcond[6]=(((new_r11*sj3))+x507+((cj3*new_r01)));
evalcond[7]=(((new_r10*sj3))+(((-1.0)*x509))+((cj3*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j5eval[0]=1.0;
if( IKabs(j5eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j5]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=1.0;
op[1]=0;
op[2]=-1.0;
polyroots2(op,zeror,numroots);
IkReal j5array[2], cj5array[2], sj5array[2], tempj5array[1];
int numsolutions = 0;
for(int ij5 = 0; ij5 < numroots; ++ij5)
{
IkReal htj5 = zeror[ij5];
tempj5array[0]=((2.0)*(atan(htj5)));
for(int kj5 = 0; kj5 < 1; ++kj5)
{
j5array[numsolutions] = tempj5array[kj5];
if( j5array[numsolutions] > IKPI )
{
    j5array[numsolutions]-=IK2PI;
}
else if( j5array[numsolutions] < -IKPI )
{
    j5array[numsolutions]+=IK2PI;
}
sj5array[numsolutions] = IKsin(j5array[numsolutions]);
cj5array[numsolutions] = IKcos(j5array[numsolutions]);
numsolutions++;
}
}
bool j5valid[2]={true,true};
_nj5 = 2;
for(int ij5 = 0; ij5 < numsolutions; ++ij5)
    {
if( !j5valid[ij5] )
{
    continue;
}
    j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
htj5 = IKtan(j5/2);

_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < numsolutions; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x511=IKPowWithIntegerCheck(cj4,-1);
if(!x511.valid){
continue;
}
IkReal x510=x511.value;
CheckValue<IkReal> x512=IKPowWithIntegerCheck(sj3,-1);
if(!x512.valid){
continue;
}
CheckValue<IkReal> x513=IKPowWithIntegerCheck(sj4,-1);
if(!x513.valid){
continue;
}
if( IKabs((new_r20*x510)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x510*(x512.value)*(x513.value)*((((cj4*new_r01))+((cj3*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r20*x510))+IKsqr((x510*(x512.value)*(x513.value)*((((cj4*new_r01))+((cj3*new_r20))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((new_r20*x510), (x510*(x512.value)*(x513.value)*((((cj4*new_r01))+((cj3*new_r20))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x514=IKsin(j5);
IkReal x515=IKcos(j5);
IkReal x516=(cj3*sj4);
IkReal x517=(sj3*sj4);
IkReal x518=((1.0)*sj3);
IkReal x519=((1.0)*x515);
IkReal x520=((1.0)*x514);
evalcond[0]=(new_r20+(((-1.0)*cj4*x520)));
evalcond[1]=((((-1.0)*cj4*x519))+new_r21);
evalcond[2]=(((new_r11*sj3))+x514+((cj3*new_r01)));
evalcond[3]=(((new_r10*sj3))+((cj3*new_r00))+(((-1.0)*x519)));
evalcond[4]=(((sj3*x514))+((x515*x516))+new_r11);
evalcond[5]=(((sj4*x514))+((cj3*new_r10))+(((-1.0)*new_r00*x518)));
evalcond[6]=(((sj4*x515))+(((-1.0)*new_r01*x518))+((cj3*new_r11)));
evalcond[7]=((((-1.0)*x517*x519))+((cj3*x514))+new_r01);
evalcond[8]=(((x514*x516))+(((-1.0)*x515*x518))+new_r10);
evalcond[9]=((((-1.0)*cj3*x519))+(((-1.0)*x517*x520))+new_r00);
evalcond[10]=(((new_r00*x517))+((cj4*new_r20))+(((-1.0)*x520))+(((-1.0)*new_r10*x516)));
evalcond[11]=(((new_r01*x517))+((cj4*new_r21))+(((-1.0)*new_r11*x516))+(((-1.0)*x519)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x522=IKPowWithIntegerCheck(cj4,-1);
if(!x522.valid){
continue;
}
IkReal x521=x522.value;
CheckValue<IkReal> x523=IKPowWithIntegerCheck(sj3,-1);
if(!x523.valid){
continue;
}
if( IKabs((x521*(x523.value)*(((((-1.0)*cj4*new_r11))+(((-1.0)*cj3*new_r21*sj4)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r21*x521)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x521*(x523.value)*(((((-1.0)*cj4*new_r11))+(((-1.0)*cj3*new_r21*sj4))))))+IKsqr((new_r21*x521))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((x521*(x523.value)*(((((-1.0)*cj4*new_r11))+(((-1.0)*cj3*new_r21*sj4))))), (new_r21*x521));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x524=IKsin(j5);
IkReal x525=IKcos(j5);
IkReal x526=(cj3*sj4);
IkReal x527=(sj3*sj4);
IkReal x528=((1.0)*sj3);
IkReal x529=((1.0)*x525);
IkReal x530=((1.0)*x524);
evalcond[0]=(new_r20+(((-1.0)*cj4*x530)));
evalcond[1]=(new_r21+(((-1.0)*cj4*x529)));
evalcond[2]=(((new_r11*sj3))+x524+((cj3*new_r01)));
evalcond[3]=(((new_r10*sj3))+(((-1.0)*x529))+((cj3*new_r00)));
evalcond[4]=(((sj3*x524))+((x525*x526))+new_r11);
evalcond[5]=((((-1.0)*new_r00*x528))+((cj3*new_r10))+((sj4*x524)));
evalcond[6]=((((-1.0)*new_r01*x528))+((cj3*new_r11))+((sj4*x525)));
evalcond[7]=((((-1.0)*x527*x529))+new_r01+((cj3*x524)));
evalcond[8]=((((-1.0)*x525*x528))+((x524*x526))+new_r10);
evalcond[9]=((((-1.0)*x527*x530))+(((-1.0)*cj3*x529))+new_r00);
evalcond[10]=(((cj4*new_r20))+(((-1.0)*x530))+(((-1.0)*new_r10*x526))+((new_r00*x527)));
evalcond[11]=(((new_r01*x527))+((cj4*new_r21))+(((-1.0)*x529))+(((-1.0)*new_r11*x526)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x531=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x531.valid){
continue;
}
CheckValue<IkReal> x532 = IKatan2WithCheck(IkReal(new_r20),IkReal(new_r21),IKFAST_ATAN2_MAGTHRESH);
if(!x532.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x531.value)))+(x532.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x533=IKsin(j5);
IkReal x534=IKcos(j5);
IkReal x535=(cj3*sj4);
IkReal x536=(sj3*sj4);
IkReal x537=((1.0)*sj3);
IkReal x538=((1.0)*x534);
IkReal x539=((1.0)*x533);
evalcond[0]=(new_r20+(((-1.0)*cj4*x539)));
evalcond[1]=(new_r21+(((-1.0)*cj4*x538)));
evalcond[2]=(((new_r11*sj3))+x533+((cj3*new_r01)));
evalcond[3]=(((new_r10*sj3))+(((-1.0)*x538))+((cj3*new_r00)));
evalcond[4]=(((sj3*x533))+((x534*x535))+new_r11);
evalcond[5]=((((-1.0)*new_r00*x537))+((cj3*new_r10))+((sj4*x533)));
evalcond[6]=((((-1.0)*new_r01*x537))+((cj3*new_r11))+((sj4*x534)));
evalcond[7]=(new_r01+((cj3*x533))+(((-1.0)*x536*x538)));
evalcond[8]=((((-1.0)*x534*x537))+new_r10+((x533*x535)));
evalcond[9]=((((-1.0)*cj3*x538))+new_r00+(((-1.0)*x536*x539)));
evalcond[10]=(((cj4*new_r20))+(((-1.0)*x539))+(((-1.0)*new_r10*x535))+((new_r00*x536)));
evalcond[11]=(((new_r01*x536))+((cj4*new_r21))+(((-1.0)*x538))+(((-1.0)*new_r11*x535)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x540=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x540.valid){
continue;
}
CheckValue<IkReal> x541 = IKatan2WithCheck(IkReal(new_r20),IkReal(new_r21),IKFAST_ATAN2_MAGTHRESH);
if(!x541.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x540.value)))+(x541.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x542=((1.0)*cj4);
evalcond[0]=((((-1.0)*x542*(IKsin(j5))))+new_r20);
evalcond[1]=((((-1.0)*x542*(IKcos(j5))))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[3];
j3eval[0]=cj4;
j3eval[1]=IKsign(cj4);
j3eval[2]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
j3eval[0]=cj4;
j3eval[1]=new_r11;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
IkReal x543=((1.0)*sj5);
IkReal x544=(((new_r10*new_r11))+((new_r00*new_r01)));
j3eval[0]=x544;
j3eval[1]=IKsign(x544);
j3eval[2]=((IKabs((((new_r01*sj5))+(((-1.0)*new_r10*x543)))))+(IKabs(((((-1.0)*new_r00*x543))+(((-1.0)*new_r11*x543))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
IkReal x545=((1.0)*sj5);
IkReal x546=((new_r01*new_r01)+(new_r11*new_r11));
j3eval[0]=x546;
j3eval[1]=((IKabs((((cj5*new_r01))+(((-1.0)*new_r11*x545)))))+(IKabs(((((-1.0)*new_r01*x545))+(((-1.0)*cj5*new_r11))))));
j3eval[2]=IKsign(x546);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
IkReal x547=(((new_r11*sj5))+((cj5*new_r01)));
j3eval[0]=x547;
j3eval[1]=IKsign(x547);
j3eval[2]=((IKabs(((((-1.0)*cj5*sj5))+(((-1.0)*new_r01*new_r11)))))+(IKabs(((-1.0)+(new_r01*new_r01)+(cj5*cj5)))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x549 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x549)==0){
continue;
}
IkReal x548=pow(x549,-0.5);
CheckValue<IkReal> x550 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x550.valid){
continue;
}
IkReal gconst32=((-1.0)*(x550.value));
IkReal gconst33=((-1.0)*new_r01*x548);
IkReal gconst34=(new_r11*x548);
CheckValue<IkReal> x551 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x551.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x551.value)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
CheckValue<IkReal> x554 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x554.valid){
continue;
}
IkReal x552=((-1.0)*(x554.value));
IkReal x553=x548;
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x552;
IkReal gconst32=x552;
IkReal gconst33=((-1.0)*new_r01*x553);
IkReal gconst34=(new_r11*x553);
IkReal x555=new_r01*new_r01;
IkReal x556=(new_r00*new_r01);
IkReal x557=(((new_r10*new_r11))+x556);
IkReal x558=x548;
IkReal x559=(new_r01*x558);
j3eval[0]=x557;
j3eval[1]=IKsign(x557);
j3eval[2]=((IKabs((((new_r11*x559))+((x556*x558)))))+(IKabs((((new_r10*x559))+(((-1.0)*x555*x558))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
CheckValue<IkReal> x562 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x562.valid){
continue;
}
IkReal x560=((-1.0)*(x562.value));
IkReal x561=x548;
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x560;
IkReal gconst32=x560;
IkReal gconst33=((-1.0)*new_r01*x561);
IkReal gconst34=(new_r11*x561);
IkReal x563=((new_r01*new_r01)+(new_r11*new_r11));
j3eval[0]=x563;
j3eval[1]=IKsign(x563);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x566 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x566.valid){
continue;
}
IkReal x564=((-1.0)*(x566.value));
IkReal x565=x548;
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x564;
IkReal gconst32=x564;
IkReal gconst33=((-1.0)*new_r01*x565);
IkReal gconst34=(new_r11*x565);
IkReal x567=new_r01*new_r01;
IkReal x568=new_r11*new_r11;
IkReal x569=((1.0)*x567);
CheckValue<IkReal> x575=IKPowWithIntegerCheck((x568+x567),-1);
if(!x575.valid){
continue;
}
IkReal x570=x575.value;
CheckValue<IkReal> x576=IKPowWithIntegerCheck(((((-1.0)*x568))+(((-1.0)*x569))),-1);
if(!x576.valid){
continue;
}
IkReal x571=x576.value;
IkReal x572=((1.0)*x571);
IkReal x573=(new_r11*x572);
IkReal x574=(new_r01*x572);
j3eval[0]=((IKabs(((((-1.0)*x573*(new_r01*new_r01*new_r01)))+(((-1.0)*new_r01*x573*(new_r11*new_r11)))+(((-1.0)*new_r01*x573)))))+(IKabs(((((-1.0)*x569*x570))+((x570*(x568*x568)))+((x567*x568*x570))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
CheckValue<IkReal> x578 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x578.valid){
continue;
}
IkReal x577=((-1.0)*(x578.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x577;
new_r11=0;
new_r00=0;
IkReal gconst32=x577;
IkReal x579 = new_r01*new_r01;
if(IKabs(x579)==0){
continue;
}
IkReal gconst33=((-1.0)*new_r01*(pow(x579,-0.5)));
IkReal gconst34=0;
j3eval[0]=new_r01;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x581 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x581.valid){
continue;
}
IkReal x580=((-1.0)*(x581.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x580;
new_r11=0;
new_r00=0;
IkReal gconst32=x580;
IkReal x582 = new_r01*new_r01;
if(IKabs(x582)==0){
continue;
}
IkReal gconst33=((-1.0)*new_r01*(pow(x582,-0.5)));
IkReal gconst34=0;
j3eval[0]=new_r10;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x583=IKPowWithIntegerCheck(gconst33,-1);
if(!x583.valid){
continue;
}
cj3array[0]=((-1.0)*new_r01*(x583.value));
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x584=IKsin(j3);
IkReal x585=IKcos(j3);
evalcond[0]=(new_r10*x584);
evalcond[1]=(gconst33*x584);
evalcond[2]=((-1.0)*new_r01*x584);
evalcond[3]=(gconst33+((new_r01*x585)));
evalcond[4]=(gconst33+((new_r10*x585)));
evalcond[5]=(((gconst33*x585))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x586=IKPowWithIntegerCheck(new_r10,-1);
if(!x586.valid){
continue;
}
cj3array[0]=((-1.0)*gconst33*(x586.value));
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x587=IKsin(j3);
IkReal x588=IKcos(j3);
IkReal x589=(gconst33*x588);
evalcond[0]=(new_r10*x587);
evalcond[1]=(gconst33*x587);
evalcond[2]=((-1.0)*new_r01*x587);
evalcond[3]=(gconst33+((new_r01*x588)));
evalcond[4]=(x589+new_r01);
evalcond[5]=(x589+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x590=IKPowWithIntegerCheck(new_r01,-1);
if(!x590.valid){
continue;
}
cj3array[0]=((-1.0)*gconst33*(x590.value));
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x591=IKsin(j3);
IkReal x592=IKcos(j3);
IkReal x593=(gconst33*x592);
evalcond[0]=(new_r10*x591);
evalcond[1]=(gconst33*x591);
evalcond[2]=((-1.0)*new_r01*x591);
evalcond[3]=(((new_r10*x592))+gconst33);
evalcond[4]=(x593+new_r01);
evalcond[5]=(x593+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst33;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
CheckValue<IkReal> x595 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x595.valid){
continue;
}
IkReal x594=((-1.0)*(x595.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x594;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst32=x594;
IkReal gconst33=((-1.0)*new_r01);
IkReal gconst34=new_r11;
j3eval[0]=-1.0;
j3eval[1]=-1.0;
j3eval[2]=((IKabs(new_r01*new_r01))+(IKabs((new_r01*new_r11))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
CheckValue<IkReal> x597 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x597.valid){
continue;
}
IkReal x596=((-1.0)*(x597.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x596;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst32=x596;
IkReal gconst33=((-1.0)*new_r01);
IkReal gconst34=new_r11;
j3eval[0]=-1.0;
j3eval[1]=-1.0;
j3eval[2]=((IKabs((new_r01*new_r11)))+(IKabs(((1.0)+(((-1.0)*(new_r01*new_r01)))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
CheckValue<IkReal> x599 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x599.valid){
continue;
}
IkReal x598=((-1.0)*(x599.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x598;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst32=x598;
IkReal gconst33=((-1.0)*new_r01);
IkReal gconst34=new_r11;
j3eval[0]=1.0;
j3eval[1]=((((0.5)*(IKabs(((-1.0)+(((2.0)*(new_r01*new_r01))))))))+(IKabs((new_r01*new_r11))));
j3eval[2]=1.0;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x600=((1.0)*new_r11);
CheckValue<IkReal> x601 = IKatan2WithCheck(IkReal(((((-1.0)*gconst33*x600))+((gconst34*new_r01)))),IkReal(((((-1.0)*gconst34*x600))+(((-1.0)*gconst33*new_r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x601.valid){
continue;
}
CheckValue<IkReal> x602=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x602.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x601.value)+(((1.5707963267949)*(x602.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x603=IKsin(j3);
IkReal x604=IKcos(j3);
IkReal x605=(gconst33*x604);
IkReal x606=((1.0)*x603);
IkReal x607=(gconst34*x604);
IkReal x608=(gconst34*x606);
evalcond[0]=(gconst33+((new_r11*x603))+((new_r01*x604)));
evalcond[1]=(x607+((gconst33*x603))+new_r11);
evalcond[2]=(x605+(((-1.0)*x608)));
evalcond[3]=(gconst34+((new_r11*x604))+(((-1.0)*new_r01*x606)));
evalcond[4]=(x605+(((-1.0)*x608))+new_r01);
evalcond[5]=((((-1.0)*x607))+(((-1.0)*gconst33*x606)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x609=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst33*gconst33)))+(((-1.0)*(gconst34*gconst34))))),-1);
if(!x609.valid){
continue;
}
CheckValue<IkReal> x610 = IKatan2WithCheck(IkReal((gconst33*new_r11)),IkReal((gconst34*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x610.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x609.value)))+(x610.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x611=IKsin(j3);
IkReal x612=IKcos(j3);
IkReal x613=(gconst33*x612);
IkReal x614=((1.0)*x611);
IkReal x615=(gconst34*x612);
IkReal x616=(gconst34*x614);
evalcond[0]=(gconst33+((new_r11*x611))+((new_r01*x612)));
evalcond[1]=(x615+new_r11+((gconst33*x611)));
evalcond[2]=((((-1.0)*x616))+x613);
evalcond[3]=(gconst34+((new_r11*x612))+(((-1.0)*new_r01*x614)));
evalcond[4]=((((-1.0)*x616))+x613+new_r01);
evalcond[5]=((((-1.0)*x615))+(((-1.0)*gconst33*x614)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x617=IKPowWithIntegerCheck(IKsign((((gconst33*new_r01))+(((-1.0)*gconst34*new_r11)))),-1);
if(!x617.valid){
continue;
}
CheckValue<IkReal> x618 = IKatan2WithCheck(IkReal((gconst33*gconst34)),IkReal(((-1.0)*(gconst33*gconst33))),IKFAST_ATAN2_MAGTHRESH);
if(!x618.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x617.value)))+(x618.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x619=IKsin(j3);
IkReal x620=IKcos(j3);
IkReal x621=(gconst33*x620);
IkReal x622=((1.0)*x619);
IkReal x623=(gconst34*x620);
IkReal x624=(gconst34*x622);
evalcond[0]=(gconst33+((new_r01*x620))+((new_r11*x619)));
evalcond[1]=(x623+new_r11+((gconst33*x619)));
evalcond[2]=((((-1.0)*x624))+x621);
evalcond[3]=((((-1.0)*new_r01*x622))+gconst34+((new_r11*x620)));
evalcond[4]=((((-1.0)*x624))+x621+new_r01);
evalcond[5]=((((-1.0)*gconst33*x622))+(((-1.0)*x623)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x625=IKPowWithIntegerCheck(gconst34,-1);
if(!x625.valid){
continue;
}
cj3array[0]=(new_r00*(x625.value));
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x626=IKsin(j3);
IkReal x627=IKcos(j3);
IkReal x628=((-1.0)*x626);
evalcond[0]=(new_r11*x626);
evalcond[1]=(new_r00*x628);
evalcond[2]=(gconst34*x628);
evalcond[3]=(new_r11+((gconst34*x627)));
evalcond[4]=(gconst34+((new_r11*x627)));
evalcond[5]=(((new_r00*x627))+(((-1.0)*gconst34)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
CheckValue<IkReal> x630 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x630.valid){
continue;
}
IkReal x629=((-1.0)*(x630.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x629;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst32=x629;
IkReal gconst33=0;
IkReal x631 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x631)==0){
continue;
}
IkReal gconst34=(new_r11*(pow(x631,-0.5)));
j3eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x633 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x633.valid){
continue;
}
IkReal x632=((-1.0)*(x633.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x632;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst32=x632;
IkReal gconst33=0;
IkReal x634 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x634)==0){
continue;
}
IkReal gconst34=(new_r11*(pow(x634,-0.5)));
j3eval[0]=new_r11;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x636 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x636.valid){
continue;
}
IkReal x635=((-1.0)*(x636.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x635;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst32=x635;
IkReal gconst33=0;
IkReal x637 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x637)==0){
continue;
}
IkReal gconst34=(new_r11*(pow(x637,-0.5)));
j3eval[0]=new_r10;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x638=IKPowWithIntegerCheck(new_r10,-1);
if(!x638.valid){
continue;
}
CheckValue<IkReal> x639=IKPowWithIntegerCheck(gconst34,-1);
if(!x639.valid){
continue;
}
if( IKabs((gconst34*(x638.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11*(x639.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst34*(x638.value)))+IKsqr(((-1.0)*new_r11*(x639.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((gconst34*(x638.value)), ((-1.0)*new_r11*(x639.value)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x640=IKsin(j3);
IkReal x641=IKcos(j3);
IkReal x642=((1.0)*gconst34);
IkReal x643=(gconst34*x641);
evalcond[0]=(new_r11*x640);
evalcond[1]=(new_r10*x641);
evalcond[2]=((-1.0)*gconst34*x640);
evalcond[3]=((-1.0)*x643);
evalcond[4]=(x643+new_r11);
evalcond[5]=(gconst34+((new_r11*x641)));
evalcond[6]=((((-1.0)*x640*x642))+new_r10);
evalcond[7]=((((-1.0)*x642))+((new_r10*x640)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x644=IKPowWithIntegerCheck(gconst34,-1);
if(!x644.valid){
continue;
}
CheckValue<IkReal> x645=IKPowWithIntegerCheck(new_r11,-1);
if(!x645.valid){
continue;
}
if( IKabs((new_r10*(x644.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst34*(x645.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x644.value)))+IKsqr(((-1.0)*gconst34*(x645.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((new_r10*(x644.value)), ((-1.0)*gconst34*(x645.value)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x646=IKsin(j3);
IkReal x647=IKcos(j3);
IkReal x648=((1.0)*gconst34);
IkReal x649=(gconst34*x647);
evalcond[0]=(new_r11*x646);
evalcond[1]=(new_r10*x647);
evalcond[2]=((-1.0)*gconst34*x646);
evalcond[3]=((-1.0)*x649);
evalcond[4]=(x649+new_r11);
evalcond[5]=(gconst34+((new_r11*x647)));
evalcond[6]=((((-1.0)*x646*x648))+new_r10);
evalcond[7]=((((-1.0)*x648))+((new_r10*x646)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x650 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x650.valid){
continue;
}
CheckValue<IkReal> x651=IKPowWithIntegerCheck(IKsign(gconst34),-1);
if(!x651.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x650.value)+(((1.5707963267949)*(x651.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x652=IKsin(j3);
IkReal x653=IKcos(j3);
IkReal x654=((1.0)*gconst34);
IkReal x655=(gconst34*x653);
evalcond[0]=(new_r11*x652);
evalcond[1]=(new_r10*x653);
evalcond[2]=((-1.0)*gconst34*x652);
evalcond[3]=((-1.0)*x655);
evalcond[4]=(x655+new_r11);
evalcond[5]=(gconst34+((new_r11*x653)));
evalcond[6]=(new_r10+(((-1.0)*x652*x654)));
evalcond[7]=((((-1.0)*x654))+((new_r10*x652)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
CheckValue<IkReal> x657 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x657.valid){
continue;
}
IkReal x656=((-1.0)*(x657.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x656;
new_r01=0;
IkReal gconst32=x656;
IkReal gconst33=0;
IkReal x658 = new_r11*new_r11;
if(IKabs(x658)==0){
continue;
}
IkReal gconst34=(new_r11*(pow(x658,-0.5)));
j3eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x660 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x660.valid){
continue;
}
IkReal x659=((-1.0)*(x660.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x659;
new_r01=0;
IkReal gconst32=x659;
IkReal gconst33=0;
IkReal x661 = new_r11*new_r11;
if(IKabs(x661)==0){
continue;
}
IkReal gconst34=(new_r11*(pow(x661,-0.5)));
j3eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x663 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x663.valid){
continue;
}
IkReal x662=((-1.0)*(x663.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst33;
cj5=gconst34;
j5=x662;
new_r01=0;
IkReal gconst32=x662;
IkReal gconst33=0;
IkReal x664 = new_r11*new_r11;
if(IKabs(x664)==0){
continue;
}
IkReal gconst34=(new_r11*(pow(x664,-0.5)));
j3eval[0]=new_r11;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x665=IKPowWithIntegerCheck(gconst34,-1);
if(!x665.valid){
continue;
}
CheckValue<IkReal> x666=IKPowWithIntegerCheck(new_r11,-1);
if(!x666.valid){
continue;
}
if( IKabs((new_r10*(x665.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst34*(x666.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x665.value)))+IKsqr(((-1.0)*gconst34*(x666.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((new_r10*(x665.value)), ((-1.0)*gconst34*(x666.value)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x667=IKsin(j3);
IkReal x668=IKcos(j3);
IkReal x669=((1.0)*gconst34);
evalcond[0]=(new_r11*x667);
evalcond[1]=((-1.0)*gconst34*x667);
evalcond[2]=(((gconst34*x668))+new_r11);
evalcond[3]=(gconst34+((new_r11*x668)));
evalcond[4]=((((-1.0)*x667*x669))+new_r10);
evalcond[5]=((((-1.0)*x668*x669))+new_r00);
evalcond[6]=(((new_r10*x668))+(((-1.0)*new_r00*x667)));
evalcond[7]=(((new_r10*x667))+(((-1.0)*x669))+((new_r00*x668)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x670 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x670.valid){
continue;
}
CheckValue<IkReal> x671=IKPowWithIntegerCheck(IKsign(gconst34),-1);
if(!x671.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x670.value)+(((1.5707963267949)*(x671.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x672=IKsin(j3);
IkReal x673=IKcos(j3);
IkReal x674=((1.0)*gconst34);
evalcond[0]=(new_r11*x672);
evalcond[1]=((-1.0)*gconst34*x672);
evalcond[2]=(((gconst34*x673))+new_r11);
evalcond[3]=(((new_r11*x673))+gconst34);
evalcond[4]=((((-1.0)*x672*x674))+new_r10);
evalcond[5]=(new_r00+(((-1.0)*x673*x674)));
evalcond[6]=(((new_r10*x673))+(((-1.0)*new_r00*x672)));
evalcond[7]=(((new_r00*x673))+((new_r10*x672))+(((-1.0)*x674)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x675 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x675.valid){
continue;
}
CheckValue<IkReal> x676=IKPowWithIntegerCheck(IKsign(gconst34),-1);
if(!x676.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x675.value)+(((1.5707963267949)*(x676.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x677=IKsin(j3);
IkReal x678=IKcos(j3);
IkReal x679=((1.0)*gconst34);
evalcond[0]=(new_r11*x677);
evalcond[1]=((-1.0)*gconst34*x677);
evalcond[2]=(((gconst34*x678))+new_r11);
evalcond[3]=(((new_r11*x678))+gconst34);
evalcond[4]=(new_r10+(((-1.0)*x677*x679)));
evalcond[5]=((((-1.0)*x678*x679))+new_r00);
evalcond[6]=(((new_r10*x678))+(((-1.0)*new_r00*x677)));
evalcond[7]=(((new_r00*x678))+((new_r10*x677))+(((-1.0)*x679)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x680=((1.0)*new_r11);
CheckValue<IkReal> x681 = IKatan2WithCheck(IkReal(((((-1.0)*new_r01*x680))+((gconst33*gconst34)))),IkReal(((((-1.0)*(gconst33*gconst33)))+(new_r11*new_r11))),IKFAST_ATAN2_MAGTHRESH);
if(!x681.valid){
continue;
}
CheckValue<IkReal> x682=IKPowWithIntegerCheck(IKsign((((gconst33*new_r01))+(((-1.0)*gconst34*x680)))),-1);
if(!x682.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x681.value)+(((1.5707963267949)*(x682.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x683=IKsin(j3);
IkReal x684=IKcos(j3);
IkReal x685=(gconst33*x684);
IkReal x686=((1.0)*x683);
IkReal x687=(gconst34*x684);
IkReal x688=(gconst34*x686);
evalcond[0]=(gconst33+((new_r01*x684))+((new_r11*x683)));
evalcond[1]=(((gconst33*x683))+x687+new_r11);
evalcond[2]=(gconst33+((new_r10*x684))+(((-1.0)*new_r00*x686)));
evalcond[3]=((((-1.0)*new_r01*x686))+gconst34+((new_r11*x684)));
evalcond[4]=((((-1.0)*x688))+x685+new_r01);
evalcond[5]=((((-1.0)*x688))+x685+new_r10);
evalcond[6]=(((new_r00*x684))+((new_r10*x683))+(((-1.0)*gconst34)));
evalcond[7]=((((-1.0)*gconst33*x686))+new_r00+(((-1.0)*x687)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x689=((1.0)*new_r11);
CheckValue<IkReal> x690 = IKatan2WithCheck(IkReal(((((-1.0)*gconst33*x689))+((gconst34*new_r01)))),IkReal(((((-1.0)*gconst33*new_r01))+(((-1.0)*gconst34*x689)))),IKFAST_ATAN2_MAGTHRESH);
if(!x690.valid){
continue;
}
CheckValue<IkReal> x691=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x691.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x690.value)+(((1.5707963267949)*(x691.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x692=IKsin(j3);
IkReal x693=IKcos(j3);
IkReal x694=(gconst33*x693);
IkReal x695=((1.0)*x692);
IkReal x696=(gconst34*x693);
IkReal x697=(gconst34*x695);
evalcond[0]=(gconst33+((new_r11*x692))+((new_r01*x693)));
evalcond[1]=(x696+((gconst33*x692))+new_r11);
evalcond[2]=(gconst33+((new_r10*x693))+(((-1.0)*new_r00*x695)));
evalcond[3]=((((-1.0)*new_r01*x695))+gconst34+((new_r11*x693)));
evalcond[4]=(x694+(((-1.0)*x697))+new_r01);
evalcond[5]=(x694+(((-1.0)*x697))+new_r10);
evalcond[6]=(((new_r10*x692))+((new_r00*x693))+(((-1.0)*gconst34)));
evalcond[7]=((((-1.0)*gconst33*x695))+new_r00+(((-1.0)*x696)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x698=((1.0)*gconst33);
CheckValue<IkReal> x699 = IKatan2WithCheck(IkReal((((gconst33*new_r01))+(((-1.0)*new_r10*x698)))),IkReal(((((-1.0)*new_r00*x698))+(((-1.0)*new_r11*x698)))),IKFAST_ATAN2_MAGTHRESH);
if(!x699.valid){
continue;
}
CheckValue<IkReal> x700=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x700.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x699.value)+(((1.5707963267949)*(x700.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x701=IKsin(j3);
IkReal x702=IKcos(j3);
IkReal x703=(gconst33*x702);
IkReal x704=((1.0)*x701);
IkReal x705=(gconst34*x702);
IkReal x706=(gconst34*x704);
evalcond[0]=(((new_r01*x702))+gconst33+((new_r11*x701)));
evalcond[1]=(((gconst33*x701))+x705+new_r11);
evalcond[2]=(gconst33+((new_r10*x702))+(((-1.0)*new_r00*x704)));
evalcond[3]=(gconst34+((new_r11*x702))+(((-1.0)*new_r01*x704)));
evalcond[4]=((((-1.0)*x706))+x703+new_r01);
evalcond[5]=((((-1.0)*x706))+x703+new_r10);
evalcond[6]=(((new_r00*x702))+((new_r10*x701))+(((-1.0)*gconst34)));
evalcond[7]=((((-1.0)*x705))+(((-1.0)*gconst33*x704))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x708 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x708)==0){
continue;
}
IkReal x707=pow(x708,-0.5);
CheckValue<IkReal> x709 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x709.valid){
continue;
}
IkReal gconst35=((3.14159265358979)+(((-1.0)*(x709.value))));
IkReal gconst36=((1.0)*new_r01*x707);
IkReal gconst37=((-1.0)*new_r11*x707);
CheckValue<IkReal> x710 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x710.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x710.value)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
CheckValue<IkReal> x713 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x713.valid){
continue;
}
IkReal x711=((1.0)*(x713.value));
IkReal x712=x707;
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x711)));
IkReal gconst35=((3.14159265358979)+(((-1.0)*x711)));
IkReal gconst36=((1.0)*new_r01*x712);
IkReal gconst37=((-1.0)*new_r11*x712);
IkReal x714=new_r01*new_r01;
IkReal x715=(((new_r10*new_r11))+((new_r00*new_r01)));
IkReal x716=x707;
IkReal x717=((1.0)*new_r01*x716);
j3eval[0]=x715;
j3eval[1]=((IKabs(((((-1.0)*new_r11*x717))+(((-1.0)*new_r00*x717)))))+(IKabs((((x714*x716))+(((-1.0)*new_r10*x717))))));
j3eval[2]=IKsign(x715);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
CheckValue<IkReal> x720 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x720.valid){
continue;
}
IkReal x718=((1.0)*(x720.value));
IkReal x719=x707;
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x718)));
IkReal gconst35=((3.14159265358979)+(((-1.0)*x718)));
IkReal gconst36=((1.0)*new_r01*x719);
IkReal gconst37=((-1.0)*new_r11*x719);
IkReal x721=((new_r01*new_r01)+(new_r11*new_r11));
j3eval[0]=x721;
j3eval[1]=IKsign(x721);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x724 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x724.valid){
continue;
}
IkReal x722=((1.0)*(x724.value));
IkReal x723=x707;
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x722)));
IkReal gconst35=((3.14159265358979)+(((-1.0)*x722)));
IkReal gconst36=((1.0)*new_r01*x723);
IkReal gconst37=((-1.0)*new_r11*x723);
IkReal x725=new_r01*new_r01;
IkReal x726=new_r11*new_r11;
IkReal x727=((1.0)*x725);
CheckValue<IkReal> x733=IKPowWithIntegerCheck((x725+x726),-1);
if(!x733.valid){
continue;
}
IkReal x728=x733.value;
CheckValue<IkReal> x734=IKPowWithIntegerCheck(((((-1.0)*x727))+(((-1.0)*x726))),-1);
if(!x734.valid){
continue;
}
IkReal x729=x734.value;
IkReal x730=((1.0)*x729);
IkReal x731=(new_r11*x730);
IkReal x732=(new_r01*x730);
j3eval[0]=((IKabs(((((-1.0)*x731*(new_r01*new_r01*new_r01)))+(((-1.0)*new_r01*x731*(new_r11*new_r11)))+(((-1.0)*new_r01*x731)))))+(IKabs(((((-1.0)*x727*x728))+((x728*(x726*x726)))+((x725*x726*x728))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
CheckValue<IkReal> x736 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x736.valid){
continue;
}
IkReal x735=((1.0)*(x736.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x735)));
new_r11=0;
new_r00=0;
IkReal gconst35=((3.14159265358979)+(((-1.0)*x735)));
IkReal x737 = new_r01*new_r01;
if(IKabs(x737)==0){
continue;
}
IkReal gconst36=((1.0)*new_r01*(pow(x737,-0.5)));
IkReal gconst37=0;
j3eval[0]=new_r01;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x739 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x739.valid){
continue;
}
IkReal x738=((1.0)*(x739.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x738)));
new_r11=0;
new_r00=0;
IkReal gconst35=((3.14159265358979)+(((-1.0)*x738)));
IkReal x740 = new_r01*new_r01;
if(IKabs(x740)==0){
continue;
}
IkReal gconst36=((1.0)*new_r01*(pow(x740,-0.5)));
IkReal gconst37=0;
j3eval[0]=new_r10;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x741=IKPowWithIntegerCheck(gconst36,-1);
if(!x741.valid){
continue;
}
cj3array[0]=((-1.0)*new_r01*(x741.value));
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x742=IKsin(j3);
IkReal x743=IKcos(j3);
evalcond[0]=(new_r10*x742);
evalcond[1]=(gconst36*x742);
evalcond[2]=((-1.0)*new_r01*x742);
evalcond[3]=(gconst36+((new_r01*x743)));
evalcond[4]=(gconst36+((new_r10*x743)));
evalcond[5]=(new_r10+((gconst36*x743)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x744=IKPowWithIntegerCheck(new_r10,-1);
if(!x744.valid){
continue;
}
cj3array[0]=((-1.0)*gconst36*(x744.value));
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x745=IKsin(j3);
IkReal x746=IKcos(j3);
IkReal x747=(gconst36*x746);
evalcond[0]=(new_r10*x745);
evalcond[1]=(gconst36*x745);
evalcond[2]=((-1.0)*new_r01*x745);
evalcond[3]=(gconst36+((new_r01*x746)));
evalcond[4]=(x747+new_r01);
evalcond[5]=(x747+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x748=IKPowWithIntegerCheck(new_r01,-1);
if(!x748.valid){
continue;
}
cj3array[0]=((-1.0)*gconst36*(x748.value));
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x749=IKsin(j3);
IkReal x750=IKcos(j3);
IkReal x751=(gconst36*x750);
evalcond[0]=(new_r10*x749);
evalcond[1]=(gconst36*x749);
evalcond[2]=((-1.0)*new_r01*x749);
evalcond[3]=(gconst36+((new_r10*x750)));
evalcond[4]=(x751+new_r01);
evalcond[5]=(x751+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst36;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[4];
CheckValue<IkReal> x753 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x753.valid){
continue;
}
IkReal x752=((1.0)*(x753.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x752)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst35=((3.14159265358979)+(((-1.0)*x752)));
IkReal gconst36=((1.0)*new_r01);
IkReal gconst37=((-1.0)*new_r11);
j3eval[0]=1.0;
j3eval[1]=1.0;
j3eval[2]=new_r01;
j3eval[3]=1.0;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  || IKabs(j3eval[3]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
CheckValue<IkReal> x755 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x755.valid){
continue;
}
IkReal x754=((1.0)*(x755.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x754)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst35=((3.14159265358979)+(((-1.0)*x754)));
IkReal gconst36=((1.0)*new_r01);
IkReal gconst37=((-1.0)*new_r11);
j3eval[0]=-1.0;
j3eval[1]=-1.0;
j3eval[2]=((IKabs(((-1.0)+(new_r01*new_r01))))+(IKabs(((1.0)*new_r01*new_r11))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
CheckValue<IkReal> x757 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x757.valid){
continue;
}
IkReal x756=((1.0)*(x757.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x756)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst35=((3.14159265358979)+(((-1.0)*x756)));
IkReal gconst36=((1.0)*new_r01);
IkReal gconst37=((-1.0)*new_r11);
j3eval[0]=1.0;
j3eval[1]=((IKabs(((2.0)*new_r01*new_r11)))+(IKabs(((1.0)+(((-2.0)*(new_r01*new_r01)))))));
j3eval[2]=1.0;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x758=((1.0)*new_r11);
CheckValue<IkReal> x759 = IKatan2WithCheck(IkReal((((gconst37*new_r01))+(((-1.0)*gconst36*x758)))),IkReal(((((-1.0)*gconst37*x758))+(((-1.0)*gconst36*new_r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x759.valid){
continue;
}
CheckValue<IkReal> x760=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x760.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x759.value)+(((1.5707963267949)*(x760.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x761=IKsin(j3);
IkReal x762=IKcos(j3);
IkReal x763=(gconst36*x762);
IkReal x764=(gconst36*x761);
IkReal x765=(gconst37*x762);
IkReal x766=((1.0)*x761);
IkReal x767=(gconst37*x766);
evalcond[0]=(((new_r11*x761))+gconst36+((new_r01*x762)));
evalcond[1]=(x764+x765+new_r11);
evalcond[2]=((((-1.0)*x767))+x763);
evalcond[3]=(((new_r11*x762))+gconst37+(((-1.0)*new_r01*x766)));
evalcond[4]=((((-1.0)*x767))+x763+new_r01);
evalcond[5]=((((-1.0)*x765))+(((-1.0)*x764)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x768=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst36*gconst36)))+(((-1.0)*(gconst37*gconst37))))),-1);
if(!x768.valid){
continue;
}
CheckValue<IkReal> x769 = IKatan2WithCheck(IkReal((gconst36*new_r11)),IkReal((gconst37*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x769.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x768.value)))+(x769.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x770=IKsin(j3);
IkReal x771=IKcos(j3);
IkReal x772=(gconst36*x771);
IkReal x773=(gconst36*x770);
IkReal x774=(gconst37*x771);
IkReal x775=((1.0)*x770);
IkReal x776=(gconst37*x775);
evalcond[0]=(gconst36+((new_r11*x770))+((new_r01*x771)));
evalcond[1]=(x773+x774+new_r11);
evalcond[2]=(x772+(((-1.0)*x776)));
evalcond[3]=((((-1.0)*new_r01*x775))+gconst37+((new_r11*x771)));
evalcond[4]=(x772+(((-1.0)*x776))+new_r01);
evalcond[5]=((((-1.0)*x773))+(((-1.0)*x774)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x777 = IKatan2WithCheck(IkReal((gconst36*gconst37)),IkReal(((-1.0)*(gconst36*gconst36))),IKFAST_ATAN2_MAGTHRESH);
if(!x777.valid){
continue;
}
CheckValue<IkReal> x778=IKPowWithIntegerCheck(IKsign((((gconst36*new_r01))+(((-1.0)*gconst37*new_r11)))),-1);
if(!x778.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x777.value)+(((1.5707963267949)*(x778.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x779=IKsin(j3);
IkReal x780=IKcos(j3);
IkReal x781=(gconst36*x780);
IkReal x782=(gconst36*x779);
IkReal x783=(gconst37*x780);
IkReal x784=((1.0)*x779);
IkReal x785=(gconst37*x784);
evalcond[0]=(gconst36+((new_r01*x780))+((new_r11*x779)));
evalcond[1]=(x782+x783+new_r11);
evalcond[2]=((((-1.0)*x785))+x781);
evalcond[3]=((((-1.0)*new_r01*x784))+((new_r11*x780))+gconst37);
evalcond[4]=((((-1.0)*x785))+x781+new_r01);
evalcond[5]=((((-1.0)*x782))+(((-1.0)*x783)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x786=IKPowWithIntegerCheck(gconst37,-1);
if(!x786.valid){
continue;
}
cj3array[0]=(new_r00*(x786.value));
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x787=IKsin(j3);
IkReal x788=IKcos(j3);
IkReal x789=((-1.0)*x787);
evalcond[0]=(new_r11*x787);
evalcond[1]=(new_r00*x789);
evalcond[2]=(gconst37*x789);
evalcond[3]=(((gconst37*x788))+new_r11);
evalcond[4]=(((new_r11*x788))+gconst37);
evalcond[5]=(((new_r00*x788))+(((-1.0)*gconst37)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
CheckValue<IkReal> x791 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x791.valid){
continue;
}
IkReal x790=((1.0)*(x791.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x790)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst35=((3.14159265358979)+(((-1.0)*x790)));
IkReal gconst36=0;
IkReal x792 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x792)==0){
continue;
}
IkReal gconst37=((-1.0)*new_r11*(pow(x792,-0.5)));
j3eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x794 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x794.valid){
continue;
}
IkReal x793=((1.0)*(x794.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x793)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst35=((3.14159265358979)+(((-1.0)*x793)));
IkReal gconst36=0;
IkReal x795 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x795)==0){
continue;
}
IkReal gconst37=((-1.0)*new_r11*(pow(x795,-0.5)));
j3eval[0]=new_r11;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x797 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x797.valid){
continue;
}
IkReal x796=((1.0)*(x797.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x796)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst35=((3.14159265358979)+(((-1.0)*x796)));
IkReal gconst36=0;
IkReal x798 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x798)==0){
continue;
}
IkReal gconst37=((-1.0)*new_r11*(pow(x798,-0.5)));
j3eval[0]=new_r10;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x799=IKPowWithIntegerCheck(new_r10,-1);
if(!x799.valid){
continue;
}
CheckValue<IkReal> x800=IKPowWithIntegerCheck(gconst37,-1);
if(!x800.valid){
continue;
}
if( IKabs((gconst37*(x799.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11*(x800.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst37*(x799.value)))+IKsqr(((-1.0)*new_r11*(x800.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((gconst37*(x799.value)), ((-1.0)*new_r11*(x800.value)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x801=IKsin(j3);
IkReal x802=IKcos(j3);
IkReal x803=(gconst37*x802);
IkReal x804=(gconst37*x801);
evalcond[0]=(new_r11*x801);
evalcond[1]=(new_r10*x802);
evalcond[2]=((-1.0)*x804);
evalcond[3]=((-1.0)*x803);
evalcond[4]=(new_r11+x803);
evalcond[5]=(gconst37+((new_r11*x802)));
evalcond[6]=((((-1.0)*x804))+new_r10);
evalcond[7]=(((new_r10*x801))+(((-1.0)*gconst37)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x805=IKPowWithIntegerCheck(gconst37,-1);
if(!x805.valid){
continue;
}
CheckValue<IkReal> x806=IKPowWithIntegerCheck(new_r11,-1);
if(!x806.valid){
continue;
}
if( IKabs((new_r10*(x805.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst37*(x806.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x805.value)))+IKsqr(((-1.0)*gconst37*(x806.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((new_r10*(x805.value)), ((-1.0)*gconst37*(x806.value)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x807=IKsin(j3);
IkReal x808=IKcos(j3);
IkReal x809=(gconst37*x808);
IkReal x810=(gconst37*x807);
evalcond[0]=(new_r11*x807);
evalcond[1]=(new_r10*x808);
evalcond[2]=((-1.0)*x810);
evalcond[3]=((-1.0)*x809);
evalcond[4]=(new_r11+x809);
evalcond[5]=(gconst37+((new_r11*x808)));
evalcond[6]=((((-1.0)*x810))+new_r10);
evalcond[7]=(((new_r10*x807))+(((-1.0)*gconst37)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x811=IKPowWithIntegerCheck(IKsign(gconst37),-1);
if(!x811.valid){
continue;
}
CheckValue<IkReal> x812 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x812.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x811.value)))+(x812.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x813=IKsin(j3);
IkReal x814=IKcos(j3);
IkReal x815=(gconst37*x814);
IkReal x816=(gconst37*x813);
evalcond[0]=(new_r11*x813);
evalcond[1]=(new_r10*x814);
evalcond[2]=((-1.0)*x816);
evalcond[3]=((-1.0)*x815);
evalcond[4]=(new_r11+x815);
evalcond[5]=(((new_r11*x814))+gconst37);
evalcond[6]=((((-1.0)*x816))+new_r10);
evalcond[7]=(((new_r10*x813))+(((-1.0)*gconst37)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
CheckValue<IkReal> x818 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x818.valid){
continue;
}
IkReal x817=((1.0)*(x818.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x817)));
new_r01=0;
IkReal gconst35=((3.14159265358979)+(((-1.0)*x817)));
IkReal gconst36=0;
IkReal x819 = new_r11*new_r11;
if(IKabs(x819)==0){
continue;
}
IkReal gconst37=((-1.0)*new_r11*(pow(x819,-0.5)));
j3eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x821 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x821.valid){
continue;
}
IkReal x820=((1.0)*(x821.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x820)));
new_r01=0;
IkReal gconst35=((3.14159265358979)+(((-1.0)*x820)));
IkReal gconst36=0;
IkReal x822 = new_r11*new_r11;
if(IKabs(x822)==0){
continue;
}
IkReal gconst37=((-1.0)*new_r11*(pow(x822,-0.5)));
j3eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
CheckValue<IkReal> x824 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x824.valid){
continue;
}
IkReal x823=((1.0)*(x824.value));
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=gconst36;
cj5=gconst37;
j5=((3.14159265)+(((-1.0)*x823)));
new_r01=0;
IkReal gconst35=((3.14159265358979)+(((-1.0)*x823)));
IkReal gconst36=0;
IkReal x825 = new_r11*new_r11;
if(IKabs(x825)==0){
continue;
}
IkReal gconst37=((-1.0)*new_r11*(pow(x825,-0.5)));
j3eval[0]=new_r11;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x826=IKPowWithIntegerCheck(gconst37,-1);
if(!x826.valid){
continue;
}
CheckValue<IkReal> x827=IKPowWithIntegerCheck(new_r11,-1);
if(!x827.valid){
continue;
}
if( IKabs((new_r10*(x826.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst37*(x827.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x826.value)))+IKsqr(((-1.0)*gconst37*(x827.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((new_r10*(x826.value)), ((-1.0)*gconst37*(x827.value)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x828=IKsin(j3);
IkReal x829=IKcos(j3);
IkReal x830=(gconst37*x829);
IkReal x831=(gconst37*x828);
evalcond[0]=(new_r11*x828);
evalcond[1]=((-1.0)*x831);
evalcond[2]=(new_r11+x830);
evalcond[3]=(gconst37+((new_r11*x829)));
evalcond[4]=((((-1.0)*x831))+new_r10);
evalcond[5]=((((-1.0)*x830))+new_r00);
evalcond[6]=(((new_r10*x829))+(((-1.0)*new_r00*x828)));
evalcond[7]=(((new_r10*x828))+((new_r00*x829))+(((-1.0)*gconst37)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x832=IKPowWithIntegerCheck(IKsign(gconst37),-1);
if(!x832.valid){
continue;
}
CheckValue<IkReal> x833 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x833.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x832.value)))+(x833.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x834=IKsin(j3);
IkReal x835=IKcos(j3);
IkReal x836=(gconst37*x835);
IkReal x837=(gconst37*x834);
evalcond[0]=(new_r11*x834);
evalcond[1]=((-1.0)*x837);
evalcond[2]=(new_r11+x836);
evalcond[3]=(((new_r11*x835))+gconst37);
evalcond[4]=((((-1.0)*x837))+new_r10);
evalcond[5]=((((-1.0)*x836))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x834))+((new_r10*x835)));
evalcond[7]=(((new_r00*x835))+(((-1.0)*gconst37))+((new_r10*x834)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x838=IKPowWithIntegerCheck(IKsign(gconst37),-1);
if(!x838.valid){
continue;
}
CheckValue<IkReal> x839 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x839.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x838.value)))+(x839.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x840=IKsin(j3);
IkReal x841=IKcos(j3);
IkReal x842=(gconst37*x841);
IkReal x843=(gconst37*x840);
evalcond[0]=(new_r11*x840);
evalcond[1]=((-1.0)*x843);
evalcond[2]=(new_r11+x842);
evalcond[3]=(gconst37+((new_r11*x841)));
evalcond[4]=((((-1.0)*x843))+new_r10);
evalcond[5]=((((-1.0)*x842))+new_r00);
evalcond[6]=(((new_r10*x841))+(((-1.0)*new_r00*x840)));
evalcond[7]=(((new_r10*x840))+((new_r00*x841))+(((-1.0)*gconst37)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x844=((1.0)*new_r11);
CheckValue<IkReal> x845 = IKatan2WithCheck(IkReal((((gconst36*gconst37))+(((-1.0)*new_r01*x844)))),IkReal(((((-1.0)*(gconst36*gconst36)))+(new_r11*new_r11))),IKFAST_ATAN2_MAGTHRESH);
if(!x845.valid){
continue;
}
CheckValue<IkReal> x846=IKPowWithIntegerCheck(IKsign(((((-1.0)*gconst37*x844))+((gconst36*new_r01)))),-1);
if(!x846.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x845.value)+(((1.5707963267949)*(x846.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x847=IKsin(j3);
IkReal x848=IKcos(j3);
IkReal x849=(gconst36*x848);
IkReal x850=(gconst36*x847);
IkReal x851=(gconst37*x848);
IkReal x852=((1.0)*x847);
IkReal x853=(gconst37*x852);
evalcond[0]=(gconst36+((new_r01*x848))+((new_r11*x847)));
evalcond[1]=(new_r11+x850+x851);
evalcond[2]=(((new_r10*x848))+gconst36+(((-1.0)*new_r00*x852)));
evalcond[3]=((((-1.0)*new_r01*x852))+gconst37+((new_r11*x848)));
evalcond[4]=((((-1.0)*x853))+new_r01+x849);
evalcond[5]=((((-1.0)*x853))+new_r10+x849);
evalcond[6]=(((new_r10*x847))+((new_r00*x848))+(((-1.0)*gconst37)));
evalcond[7]=((((-1.0)*x851))+(((-1.0)*x850))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x854=((1.0)*new_r11);
CheckValue<IkReal> x855 = IKatan2WithCheck(IkReal(((((-1.0)*gconst36*x854))+((gconst37*new_r01)))),IkReal(((((-1.0)*gconst36*new_r01))+(((-1.0)*gconst37*x854)))),IKFAST_ATAN2_MAGTHRESH);
if(!x855.valid){
continue;
}
CheckValue<IkReal> x856=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x856.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x855.value)+(((1.5707963267949)*(x856.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x857=IKsin(j3);
IkReal x858=IKcos(j3);
IkReal x859=(gconst36*x858);
IkReal x860=(gconst36*x857);
IkReal x861=(gconst37*x858);
IkReal x862=((1.0)*x857);
IkReal x863=(gconst37*x862);
evalcond[0]=(gconst36+((new_r11*x857))+((new_r01*x858)));
evalcond[1]=(new_r11+x861+x860);
evalcond[2]=((((-1.0)*new_r00*x862))+gconst36+((new_r10*x858)));
evalcond[3]=((((-1.0)*new_r01*x862))+gconst37+((new_r11*x858)));
evalcond[4]=((((-1.0)*x863))+new_r01+x859);
evalcond[5]=((((-1.0)*x863))+new_r10+x859);
evalcond[6]=(((new_r10*x857))+((new_r00*x858))+(((-1.0)*gconst37)));
evalcond[7]=((((-1.0)*x861))+(((-1.0)*x860))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x864=((1.0)*gconst36);
CheckValue<IkReal> x865 = IKatan2WithCheck(IkReal((((gconst36*new_r01))+(((-1.0)*new_r10*x864)))),IkReal(((((-1.0)*new_r00*x864))+(((-1.0)*new_r11*x864)))),IKFAST_ATAN2_MAGTHRESH);
if(!x865.valid){
continue;
}
CheckValue<IkReal> x866=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x866.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x865.value)+(((1.5707963267949)*(x866.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x867=IKsin(j3);
IkReal x868=IKcos(j3);
IkReal x869=(gconst36*x868);
IkReal x870=(gconst36*x867);
IkReal x871=(gconst37*x868);
IkReal x872=((1.0)*x867);
IkReal x873=(gconst37*x872);
evalcond[0]=(((new_r01*x868))+gconst36+((new_r11*x867)));
evalcond[1]=(new_r11+x870+x871);
evalcond[2]=((((-1.0)*new_r00*x872))+gconst36+((new_r10*x868)));
evalcond[3]=(gconst37+(((-1.0)*new_r01*x872))+((new_r11*x868)));
evalcond[4]=(new_r01+x869+(((-1.0)*x873)));
evalcond[5]=(new_r10+x869+(((-1.0)*x873)));
evalcond[6]=(((new_r00*x868))+((new_r10*x867))+(((-1.0)*gconst37)));
evalcond[7]=((((-1.0)*x870))+(((-1.0)*x871))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((new_r01*new_r01)+(new_r11*new_r11));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r01=0;
new_r11=0;
j3eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x875 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x875.valid){
continue;
}
IkReal x874=x875.value;
j3array[0]=((-1.0)*x874);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x874)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r00*(IKsin(j3))))+((new_r10*(IKcos(j3)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x876=IKcos(j3);
IkReal x877=IKsin(j3);
IkReal x878=((1.0)*x877);
evalcond[0]=(new_r11+x876);
evalcond[1]=(new_r01+(((-1.0)*x878)));
evalcond[2]=(new_r10+(((-1.0)*x878)));
evalcond[3]=((((-1.0)*x876))+new_r00);
evalcond[4]=(((new_r01*x876))+((new_r11*x877)));
evalcond[5]=((-1.0)+((new_r00*x876))+((new_r10*x877)));
evalcond[6]=((((-1.0)*new_r00*x878))+((new_r10*x876)));
evalcond[7]=((1.0)+(((-1.0)*new_r01*x878))+((new_r11*x876)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r01), ((-1.0)*new_r00));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x879=IKsin(j3);
IkReal x880=IKcos(j3);
IkReal x881=((1.0)*x879);
evalcond[0]=(new_r01+x879);
evalcond[1]=(new_r10+x879);
evalcond[2]=(new_r00+x880);
evalcond[3]=((((-1.0)*x880))+new_r11);
evalcond[4]=(((new_r01*x880))+((new_r11*x879)));
evalcond[5]=((1.0)+((new_r00*x880))+((new_r10*x879)));
evalcond[6]=(((new_r10*x880))+(((-1.0)*new_r00*x881)));
evalcond[7]=((-1.0)+((new_r11*x880))+(((-1.0)*new_r01*x881)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r11=0;
new_r00=0;
j3eval[0]=new_r01;
j3eval[1]=((IKabs(cj5))+(IKabs(sj5)));
j3eval[2]=IKsign(new_r01);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r11=0;
new_r00=0;
j3eval[0]=new_r01;
j3eval[1]=new_r10;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x882=IKPowWithIntegerCheck(new_r01,-1);
if(!x882.valid){
continue;
}
CheckValue<IkReal> x883=IKPowWithIntegerCheck(new_r10,-1);
if(!x883.valid){
continue;
}
if( IKabs((cj5*(x882.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*sj5*(x883.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((cj5*(x882.value)))+IKsqr(((-1.0)*sj5*(x883.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((cj5*(x882.value)), ((-1.0)*sj5*(x883.value)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[7];
IkReal x884=IKcos(j3);
IkReal x885=IKsin(j3);
IkReal x886=((1.0)*cj5);
IkReal x887=(sj5*x884);
IkReal x888=(x885*x886);
evalcond[0]=(sj5+((new_r01*x884)));
evalcond[1]=(sj5+((new_r10*x884)));
evalcond[2]=(cj5+(((-1.0)*new_r01*x885)));
evalcond[3]=(((new_r10*x885))+(((-1.0)*x886)));
evalcond[4]=(((sj5*x885))+((cj5*x884)));
evalcond[5]=((((-1.0)*x888))+new_r01+x887);
evalcond[6]=((((-1.0)*x888))+new_r10+x887);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x889=IKPowWithIntegerCheck(IKsign(new_r01),-1);
if(!x889.valid){
continue;
}
CheckValue<IkReal> x890 = IKatan2WithCheck(IkReal(cj5),IkReal(((-1.0)*sj5)),IKFAST_ATAN2_MAGTHRESH);
if(!x890.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x889.value)))+(x890.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[7];
IkReal x891=IKcos(j3);
IkReal x892=IKsin(j3);
IkReal x893=((1.0)*cj5);
IkReal x894=(sj5*x891);
IkReal x895=(x892*x893);
evalcond[0]=(sj5+((new_r01*x891)));
evalcond[1]=(sj5+((new_r10*x891)));
evalcond[2]=(cj5+(((-1.0)*new_r01*x892)));
evalcond[3]=(((new_r10*x892))+(((-1.0)*x893)));
evalcond[4]=(((sj5*x892))+((cj5*x891)));
evalcond[5]=((((-1.0)*x895))+new_r01+x894);
evalcond[6]=((((-1.0)*x895))+new_r10+x894);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r11=0;
new_r01=0;
new_r22=0;
new_r20=0;
j3eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j3]

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x897 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x897.valid){
continue;
}
IkReal x896=x897.value;
j3array[0]=((-1.0)*x896);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x896)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r00*(IKsin(j3))))+((new_r10*(IKcos(j3)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
j3eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j3]

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x899 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x899.valid){
continue;
}
IkReal x898=x899.value;
j3array[0]=((-1.0)*x898);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x898)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
evalcond[0]=(((new_r11*(IKcos(j3))))+(((-1.0)*new_r01*(IKsin(j3)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r01=0;
new_r10=0;
j3eval[0]=new_r11;
j3eval[1]=IKsign(new_r11);
j3eval[2]=((IKabs(cj5))+(IKabs(sj5)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r01=0;
new_r10=0;
j3eval[0]=new_r00;
j3eval[1]=new_r11;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r01=0;
new_r10=0;
j3eval[0]=new_r11;
j3eval[1]=cj5;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=new_r00;
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x900=IKcos(j3);
IkReal x901=IKsin(j3);
evalcond[0]=x900;
evalcond[1]=(new_r00*x900);
evalcond[2]=(new_r11+x901);
evalcond[3]=(new_r11*x900);
evalcond[4]=((1.0)+((new_r11*x901)));
evalcond[5]=((1.0)+(((-1.0)*new_r00*x901)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=new_r11;
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x902=IKcos(j3);
IkReal x903=IKsin(j3);
evalcond[0]=(new_r00*x902);
evalcond[1]=(new_r11*x902);
evalcond[2]=((-1.0)*x902);
evalcond[3]=(new_r00+x903);
evalcond[4]=((-1.0)+((new_r11*x903)));
evalcond[5]=((-1.0)+(((-1.0)*new_r00*x903)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x905=IKPowWithIntegerCheck(new_r11,-1);
if(!x905.valid){
continue;
}
IkReal x904=x905.value;
CheckValue<IkReal> x906=IKPowWithIntegerCheck(cj5,-1);
if(!x906.valid){
continue;
}
CheckValue<IkReal> x907=IKPowWithIntegerCheck(x904,-2);
if(!x907.valid){
continue;
}
if( IKabs(((-1.0)*sj5*x904)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x904*(x906.value)*(((1.0)+(((-1.0)*(cj5*cj5)))+(((-1.0)*(x907.value))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*sj5*x904))+IKsqr((x904*(x906.value)*(((1.0)+(((-1.0)*(cj5*cj5)))+(((-1.0)*(x907.value)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*sj5*x904), (x904*(x906.value)*(((1.0)+(((-1.0)*(cj5*cj5)))+(((-1.0)*(x907.value)))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[7];
IkReal x908=IKsin(j3);
IkReal x909=IKcos(j3);
IkReal x910=((1.0)*cj5);
IkReal x911=(sj5*x908);
evalcond[0]=(sj5+((new_r11*x908)));
evalcond[1]=(cj5+((new_r11*x909)));
evalcond[2]=(sj5+(((-1.0)*new_r00*x908)));
evalcond[3]=((((-1.0)*x910))+((new_r00*x909)));
evalcond[4]=(((cj5*x909))+new_r11+x911);
evalcond[5]=((((-1.0)*x908*x910))+((sj5*x909)));
evalcond[6]=((((-1.0)*x911))+new_r00+(((-1.0)*x909*x910)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x912=IKPowWithIntegerCheck(new_r00,-1);
if(!x912.valid){
continue;
}
CheckValue<IkReal> x913=IKPowWithIntegerCheck(new_r11,-1);
if(!x913.valid){
continue;
}
if( IKabs((sj5*(x912.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*cj5*(x913.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((sj5*(x912.value)))+IKsqr(((-1.0)*cj5*(x913.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((sj5*(x912.value)), ((-1.0)*cj5*(x913.value)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[7];
IkReal x914=IKsin(j3);
IkReal x915=IKcos(j3);
IkReal x916=((1.0)*cj5);
IkReal x917=(sj5*x914);
evalcond[0]=(sj5+((new_r11*x914)));
evalcond[1]=(cj5+((new_r11*x915)));
evalcond[2]=(sj5+(((-1.0)*new_r00*x914)));
evalcond[3]=((((-1.0)*x916))+((new_r00*x915)));
evalcond[4]=(((cj5*x915))+new_r11+x917);
evalcond[5]=(((sj5*x915))+(((-1.0)*x914*x916)));
evalcond[6]=((((-1.0)*x917))+new_r00+(((-1.0)*x915*x916)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x918 = IKatan2WithCheck(IkReal(((-1.0)*sj5)),IkReal(((-1.0)*cj5)),IKFAST_ATAN2_MAGTHRESH);
if(!x918.valid){
continue;
}
CheckValue<IkReal> x919=IKPowWithIntegerCheck(IKsign(new_r11),-1);
if(!x919.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x918.value)+(((1.5707963267949)*(x919.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[7];
IkReal x920=IKsin(j3);
IkReal x921=IKcos(j3);
IkReal x922=((1.0)*cj5);
IkReal x923=(sj5*x920);
evalcond[0]=(sj5+((new_r11*x920)));
evalcond[1]=(cj5+((new_r11*x921)));
evalcond[2]=(sj5+(((-1.0)*new_r00*x920)));
evalcond[3]=((((-1.0)*x922))+((new_r00*x921)));
evalcond[4]=(new_r11+x923+((cj5*x921)));
evalcond[5]=(((sj5*x921))+(((-1.0)*x920*x922)));
evalcond[6]=((((-1.0)*x923))+(((-1.0)*x921*x922))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x924 = IKatan2WithCheck(IkReal(((-1.0)+(new_r01*new_r01)+(cj5*cj5))),IkReal(((((-1.0)*cj5*sj5))+(((-1.0)*new_r01*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x924.valid){
continue;
}
CheckValue<IkReal> x925=IKPowWithIntegerCheck(IKsign((((new_r11*sj5))+((cj5*new_r01)))),-1);
if(!x925.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x924.value)+(((1.5707963267949)*(x925.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x926=IKsin(j3);
IkReal x927=IKcos(j3);
IkReal x928=((1.0)*cj5);
IkReal x929=(sj5*x927);
IkReal x930=(sj5*x926);
IkReal x931=((1.0)*x926);
IkReal x932=(x926*x928);
evalcond[0]=(sj5+((new_r01*x927))+((new_r11*x926)));
evalcond[1]=(new_r11+x930+((cj5*x927)));
evalcond[2]=(sj5+(((-1.0)*new_r00*x931))+((new_r10*x927)));
evalcond[3]=(cj5+(((-1.0)*new_r01*x931))+((new_r11*x927)));
evalcond[4]=(new_r01+x929+(((-1.0)*x932)));
evalcond[5]=(new_r10+x929+(((-1.0)*x932)));
evalcond[6]=((((-1.0)*x928))+((new_r00*x927))+((new_r10*x926)));
evalcond[7]=((((-1.0)*x927*x928))+(((-1.0)*x930))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x933=((1.0)*sj5);
CheckValue<IkReal> x934=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x934.valid){
continue;
}
CheckValue<IkReal> x935 = IKatan2WithCheck(IkReal(((((-1.0)*new_r11*x933))+((cj5*new_r01)))),IkReal(((((-1.0)*new_r01*x933))+(((-1.0)*cj5*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x935.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x934.value)))+(x935.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x936=IKsin(j3);
IkReal x937=IKcos(j3);
IkReal x938=((1.0)*cj5);
IkReal x939=(sj5*x937);
IkReal x940=(sj5*x936);
IkReal x941=((1.0)*x936);
IkReal x942=(x936*x938);
evalcond[0]=(sj5+((new_r01*x937))+((new_r11*x936)));
evalcond[1]=(new_r11+x940+((cj5*x937)));
evalcond[2]=(sj5+((new_r10*x937))+(((-1.0)*new_r00*x941)));
evalcond[3]=(cj5+(((-1.0)*new_r01*x941))+((new_r11*x937)));
evalcond[4]=((((-1.0)*x942))+new_r01+x939);
evalcond[5]=((((-1.0)*x942))+new_r10+x939);
evalcond[6]=(((new_r00*x937))+((new_r10*x936))+(((-1.0)*x938)));
evalcond[7]=((((-1.0)*x940))+(((-1.0)*x937*x938))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x943=((1.0)*sj5);
CheckValue<IkReal> x944 = IKatan2WithCheck(IkReal((((new_r01*sj5))+(((-1.0)*new_r10*x943)))),IkReal(((((-1.0)*new_r11*x943))+(((-1.0)*new_r00*x943)))),IKFAST_ATAN2_MAGTHRESH);
if(!x944.valid){
continue;
}
CheckValue<IkReal> x945=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x945.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x944.value)+(((1.5707963267949)*(x945.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x946=IKsin(j3);
IkReal x947=IKcos(j3);
IkReal x948=((1.0)*cj5);
IkReal x949=(sj5*x947);
IkReal x950=(sj5*x946);
IkReal x951=((1.0)*x946);
IkReal x952=(x946*x948);
evalcond[0]=(sj5+((new_r01*x947))+((new_r11*x946)));
evalcond[1]=(new_r11+x950+((cj5*x947)));
evalcond[2]=(sj5+(((-1.0)*new_r00*x951))+((new_r10*x947)));
evalcond[3]=(cj5+(((-1.0)*new_r01*x951))+((new_r11*x947)));
evalcond[4]=(new_r01+(((-1.0)*x952))+x949);
evalcond[5]=(new_r10+(((-1.0)*x952))+x949);
evalcond[6]=((((-1.0)*x948))+((new_r00*x947))+((new_r10*x946)));
evalcond[7]=((((-1.0)*x947*x948))+(((-1.0)*x950))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x953=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj5*x953))+(((-1.0)*new_r11*sj5)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj5*new_r11))+(((-1.0)*sj5*x953)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj5*x953))+(((-1.0)*new_r11*sj5))))+IKsqr((((cj5*new_r11))+(((-1.0)*sj5*x953))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*cj5*x953))+(((-1.0)*new_r11*sj5))), (((cj5*new_r11))+(((-1.0)*sj5*x953))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x954=IKcos(j3);
IkReal x955=IKsin(j3);
IkReal x956=((1.0)*cj5);
IkReal x957=(sj5*x955);
IkReal x958=(sj5*x954);
IkReal x959=((1.0)*x955);
IkReal x960=(x954*x956);
evalcond[0]=(sj5+((new_r01*x954))+((new_r11*x955)));
evalcond[1]=(((cj5*x955))+new_r01+x958);
evalcond[2]=(new_r11+x957+(((-1.0)*x960)));
evalcond[3]=(new_r00+x957+(((-1.0)*x960)));
evalcond[4]=(((new_r10*x955))+((new_r00*x954))+(((-1.0)*x956)));
evalcond[5]=((((-1.0)*x958))+new_r10+(((-1.0)*x955*x956)));
evalcond[6]=(((new_r10*x954))+(((-1.0)*sj5))+(((-1.0)*new_r00*x959)));
evalcond[7]=((((-1.0)*new_r01*x959))+(((-1.0)*x956))+((new_r11*x954)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j3eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j3eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j3eval[0]=((IKabs((new_r10*new_r22)))+(IKabs((new_r00*new_r22))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j3]

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x962 = IKatan2WithCheck(IkReal((new_r10*new_r22)),IkReal(((-1.0)*new_r00*new_r22)),IKFAST_ATAN2_MAGTHRESH);
if(!x962.valid){
continue;
}
IkReal x961=x962.value;
j3array[0]=((-1.0)*x961);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x961)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[5];
IkReal x963=IKsin(j3);
IkReal x964=IKcos(j3);
IkReal x965=(new_r11*x964);
IkReal x966=((1.0)*x963);
evalcond[0]=(((new_r11*x963))+((new_r01*x964)));
evalcond[1]=(((new_r00*x964))+((new_r10*x963)));
evalcond[2]=((((-1.0)*new_r00*x966))+((new_r10*x964)));
evalcond[3]=((((-1.0)*new_r01*x966))+x965);
evalcond[4]=((((-1.0)*new_r01*new_r22*x966))+((new_r22*x965)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x968 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x968.valid){
continue;
}
IkReal x967=x968.value;
j3array[0]=((-1.0)*x967);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x967)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[5];
IkReal x969=IKcos(j3);
IkReal x970=IKsin(j3);
IkReal x971=(new_r11*x969);
IkReal x972=(new_r10*x969);
IkReal x973=((1.0)*x970);
evalcond[0]=(((new_r01*x969))+((new_r11*x970)));
evalcond[1]=((((-1.0)*new_r00*x973))+x972);
evalcond[2]=((((-1.0)*new_r01*x973))+x971);
evalcond[3]=((((-1.0)*new_r00*new_r22*x973))+((new_r22*x972)));
evalcond[4]=((((-1.0)*new_r01*new_r22*x973))+((new_r22*x971)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x975 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x975.valid){
continue;
}
IkReal x974=x975.value;
j3array[0]=((-1.0)*x974);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x974)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[5];
IkReal x976=IKcos(j3);
IkReal x977=IKsin(j3);
IkReal x978=(new_r11*x976);
IkReal x979=(new_r10*x976);
IkReal x980=((1.0)*x977);
evalcond[0]=(((new_r10*x977))+((new_r00*x976)));
evalcond[1]=((((-1.0)*new_r00*x980))+x979);
evalcond[2]=((((-1.0)*new_r01*x980))+x978);
evalcond[3]=(((new_r22*x979))+(((-1.0)*new_r00*new_r22*x980)));
evalcond[4]=((((-1.0)*new_r01*new_r22*x980))+((new_r22*x978)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x982=IKPowWithIntegerCheck(cj4,-1);
if(!x982.valid){
continue;
}
IkReal x981=x982.value;
CheckValue<IkReal> x983=IKPowWithIntegerCheck(new_r11,-1);
if(!x983.valid){
continue;
}
if( IKabs((x981*(x983.value)*(((((-1.0)*cj4*sj5))+((new_r01*new_r12)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r12*x981)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x981*(x983.value)*(((((-1.0)*cj4*sj5))+((new_r01*new_r12))))))+IKsqr(((-1.0)*new_r12*x981))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((x981*(x983.value)*(((((-1.0)*cj4*sj5))+((new_r01*new_r12))))), ((-1.0)*new_r12*x981));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[18];
IkReal x984=IKsin(j3);
IkReal x985=IKcos(j3);
IkReal x986=((1.0)*cj5);
IkReal x987=(cj5*sj4);
IkReal x988=((1.0)*sj5);
IkReal x989=(sj4*x984);
IkReal x990=(sj5*x985);
IkReal x991=(new_r11*x985);
IkReal x992=(new_r12*x985);
IkReal x993=(new_r10*x985);
IkReal x994=((1.0)*x984);
IkReal x995=((1.0)*sj4*x985);
IkReal x996=(new_r00*x994);
IkReal x997=(cj4*x994);
evalcond[0]=(((cj4*x985))+new_r12);
evalcond[1]=((((-1.0)*x997))+new_r02);
evalcond[2]=(((new_r02*x985))+((new_r12*x984)));
evalcond[3]=(sj5+((new_r11*x984))+((new_r01*x985)));
evalcond[4]=(cj4+(((-1.0)*new_r02*x994))+x992);
evalcond[5]=(((sj5*x984))+new_r11+((x985*x987)));
evalcond[6]=(((new_r00*x985))+(((-1.0)*x986))+((new_r10*x984)));
evalcond[7]=((((-1.0)*x986*x989))+new_r01+x990);
evalcond[8]=(((sj4*x990))+(((-1.0)*x984*x986))+new_r10);
evalcond[9]=(((sj4*sj5))+(((-1.0)*x996))+x993);
evalcond[10]=((((-1.0)*new_r01*x994))+x991+x987);
evalcond[11]=((((-1.0)*x988*x989))+new_r00+(((-1.0)*x985*x986)));
evalcond[12]=((((-1.0)*cj4*x996))+((new_r20*sj4))+((cj4*x993)));
evalcond[13]=(((cj4*x991))+(((-1.0)*new_r01*x997))+((new_r21*sj4)));
evalcond[14]=(((new_r02*x989))+((cj4*new_r22))+(((-1.0)*sj4*x992)));
evalcond[15]=((1.0)+(((-1.0)*new_r02*x997))+((cj4*x992))+((new_r22*sj4)));
evalcond[16]=(((new_r00*x989))+(((-1.0)*x988))+((cj4*new_r20))+(((-1.0)*sj4*x993)));
evalcond[17]=((((-1.0)*x986))+((cj4*new_r21))+(((-1.0)*sj4*x991))+((new_r01*x989)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x998=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x998.valid){
continue;
}
CheckValue<IkReal> x999 = IKatan2WithCheck(IkReal(new_r02),IkReal(((-1.0)*new_r12)),IKFAST_ATAN2_MAGTHRESH);
if(!x999.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x998.value)))+(x999.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[18];
IkReal x1000=IKsin(j3);
IkReal x1001=IKcos(j3);
IkReal x1002=((1.0)*cj5);
IkReal x1003=(cj5*sj4);
IkReal x1004=((1.0)*sj5);
IkReal x1005=(sj4*x1000);
IkReal x1006=(sj5*x1001);
IkReal x1007=(new_r11*x1001);
IkReal x1008=(new_r12*x1001);
IkReal x1009=(new_r10*x1001);
IkReal x1010=((1.0)*x1000);
IkReal x1011=((1.0)*sj4*x1001);
IkReal x1012=(new_r00*x1010);
IkReal x1013=(cj4*x1010);
evalcond[0]=(((cj4*x1001))+new_r12);
evalcond[1]=((((-1.0)*x1013))+new_r02);
evalcond[2]=(((new_r12*x1000))+((new_r02*x1001)));
evalcond[3]=(sj5+((new_r11*x1000))+((new_r01*x1001)));
evalcond[4]=(x1008+cj4+(((-1.0)*new_r02*x1010)));
evalcond[5]=(((sj5*x1000))+new_r11+((x1001*x1003)));
evalcond[6]=((((-1.0)*x1002))+((new_r10*x1000))+((new_r00*x1001)));
evalcond[7]=(x1006+(((-1.0)*x1002*x1005))+new_r01);
evalcond[8]=(((sj4*x1006))+new_r10+(((-1.0)*x1000*x1002)));
evalcond[9]=(x1009+(((-1.0)*x1012))+((sj4*sj5)));
evalcond[10]=(x1007+x1003+(((-1.0)*new_r01*x1010)));
evalcond[11]=((((-1.0)*x1004*x1005))+(((-1.0)*x1001*x1002))+new_r00);
evalcond[12]=(((new_r20*sj4))+(((-1.0)*cj4*x1012))+((cj4*x1009)));
evalcond[13]=(((cj4*x1007))+(((-1.0)*new_r01*x1013))+((new_r21*sj4)));
evalcond[14]=(((cj4*new_r22))+(((-1.0)*sj4*x1008))+((new_r02*x1005)));
evalcond[15]=((1.0)+(((-1.0)*new_r02*x1013))+((cj4*x1008))+((new_r22*sj4)));
evalcond[16]=((((-1.0)*x1004))+((cj4*new_r20))+(((-1.0)*sj4*x1009))+((new_r00*x1005)));
evalcond[17]=((((-1.0)*x1002))+((cj4*new_r21))+(((-1.0)*sj4*x1007))+((new_r01*x1005)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "ddc94f89b6463162047836185fa58cf1"; }

IKFAST_API const char* GetIkFastVersion() { return "0x1000004a"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif

// start python bindings
// https://github.com/caelan/ss-pybullet/blob/c5efe7ad32381a7a7a15c2bd147b5a8731d21342/pybullet_tools/ikfast/pr2/left_arm_ik.cpp#L12972
// https://github.com/yijiangh/conrob_pybullet/blob/master/utils/ikfast/kuka_kr6_r900/ikfast0x1000004a.Transform6D.0_1_2_3_4_5.cpp#L9923

static PyObject *get_ik(PyObject *self, PyObject *args)
{
    IkSolutionList<IkReal> solutions;

    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9], eetrans[3];

    // First list if 3x3 rotation matrix, easier to compute in Python.
    // Next list is [x, y, z] translation matrix.
    // Last list is free joints.
    PyObject *rotList; // 3x3 rotation matrix
    PyObject *transList; // [x,y,z]
    PyObject *freeList; // can be empty

    // format 'O!': pass C object pointer with the pointer's address.
    if(!PyArg_ParseTuple(args, "O!O!O!", &PyList_Type, &rotList, &PyList_Type, &transList, &PyList_Type, &freeList))
    {
        fprintf(stderr,"Failed to parse input to python objects\n");
        return NULL;
    }

    for(std::size_t i = 0; i < 3; ++i)
    {
        eetrans[i] = PyFloat_AsDouble(PyList_GetItem(transList, i));

        PyObject* rowList = PyList_GetItem(rotList, i);
        for( std::size_t j = 0; j < 3; ++j)
        {
            eerot[3*i + j] = PyFloat_AsDouble(PyList_GetItem(rowList, j));
        }
    }

    for(int i = 0; i < GetNumFreeParameters(); ++i)
    {
        vfree[i] = PyFloat_AsDouble(PyList_GetItem(freeList, i));
    }

    // call ikfast routine
    bool bSuccess = ComputeIk(eetrans, eerot, &vfree[0], solutions);

    if (!bSuccess)
    {
        //fprintf(stderr,"Failed to get ik solution\n");
        return Py_BuildValue(""); // Equivalent to returning None in python
    }

    std::vector<IkReal> solvalues(GetNumJoints());
    PyObject *solutionList = PyList_New(solutions.GetNumSolutions());

    // convert all ikfast solutions into a python list
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i)
    {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);

        PyObject *individualSolution = PyList_New(GetNumJoints());
        for( std::size_t j = 0; j < solvalues.size(); ++j)
        {
            // I think IkReal is just a wrapper for double. So this should work.
            PyList_SetItem(individualSolution, j, PyFloat_FromDouble(solvalues[j]));
        }
        PyList_SetItem(solutionList, i, individualSolution);
    }

    return solutionList;
}

static PyObject *get_fk(PyObject *self, PyObject *args)
{
    std::vector<IkReal> joints(GetNumJoints());
    // eerot is a flattened 3x3 rotation matrix
    IkReal eerot[9], eetrans[3];

    PyObject *jointList;
    if(!PyArg_ParseTuple(args, "O!", &PyList_Type, &jointList))
    {
        return NULL;
    }

    for(std::size_t i = 0; i < GetNumJoints(); ++i)
    {
        joints[i] = PyFloat_AsDouble(PyList_GetItem(jointList, i));
    }

    // call ikfast routine
    ComputeFk(&joints[0], eetrans, eerot);

    // convert computed EE pose to a python object
    PyObject *pose = PyList_New(2);
    PyObject *pos = PyList_New(3);
    PyObject *rot = PyList_New(3);

    for(std::size_t i = 0; i < 3; ++i)
    {
        PyList_SetItem(pos, i, PyFloat_FromDouble(eetrans[i]));

        PyObject *row = PyList_New(3);
        for( std::size_t j = 0; j < 3; ++j)
        {
            PyList_SetItem(row, j, PyFloat_FromDouble(eerot[3*i + j]));
        }
        PyList_SetItem(rot, i, row);
    }

    PyList_SetItem(pose, 0, pos);
    PyList_SetItem(pose, 1, rot);

    return pose;
}

static PyMethodDef ikfast_methods[] =
{
    {"get_ik", get_ik, METH_VARARGS, "Compute ik solutions using ikfast."},
    {"get_fk", get_fk, METH_VARARGS, "Compute fk solutions using ikfast."},
    {NULL, NULL, 0, NULL}
    // Not sure why/if this is needed. It shows up in the examples though(something about Sentinel).
};

#if PY_MAJOR_VERSION >= 3

static struct PyModuleDef ikfast_assistive_human_module = {
    PyModuleDef_HEAD_INIT,
    "ikfast_assistive_human",   /* name of module */
    NULL, /* module documentation, may be NULL */
    -1,       /* size of per-interpreter state of the module,
                 or -1 if the module keeps state in global variables. */
    ikfast_methods
};

#define INITERROR return NULL

PyMODINIT_FUNC
PyInit_ikfast_assistive_human(void)

#else // PY_MAJOR_VERSION < 3
#define INITERROR return

PyMODINIT_FUNC
initikfast_assistive_human(void)
#endif
{
#if PY_MAJOR_VERSION >= 3
    PyObject *module = PyModule_Create(&ikfast_assistive_human_module);
#else
    PyObject *module = Py_InitModule("ikfast_assistive_human", ikfast_methods);
#endif

if (module == NULL)
    INITERROR;

#if PY_MAJOR_VERSION >= 3
    return module;
#endif
}

// end python bindings
